
==================== Cmm produced by new codegen ====================
2016-08-01 18:20:37.378257 UTC

[section "data" { __stginit_main@main:Main:
 }]


==================== Post CPS Cmm ====================
2016-08-01 18:20:37.379286 UTC

[section "data" { __stginit_main@main:Main:
 }]


==================== Output Cmm ====================
2016-08-01 18:20:37.380095 UTC

[section "data" { __stginit_main@main:Main:
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:20:37.382411 UTC

[section "data" {
     mkfoo_rnV_closure:
         const mkfoo_rnV_info;
 },
 mkfoo_rnV_entry() //  []
         { info_tbl: [(c1cS,
                       label: mkfoo_rnV_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 16 updfr_space: Just 8
         }
     {offset
       c1cS:
           _B1::P64 = P64[(old + 16)];
           goto c1cP;
       c1cP:
           if ((old + 0) - <highSp> < SpLim) goto c1cT; else goto c1cU;
       c1cU:
           goto c1cO;
       c1cO:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c1cW; else goto c1cV;
       c1cW:
           HpAlloc = 16;
           goto c1cT;
       c1cT:
           R1 = mkfoo_rnV_closure;
           P64[(old + 16)] = _B1::P64;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c1cV:
           I64[Hp - 8] = Foo_con_info;
           P64[Hp] = _B1::P64;
           _c1cR::P64 = Hp - 7;
           R1 = _c1cR::P64;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-01 18:20:37.38778 UTC

{offset
  c1cS:
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c1cT; else goto c1cU;
  c1cU:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c1cW; else goto c1cV;
  c1cW:
      HpAlloc = 16;
      goto c1cT;
  c1cT:
      R1 = mkfoo_rnV_closure;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c1cV:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c1cR::P64 = Hp - 7;
      R1 = _c1cR::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-01 18:20:37.392254 UTC

mkfoo_rnV_entry
[c1cS]
{offset
  c1cS:
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c1cT; else goto c1cU;
  c1cU:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c1cW; else goto c1cV;
  c1cW:
      HpAlloc = 16;
      goto c1cT;
  c1cT:
      R1 = mkfoo_rnV_closure;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c1cV:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c1cR::P64 = Hp - 7;
      R1 = _c1cR::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-01 18:20:37.395719 UTC

{offset
  c1cS:
      _B1::P64 = P64[Sp];
      goto c1cU;
  c1cU:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c1cW; else goto c1cV;
  c1cW:
      HpAlloc = 16;
      goto c1cT;
  c1cT:
      R1 = mkfoo_rnV_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c1cV:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c1cR::P64 = Hp - 7;
      R1 = _c1cR::P64;
      Sp = Sp + 8;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-01 18:20:37.398043 UTC

[(c1cS, {}), (c1cT, {}), (c1cU, {}), (c1cV, {}), (c1cW, {})]


==================== procpoint map ====================
2016-08-01 18:20:37.399096 UTC

[(c1cS, <procpt>), (c1cT, reached by c1cS),
 (c1cU, reached by c1cS), (c1cV, reached by c1cS),
 (c1cW, reached by c1cS)]


==================== Post splitting ====================
2016-08-01 18:20:37.400254 UTC

mkfoo_rnV_entry() //  []
        { info_tbl: [(c1cS,
                      label: mkfoo_rnV_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1cS:
          _B1::P64 = P64[Sp];
          goto c1cU;
      c1cU:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c1cW; else goto c1cV;
      c1cW:
          HpAlloc = 16;
          goto c1cT;
      c1cT:
          R1 = mkfoo_rnV_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c1cV:
          I64[Hp - 8] = Foo_con_info;
          P64[Hp] = _B1::P64;
          _c1cR::P64 = Hp - 7;
          R1 = _c1cR::P64;
          Sp = Sp + 8;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:37.404296 UTC

mkfoo_rnV_entry() //  []
        { info_tbl: [(c1cS,
                      label: mkfoo_rnV_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1cS:
          _B1::P64 = P64[Sp];
          goto c1cU;
      c1cU:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c1cW; else goto c1cV;
      c1cW:
          HpAlloc = 16;
          goto c1cT;
      c1cT:
          R1 = mkfoo_rnV_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c1cV:
          I64[Hp - 8] = Foo_con_info;
          P64[Hp] = _B1::P64;
          _c1cR::P64 = Hp - 7;
          R1 = _c1cR::P64;
          Sp = Sp + 8;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:37.40727 UTC

mkfoo_rnV_entry() //  []
        { info_tbl: [(c1cS,
                      label: mkfoo_rnV_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1cS:
          _B1::P64 = P64[Sp];
          goto c1cU;
      c1cU:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c1cW; else goto c1cV;
      c1cW:
          HpAlloc = 16;
          goto c1cT;
      c1cT:
          R1 = mkfoo_rnV_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c1cV:
          I64[Hp - 8] = Foo_con_info;
          P64[Hp] = _B1::P64;
          _c1cR::P64 = Hp - 7;
          R1 = _c1cR::P64;
          Sp = Sp + 8;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-01 18:20:37.410247 UTC

[section "data" {
     mkfoo_rnV_closure:
         const mkfoo_rnV_info;
 },
 mkfoo_rnV_entry() //  []
         { info_tbl: [(c1cS,
                       label: mkfoo_rnV_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1cS:
           _B1::P64 = P64[Sp];
           goto c1cU;
       c1cU:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c1cW; else goto c1cV;
       c1cW:
           HpAlloc = 16;
           goto c1cT;
       c1cT:
           R1 = mkfoo_rnV_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c1cV:
           I64[Hp - 8] = Foo_con_info;
           P64[Hp] = _B1::P64;
           _c1cR::P64 = Hp - 7;
           R1 = _c1cR::P64;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-01 18:20:37.413581 UTC

[section "data" {
     mkfoo_rnV_closure:
         const mkfoo_rnV_info;
 },
 mkfoo_rnV_entry() //  []
         { info_tbl: [(c1cS,
                       label: mkfoo_rnV_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1cS:
           _B1::P64 = P64[Sp];
           goto c1cU;
       c1cU:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c1cW; else goto c1cV;
       c1cW:
           HpAlloc = 16;
           goto c1cT;
       c1cT:
           R1 = mkfoo_rnV_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c1cV:
           I64[Hp - 8] = Foo_con_info;
           P64[Hp] = _B1::P64;
           _c1cR::P64 = Hp - 7;
           R1 = _c1cR::P64;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:20:37.4391 UTC

[section "data" {
     $cshowsPrec_r18d_closure:
         const $cshowsPrec_r18d_info;
         const 0;
 },
 sat_s1bK_entry() //  [R1]
         { info_tbl: [(c1eq,
                       label: sat_s1bK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c1eq:
           _s1bK::P64 = R1;
           goto c1eo;
       c1eo:
           if ((old + 0) - <highSp> < SpLim) goto c1er; else goto c1es;
       c1er:
           R1 = _s1bK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1es:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _s1bK::P64;
           _s1bE::P64 = P64[_s1bK::P64 + 16];
           P64[(old + 56)] = $fShowInt_closure;
           I64[(old + 48)] = stg_ap_pp_info;
           P64[(old + 40)] = stg_INTLIKE_closure+433;
           P64[(old + 32)] = _s1bE::P64;
           call showsPrec_entry() args: 56, res: 0, upd: 24;
     }
 },
 section "readonly" {
     c1eB_str:
         I8[] [70,111,111,32]
 },
 sat_s1bH_entry() //  [R1]
         { info_tbl: [(c1eC,
                       label: sat_s1bH_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c1eC:
           _s1bH::P64 = R1;
           goto c1ez;
       c1ez:
           if ((old + 0) - <highSp> < SpLim) goto c1eD; else goto c1eE;
       c1eD:
           R1 = _s1bH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1eE:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _s1bH::P64;
           R1 = unpackCString#_closure;
           I64[(old + 32)] = c1eB_str;
           call stg_ap_n_fast(R1) args: 32, res: 0, upd: 24;
     }
 },
 sat_s1bI_entry() //  [R1]
         { info_tbl: [(c1eF,
                       label: sat_s1bI_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c1eF:
           _s1bI::P64 = R1;
           goto c1ev;
       c1ev:
           if ((old + 0) - <highSp> < SpLim) goto c1eG; else goto c1eH;
       c1eH:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c1eJ; else goto c1eI;
       c1eJ:
           HpAlloc = 16;
           goto c1eG;
       c1eG:
           R1 = _s1bI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1eI:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _s1bI::P64;
           I64[Hp - 8] = sat_s1bH_info;
           _c1ex::P64 = Hp - 8;
           R1 = showString_closure;
           P64[(old + 32)] = _c1ex::P64;
           call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
     }
 },
 sat_s1bL_entry() //  [R1]
         { info_tbl: [(c1eK,
                       label: sat_s1bL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c1eK:
           _s1bL::P64 = R1;
           goto c1ek;
       c1ek:
           if ((old + 0) - <highSp> < SpLim) goto c1eL; else goto c1eM;
       c1eM:
           Hp = Hp + 40;
           if (Hp > HpLim) goto c1eO; else goto c1eN;
       c1eO:
           HpAlloc = 40;
           goto c1eL;
       c1eL:
           R1 = _s1bL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1eN:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _s1bL::P64;
           _s1bE::P64 = P64[_s1bL::P64 + 16];
           I64[Hp - 32] = sat_s1bK_info;
           P64[Hp - 16] = _s1bE::P64;
           _c1em::P64 = Hp - 32;
           I64[Hp - 8] = sat_s1bI_info;
           _c1et::P64 = Hp - 8;
           R1 = ._closure;
           P64[(old + 40)] = _c1et::P64;
           P64[(old + 32)] = _c1em::P64;
           call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1bG_entry() //  [R1]
         { info_tbl: [(c1eT,
                       label: sat_s1bG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c1eT:
           _s1bG::P64 = R1;
           goto c1eR;
       c1eR:
           if ((old + 0) - <highSp> < SpLim) goto c1eU; else goto c1eV;
       c1eU:
           R1 = _s1bG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1eV:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _s1bG::P64;
           _s1bB::P64 = P64[_s1bG::P64 + 16];
           P64[(old + 56)] = $fOrdInt_closure;
           I64[(old + 48)] = stg_ap_pp_info;
           P64[(old + 40)] = _s1bB::P64;
           P64[(old + 32)] = stg_INTLIKE_closure+433;
           call >=_entry() args: 56, res: 0, upd: 24;
     }
 },
 $cshowsPrec_r18d_entry() //  []
         { info_tbl: [(c1eW,
                       label: $cshowsPrec_r18d_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 24 updfr_space: Just 8
         }
     {offset
       c1eW:
           _s1bB::P64 = P64[(old + 24)];
           _s1bC::P64 = P64[(old + 16)];
           goto c1eb;
       c1eb:
           if ((old + 0) - <highSp> < SpLim) goto c1eX; else goto c1eY;
       c1eX:
           R1 = $cshowsPrec_r18d_closure;
           P64[(old + 24)] = _s1bB::P64;
           P64[(old + 16)] = _s1bC::P64;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
       c1eY:
           goto c1ea;
       c1ea:
           I64[(young<c1ed> + 8)] = c1ed;
           R1 = _s1bC::P64;
           if (R1 & 7 != 0) goto c1ed; else goto c1ee;
       c1ee:
           call (I64[I64[R1]])(R1) returns to c1ed, args: 8, res: 8, upd: 8;
       c1ed:
           _s1bD::P64 = R1;
           Hp = Hp + 48;
           if (Hp > HpLim) goto c1f1; else goto c1f0;
       c1f1:
           HpAlloc = 48;
           goto c1eZ;
       c1eZ:
           R1 = _s1bD::P64;
           call stg_gc_unpt_r1(R1) returns to c1ed, args: 8, res: 8, upd: 8;
       c1f0:
           _s1bE::P64 = P64[_s1bD::P64 + 7];
           I64[Hp - 40] = sat_s1bL_info;
           P64[Hp - 24] = _s1bE::P64;
           _c1ei::P64 = Hp - 40;
           I64[Hp - 16] = sat_s1bG_info;
           P64[Hp] = _s1bB::P64;
           _c1eP::P64 = Hp - 16;
           R1 = showParen_closure;
           P64[(old + 24)] = _c1eP::P64;
           P64[(old + 16)] = _c1ei::P64;
           call stg_ap_pp_fast(R1) args: 24, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-01 18:20:37.463479 UTC

{offset
  c1eq:
      _s1bK::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1er; else goto c1es;
  c1er:
      R1 = _s1bK::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1es:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1bK::P64;
      _s1bE::P64 = P64[_s1bK::P64 + 16];
      P64[(old + 56)] = $fShowInt_closure;
      I64[(old + 48)] = stg_ap_pp_info;
      P64[(old + 40)] = stg_INTLIKE_closure+433;
      P64[(old + 32)] = _s1bE::P64;
      call showsPrec_entry() args: 56, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-01 18:20:37.465942 UTC

sat_s1bK_entry
[c1eq]
{offset
  c1eq:
      _s1bK::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1er; else goto c1es;
  c1er:
      R1 = _s1bK::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1es:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1bK::P64;
      _s1bE::P64 = P64[_s1bK::P64 + 16];
      P64[(old + 56)] = $fShowInt_closure;
      I64[(old + 48)] = stg_ap_pp_info;
      P64[(old + 40)] = stg_INTLIKE_closure+433;
      P64[(old + 32)] = _s1bE::P64;
      call showsPrec_entry() args: 56, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-01 18:20:37.468913 UTC

{offset
  c1eq:
      _s1bK::P64 = R1;
      if ((Sp + 8) - 56 < SpLim) goto c1er; else goto c1es;
  c1er:
      R1 = _s1bK::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1es:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _s1bK::P64;
      _s1bE::P64 = P64[_s1bK::P64 + 16];
      P64[Sp - 48] = $fShowInt_closure;
      I64[Sp - 40] = stg_ap_pp_info;
      P64[Sp - 32] = stg_INTLIKE_closure+433;
      P64[Sp - 24] = _s1bE::P64;
      Sp = Sp - 48;
      call showsPrec_entry() args: 56, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-01 18:20:37.471457 UTC

[(c1eq, {$fShowInt_closure}), (c1er, {}),
 (c1es, {$fShowInt_closure})]


==================== procpoint map ====================
2016-08-01 18:20:37.472431 UTC

[(c1eq, <procpt>), (c1er, reached by c1eq),
 (c1es, reached by c1eq)]


==================== Post splitting ====================
2016-08-01 18:20:37.473351 UTC

sat_s1bK_entry() //  [R1]
        { info_tbl: [(c1eq,
                      label: sat_s1bK_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1eq:
          _s1bK::P64 = R1;
          if ((Sp + 8) - 56 < SpLim) goto c1er; else goto c1es;
      c1er:
          R1 = _s1bK::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1es:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bK::P64;
          _s1bE::P64 = P64[_s1bK::P64 + 16];
          P64[Sp - 48] = $fShowInt_closure;
          I64[Sp - 40] = stg_ap_pp_info;
          P64[Sp - 32] = stg_INTLIKE_closure+433;
          P64[Sp - 24] = _s1bE::P64;
          Sp = Sp - 48;
          call showsPrec_entry() args: 56, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:37.476594 UTC

sat_s1bK_entry() //  [R1]
        { info_tbl: [(c1eq,
                      label: sat_s1bK_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1eq:
          _s1bK::P64 = R1;
          if ((Sp + 8) - 56 < SpLim) goto c1er; else goto c1es;
      c1er:
          R1 = _s1bK::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1es:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bK::P64;
          _s1bE::P64 = P64[_s1bK::P64 + 16];
          P64[Sp - 48] = $fShowInt_closure;
          I64[Sp - 40] = stg_ap_pp_info;
          P64[Sp - 32] = stg_INTLIKE_closure+433;
          P64[Sp - 24] = _s1bE::P64;
          Sp = Sp - 48;
          call showsPrec_entry() args: 56, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:37.47967 UTC

sat_s1bK_entry() //  [R1]
        { info_tbl: [(c1eq,
                      label: sat_s1bK_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1eq:
          _s1bK::P64 = R1;
          if ((Sp + 8) - 56 < SpLim) goto c1er; else goto c1es;
      c1er:
          R1 = _s1bK::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1es:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bK::P64;
          _s1bE::P64 = P64[_s1bK::P64 + 16];
          P64[Sp - 48] = $fShowInt_closure;
          I64[Sp - 40] = stg_ap_pp_info;
          P64[Sp - 32] = stg_INTLIKE_closure+433;
          P64[Sp - 24] = _s1bE::P64;
          Sp = Sp - 48;
          call showsPrec_entry() args: 56, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:37.483012 UTC

{offset
  c1eC:
      _s1bH::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1eD; else goto c1eE;
  c1eD:
      R1 = _s1bH::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1eE:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1bH::P64;
      R1 = unpackCString#_closure;
      I64[(old + 32)] = c1eB_str;
      call stg_ap_n_fast(R1) args: 32, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-01 18:20:37.484958 UTC

sat_s1bH_entry
[c1eC]
{offset
  c1eC:
      _s1bH::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1eD; else goto c1eE;
  c1eD:
      R1 = _s1bH::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1eE:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1bH::P64;
      R1 = unpackCString#_closure;
      I64[(old + 32)] = c1eB_str;
      call stg_ap_n_fast(R1) args: 32, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-01 18:20:37.487298 UTC

{offset
  c1eC:
      _s1bH::P64 = R1;
      if ((Sp + 8) - 32 < SpLim) goto c1eD; else goto c1eE;
  c1eD:
      R1 = _s1bH::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1eE:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _s1bH::P64;
      R1 = unpackCString#_closure;
      I64[Sp - 24] = c1eB_str;
      Sp = Sp - 24;
      call stg_ap_n_fast(R1) args: 32, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-01 18:20:37.48932 UTC

[(c1eC, {unpackCString#_closure}), (c1eD, {}),
 (c1eE, {unpackCString#_closure})]


==================== procpoint map ====================
2016-08-01 18:20:37.490277 UTC

[(c1eC, <procpt>), (c1eD, reached by c1eC),
 (c1eE, reached by c1eC)]


==================== Post splitting ====================
2016-08-01 18:20:37.491223 UTC

sat_s1bH_entry() //  [R1]
        { info_tbl: [(c1eC,
                      label: sat_s1bH_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1eC:
          _s1bH::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1eD; else goto c1eE;
      c1eD:
          R1 = _s1bH::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1eE:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bH::P64;
          R1 = unpackCString#_closure;
          I64[Sp - 24] = c1eB_str;
          Sp = Sp - 24;
          call stg_ap_n_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:37.495 UTC

sat_s1bH_entry() //  [R1]
        { info_tbl: [(c1eC,
                      label: sat_s1bH_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1eC:
          _s1bH::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1eD; else goto c1eE;
      c1eD:
          R1 = _s1bH::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1eE:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bH::P64;
          R1 = unpackCString#_closure;
          I64[Sp - 24] = c1eB_str;
          Sp = Sp - 24;
          call stg_ap_n_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:37.49755 UTC

sat_s1bH_entry() //  [R1]
        { info_tbl: [(c1eC,
                      label: sat_s1bH_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1eC:
          _s1bH::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1eD; else goto c1eE;
      c1eD:
          R1 = _s1bH::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1eE:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bH::P64;
          R1 = unpackCString#_closure;
          I64[Sp - 24] = c1eB_str;
          Sp = Sp - 24;
          call stg_ap_n_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:37.50035 UTC

{offset
  c1eF:
      _s1bI::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1eG; else goto c1eH;
  c1eH:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c1eJ; else goto c1eI;
  c1eJ:
      HpAlloc = 16;
      goto c1eG;
  c1eG:
      R1 = _s1bI::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1eI:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1bI::P64;
      I64[Hp - 8] = sat_s1bH_info;
      _c1ex::P64 = Hp - 8;
      R1 = showString_closure;
      P64[(old + 32)] = _c1ex::P64;
      call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-01 18:20:37.503063 UTC

sat_s1bI_entry
[c1eF]
{offset
  c1eF:
      _s1bI::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1eG; else goto c1eH;
  c1eH:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c1eJ; else goto c1eI;
  c1eJ:
      HpAlloc = 16;
      goto c1eG;
  c1eG:
      R1 = _s1bI::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1eI:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1bI::P64;
      I64[Hp - 8] = sat_s1bH_info;
      _c1ex::P64 = Hp - 8;
      R1 = showString_closure;
      P64[(old + 32)] = _c1ex::P64;
      call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-01 18:20:37.506253 UTC

{offset
  c1eF:
      _s1bI::P64 = R1;
      if ((Sp + 8) - 32 < SpLim) goto c1eG; else goto c1eH;
  c1eH:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c1eJ; else goto c1eI;
  c1eJ:
      HpAlloc = 16;
      goto c1eG;
  c1eG:
      R1 = _s1bI::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1eI:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _s1bI::P64;
      I64[Hp - 8] = sat_s1bH_info;
      _c1ex::P64 = Hp - 8;
      R1 = showString_closure;
      P64[Sp - 24] = _c1ex::P64;
      Sp = Sp - 24;
      call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-01 18:20:37.508893 UTC

[(c1eF, {showString_closure, sat_s1bH_closure}), (c1eG, {}),
 (c1eH, {showString_closure, sat_s1bH_closure}),
 (c1eI, {showString_closure, sat_s1bH_closure}), (c1eJ, {})]


==================== procpoint map ====================
2016-08-01 18:20:37.510232 UTC

[(c1eF, <procpt>), (c1eG, reached by c1eF),
 (c1eH, reached by c1eF), (c1eI, reached by c1eF),
 (c1eJ, reached by c1eF)]


==================== Post splitting ====================
2016-08-01 18:20:37.511373 UTC

sat_s1bI_entry() //  [R1]
        { info_tbl: [(c1eF,
                      label: sat_s1bI_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1eF:
          _s1bI::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1eG; else goto c1eH;
      c1eH:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c1eJ; else goto c1eI;
      c1eJ:
          HpAlloc = 16;
          goto c1eG;
      c1eG:
          R1 = _s1bI::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1eI:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bI::P64;
          I64[Hp - 8] = sat_s1bH_info;
          _c1ex::P64 = Hp - 8;
          R1 = showString_closure;
          P64[Sp - 24] = _c1ex::P64;
          Sp = Sp - 24;
          call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:37.51482 UTC

sat_s1bI_entry() //  [R1]
        { info_tbl: [(c1eF,
                      label: sat_s1bI_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1eF:
          _s1bI::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1eG; else goto c1eH;
      c1eH:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c1eJ; else goto c1eI;
      c1eJ:
          HpAlloc = 16;
          goto c1eG;
      c1eG:
          R1 = _s1bI::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1eI:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bI::P64;
          I64[Hp - 8] = sat_s1bH_info;
          _c1ex::P64 = Hp - 8;
          R1 = showString_closure;
          P64[Sp - 24] = _c1ex::P64;
          Sp = Sp - 24;
          call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:37.518033 UTC

sat_s1bI_entry() //  [R1]
        { info_tbl: [(c1eF,
                      label: sat_s1bI_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1eF:
          _s1bI::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1eG; else goto c1eH;
      c1eH:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c1eJ; else goto c1eI;
      c1eJ:
          HpAlloc = 16;
          goto c1eG;
      c1eG:
          R1 = _s1bI::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1eI:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bI::P64;
          I64[Hp - 8] = sat_s1bH_info;
          _c1ex::P64 = Hp - 8;
          R1 = showString_closure;
          P64[Sp - 24] = _c1ex::P64;
          Sp = Sp - 24;
          call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:37.521593 UTC

{offset
  c1eK:
      _s1bL::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1eL; else goto c1eM;
  c1eM:
      Hp = Hp + 40;
      if (Hp > HpLim) goto c1eO; else goto c1eN;
  c1eO:
      HpAlloc = 40;
      goto c1eL;
  c1eL:
      R1 = _s1bL::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1eN:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1bL::P64;
      _s1bE::P64 = P64[_s1bL::P64 + 16];
      I64[Hp - 32] = sat_s1bK_info;
      P64[Hp - 16] = _s1bE::P64;
      _c1em::P64 = Hp - 32;
      I64[Hp - 8] = sat_s1bI_info;
      _c1et::P64 = Hp - 8;
      R1 = ._closure;
      P64[(old + 40)] = _c1et::P64;
      P64[(old + 32)] = _c1em::P64;
      call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-01 18:20:37.524876 UTC

sat_s1bL_entry
[c1eK]
{offset
  c1eK:
      _s1bL::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1eL; else goto c1eM;
  c1eM:
      Hp = Hp + 40;
      if (Hp > HpLim) goto c1eO; else goto c1eN;
  c1eO:
      HpAlloc = 40;
      goto c1eL;
  c1eL:
      R1 = _s1bL::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1eN:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1bL::P64;
      _s1bE::P64 = P64[_s1bL::P64 + 16];
      I64[Hp - 32] = sat_s1bK_info;
      P64[Hp - 16] = _s1bE::P64;
      _c1em::P64 = Hp - 32;
      I64[Hp - 8] = sat_s1bI_info;
      _c1et::P64 = Hp - 8;
      R1 = ._closure;
      P64[(old + 40)] = _c1et::P64;
      P64[(old + 32)] = _c1em::P64;
      call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-01 18:20:37.528753 UTC

{offset
  c1eK:
      _s1bL::P64 = R1;
      if ((Sp + 8) - 40 < SpLim) goto c1eL; else goto c1eM;
  c1eM:
      Hp = Hp + 40;
      if (Hp > HpLim) goto c1eO; else goto c1eN;
  c1eO:
      HpAlloc = 40;
      goto c1eL;
  c1eL:
      R1 = _s1bL::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1eN:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _s1bL::P64;
      _s1bE::P64 = P64[_s1bL::P64 + 16];
      I64[Hp - 32] = sat_s1bK_info;
      P64[Hp - 16] = _s1bE::P64;
      _c1em::P64 = Hp - 32;
      I64[Hp - 8] = sat_s1bI_info;
      _c1et::P64 = Hp - 8;
      R1 = ._closure;
      P64[Sp - 32] = _c1et::P64;
      P64[Sp - 24] = _c1em::P64;
      Sp = Sp - 32;
      call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-01 18:20:37.532154 UTC

[(c1eK, {._closure, sat_s1bI_closure, sat_s1bK_closure}),
 (c1eL, {}),
 (c1eM, {._closure, sat_s1bI_closure, sat_s1bK_closure}),
 (c1eN, {._closure, sat_s1bI_closure, sat_s1bK_closure}),
 (c1eO, {})]


==================== procpoint map ====================
2016-08-01 18:20:37.533715 UTC

[(c1eK, <procpt>), (c1eL, reached by c1eK),
 (c1eM, reached by c1eK), (c1eN, reached by c1eK),
 (c1eO, reached by c1eK)]


==================== Post splitting ====================
2016-08-01 18:20:37.534845 UTC

sat_s1bL_entry() //  [R1]
        { info_tbl: [(c1eK,
                      label: sat_s1bL_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1eK:
          _s1bL::P64 = R1;
          if ((Sp + 8) - 40 < SpLim) goto c1eL; else goto c1eM;
      c1eM:
          Hp = Hp + 40;
          if (Hp > HpLim) goto c1eO; else goto c1eN;
      c1eO:
          HpAlloc = 40;
          goto c1eL;
      c1eL:
          R1 = _s1bL::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1eN:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bL::P64;
          _s1bE::P64 = P64[_s1bL::P64 + 16];
          I64[Hp - 32] = sat_s1bK_info;
          P64[Hp - 16] = _s1bE::P64;
          _c1em::P64 = Hp - 32;
          I64[Hp - 8] = sat_s1bI_info;
          _c1et::P64 = Hp - 8;
          R1 = ._closure;
          P64[Sp - 32] = _c1et::P64;
          P64[Sp - 24] = _c1em::P64;
          Sp = Sp - 32;
          call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:37.539058 UTC

sat_s1bL_entry() //  [R1]
        { info_tbl: [(c1eK,
                      label: sat_s1bL_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1eK:
          _s1bL::P64 = R1;
          if ((Sp + 8) - 40 < SpLim) goto c1eL; else goto c1eM;
      c1eM:
          Hp = Hp + 40;
          if (Hp > HpLim) goto c1eO; else goto c1eN;
      c1eO:
          HpAlloc = 40;
          goto c1eL;
      c1eL:
          R1 = _s1bL::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1eN:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bL::P64;
          _s1bE::P64 = P64[_s1bL::P64 + 16];
          I64[Hp - 32] = sat_s1bK_info;
          P64[Hp - 16] = _s1bE::P64;
          _c1em::P64 = Hp - 32;
          I64[Hp - 8] = sat_s1bI_info;
          _c1et::P64 = Hp - 8;
          R1 = ._closure;
          P64[Sp - 32] = _c1et::P64;
          P64[Sp - 24] = _c1em::P64;
          Sp = Sp - 32;
          call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:37.543359 UTC

sat_s1bL_entry() //  [R1]
        { info_tbl: [(c1eK,
                      label: sat_s1bL_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1eK:
          _s1bL::P64 = R1;
          if ((Sp + 8) - 40 < SpLim) goto c1eL; else goto c1eM;
      c1eM:
          Hp = Hp + 40;
          if (Hp > HpLim) goto c1eO; else goto c1eN;
      c1eO:
          HpAlloc = 40;
          goto c1eL;
      c1eL:
          R1 = _s1bL::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1eN:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bL::P64;
          _s1bE::P64 = P64[_s1bL::P64 + 16];
          I64[Hp - 32] = sat_s1bK_info;
          P64[Hp - 16] = _s1bE::P64;
          _c1em::P64 = Hp - 32;
          I64[Hp - 8] = sat_s1bI_info;
          _c1et::P64 = Hp - 8;
          R1 = ._closure;
          P64[Sp - 32] = _c1et::P64;
          P64[Sp - 24] = _c1em::P64;
          Sp = Sp - 32;
          call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:37.548318 UTC

{offset
  c1eT:
      _s1bG::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1eU; else goto c1eV;
  c1eU:
      R1 = _s1bG::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1eV:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1bG::P64;
      _s1bB::P64 = P64[_s1bG::P64 + 16];
      P64[(old + 56)] = $fOrdInt_closure;
      I64[(old + 48)] = stg_ap_pp_info;
      P64[(old + 40)] = _s1bB::P64;
      P64[(old + 32)] = stg_INTLIKE_closure+433;
      call >=_entry() args: 56, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-01 18:20:37.550726 UTC

sat_s1bG_entry
[c1eT]
{offset
  c1eT:
      _s1bG::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1eU; else goto c1eV;
  c1eU:
      R1 = _s1bG::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1eV:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1bG::P64;
      _s1bB::P64 = P64[_s1bG::P64 + 16];
      P64[(old + 56)] = $fOrdInt_closure;
      I64[(old + 48)] = stg_ap_pp_info;
      P64[(old + 40)] = _s1bB::P64;
      P64[(old + 32)] = stg_INTLIKE_closure+433;
      call >=_entry() args: 56, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-01 18:20:37.553639 UTC

{offset
  c1eT:
      _s1bG::P64 = R1;
      if ((Sp + 8) - 56 < SpLim) goto c1eU; else goto c1eV;
  c1eU:
      R1 = _s1bG::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1eV:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _s1bG::P64;
      _s1bB::P64 = P64[_s1bG::P64 + 16];
      P64[Sp - 48] = $fOrdInt_closure;
      I64[Sp - 40] = stg_ap_pp_info;
      P64[Sp - 32] = _s1bB::P64;
      P64[Sp - 24] = stg_INTLIKE_closure+433;
      Sp = Sp - 48;
      call >=_entry() args: 56, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-01 18:20:37.556126 UTC

[(c1eT, {$fOrdInt_closure}), (c1eU, {}),
 (c1eV, {$fOrdInt_closure})]


==================== procpoint map ====================
2016-08-01 18:20:37.557102 UTC

[(c1eT, <procpt>), (c1eU, reached by c1eT),
 (c1eV, reached by c1eT)]


==================== Post splitting ====================
2016-08-01 18:20:37.558009 UTC

sat_s1bG_entry() //  [R1]
        { info_tbl: [(c1eT,
                      label: sat_s1bG_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1eT:
          _s1bG::P64 = R1;
          if ((Sp + 8) - 56 < SpLim) goto c1eU; else goto c1eV;
      c1eU:
          R1 = _s1bG::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1eV:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bG::P64;
          _s1bB::P64 = P64[_s1bG::P64 + 16];
          P64[Sp - 48] = $fOrdInt_closure;
          I64[Sp - 40] = stg_ap_pp_info;
          P64[Sp - 32] = _s1bB::P64;
          P64[Sp - 24] = stg_INTLIKE_closure+433;
          Sp = Sp - 48;
          call >=_entry() args: 56, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:37.56132 UTC

sat_s1bG_entry() //  [R1]
        { info_tbl: [(c1eT,
                      label: sat_s1bG_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1eT:
          _s1bG::P64 = R1;
          if ((Sp + 8) - 56 < SpLim) goto c1eU; else goto c1eV;
      c1eU:
          R1 = _s1bG::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1eV:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bG::P64;
          _s1bB::P64 = P64[_s1bG::P64 + 16];
          P64[Sp - 48] = $fOrdInt_closure;
          I64[Sp - 40] = stg_ap_pp_info;
          P64[Sp - 32] = _s1bB::P64;
          P64[Sp - 24] = stg_INTLIKE_closure+433;
          Sp = Sp - 48;
          call >=_entry() args: 56, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:37.564376 UTC

sat_s1bG_entry() //  [R1]
        { info_tbl: [(c1eT,
                      label: sat_s1bG_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1eT:
          _s1bG::P64 = R1;
          if ((Sp + 8) - 56 < SpLim) goto c1eU; else goto c1eV;
      c1eU:
          R1 = _s1bG::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1eV:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bG::P64;
          _s1bB::P64 = P64[_s1bG::P64 + 16];
          P64[Sp - 48] = $fOrdInt_closure;
          I64[Sp - 40] = stg_ap_pp_info;
          P64[Sp - 32] = _s1bB::P64;
          P64[Sp - 24] = stg_INTLIKE_closure+433;
          Sp = Sp - 48;
          call >=_entry() args: 56, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:37.567907 UTC

{offset
  c1eW:
      _s1bB::P64 = P64[(old + 24)];
      _s1bC::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c1eX; else goto c1eY;
  c1eX:
      R1 = $cshowsPrec_r18d_closure;
      P64[(old + 24)] = _s1bB::P64;
      P64[(old + 16)] = _s1bC::P64;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c1eY:
      I64[(young<c1ed> + 8)] = c1ed;
      R1 = _s1bC::P64;
      if (R1 & 7 != 0) goto c1ed; else goto c1ee;
  c1ee:
      call (I64[I64[R1]])(R1) returns to c1ed, args: 8, res: 8, upd: 8;
  c1ed:
      _s1bD::P64 = R1;
      Hp = Hp + 48;
      if (Hp > HpLim) goto c1f1; else goto c1f0;
  c1f1:
      HpAlloc = 48;
      R1 = _s1bD::P64;
      call stg_gc_unpt_r1(R1) returns to c1ed, args: 8, res: 8, upd: 8;
  c1f0:
      _s1bE::P64 = P64[_s1bD::P64 + 7];
      I64[Hp - 40] = sat_s1bL_info;
      P64[Hp - 24] = _s1bE::P64;
      _c1ei::P64 = Hp - 40;
      I64[Hp - 16] = sat_s1bG_info;
      P64[Hp] = _s1bB::P64;
      _c1eP::P64 = Hp - 16;
      R1 = showParen_closure;
      P64[(old + 24)] = _c1eP::P64;
      P64[(old + 16)] = _c1ei::P64;
      call stg_ap_pp_fast(R1) args: 24, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-01 18:20:37.572632 UTC

$cshowsPrec_r18d_entry
[c1ed, c1eW]
{offset
  c1eW:
      _s1bB::P64 = P64[(old + 24)];
      _s1bC::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c1eX; else goto c1eY;
  c1eX:
      R1 = $cshowsPrec_r18d_closure;
      P64[(old + 24)] = _s1bB::P64;
      P64[(old + 16)] = _s1bC::P64;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c1eY:
      I64[(young<c1ed> + 8)] = c1ed;
      R1 = _s1bC::P64;
      if (R1 & 7 != 0) goto c1ed; else goto c1ee;
  c1ee:
      call (I64[I64[R1]])(R1) returns to c1ed, args: 8, res: 8, upd: 8;
  c1ed:
      _s1bD::P64 = R1;
      Hp = Hp + 48;
      if (Hp > HpLim) goto c1f1; else goto c1f0;
  c1f1:
      HpAlloc = 48;
      R1 = _s1bD::P64;
      call stg_gc_unpt_r1(R1) returns to c1ed, args: 8, res: 8, upd: 8;
  c1f0:
      _s1bE::P64 = P64[_s1bD::P64 + 7];
      I64[Hp - 40] = sat_s1bL_info;
      P64[Hp - 24] = _s1bE::P64;
      _c1ei::P64 = Hp - 40;
      I64[Hp - 16] = sat_s1bG_info;
      P64[Hp] = _s1bB::P64;
      _c1eP::P64 = Hp - 16;
      R1 = showParen_closure;
      P64[(old + 24)] = _c1eP::P64;
      P64[(old + 16)] = _c1ei::P64;
      call stg_ap_pp_fast(R1) args: 24, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-01 18:20:37.578342 UTC

{offset
  c1eW:
      _s1bB::P64 = P64[Sp];
      _s1bC::P64 = P64[Sp + 8];
      if ((Sp + 24) - 32 < SpLim) goto c1eX; else goto c1eY;
  c1eX:
      R1 = $cshowsPrec_r18d_closure;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c1eY:
      I64[Sp - 8] = c1ed;
      R1 = _s1bC::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto c1ed; else goto c1ee;
  c1ee:
      call (I64[I64[R1]])(R1) returns to c1ed, args: 8, res: 8, upd: 8;
  c1ed:
      _s1bB::P64 = P64[Sp + 8];
      _s1bD::P64 = R1;
      Hp = Hp + 48;
      if (Hp > HpLim) goto c1f1; else goto c1f0;
  c1f1:
      HpAlloc = 48;
      R1 = _s1bD::P64;
      call stg_gc_unpt_r1(R1) returns to c1ed, args: 8, res: 8, upd: 8;
  c1f0:
      _s1bE::P64 = P64[_s1bD::P64 + 7];
      I64[Hp - 40] = sat_s1bL_info;
      P64[Hp - 24] = _s1bE::P64;
      _c1ei::P64 = Hp - 40;
      I64[Hp - 16] = sat_s1bG_info;
      P64[Hp] = _s1bB::P64;
      _c1eP::P64 = Hp - 16;
      R1 = showParen_closure;
      P64[Sp + 8] = _c1eP::P64;
      P64[Sp + 16] = _c1ei::P64;
      Sp = Sp + 8;
      call stg_ap_pp_fast(R1) args: 24, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-01 18:20:37.58304 UTC

[(c1ed, {showParen_closure, sat_s1bG_closure, sat_s1bL_closure}),
 (c1ee, {showParen_closure, sat_s1bG_closure, sat_s1bL_closure}),
 (c1eW,
  {showParen_closure, $cshowsPrec_r18d_closure, sat_s1bG_closure,
   sat_s1bL_closure}),
 (c1eX, {$cshowsPrec_r18d_closure}),
 (c1eY, {showParen_closure, sat_s1bG_closure, sat_s1bL_closure}),
 (c1f0, {showParen_closure, sat_s1bG_closure, sat_s1bL_closure}),
 (c1f1, {showParen_closure, sat_s1bG_closure, sat_s1bL_closure})]


==================== procpoint map ====================
2016-08-01 18:20:37.58546 UTC

[(c1ed, <procpt>), (c1ee, reached by c1eW), (c1eW, <procpt>),
 (c1eX, reached by c1eW), (c1eY, reached by c1eW),
 (c1f0, reached by c1ed), (c1f1, reached by c1ed)]


==================== Post splitting ====================
2016-08-01 18:20:37.586755 UTC

$cshowsPrec_r18d_entry() //  []
        { info_tbl: [(c1eW,
                      label: $cshowsPrec_r18d_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1eW:
          _s1bB::P64 = P64[Sp];
          _s1bC::P64 = P64[Sp + 8];
          if ((Sp + 24) - 32 < SpLim) goto c1eX; else goto c1eY;
      c1eX:
          R1 = $cshowsPrec_r18d_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
      c1eY:
          I64[Sp - 8] = block_c1ed_info;
          R1 = _s1bC::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto u1f2; else goto c1ee;
      u1f2:
          call block_c1ed_entry(R1) args: 0, res: 0, upd: 0;
      c1ee:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-01 18:20:37.590179 UTC

block_c1ed_entry() //  [R1]
        { info_tbl: [(c1ed,
                      label: block_c1ed_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1ed:
          _s1bB::P64 = P64[Sp + 8];
          _s1bD::P64 = R1;
          Hp = Hp + 48;
          if (Hp > HpLim) goto c1f1; else goto c1f0;
      c1f1:
          HpAlloc = 48;
          R1 = _s1bD::P64;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c1f0:
          _s1bE::P64 = P64[_s1bD::P64 + 7];
          I64[Hp - 40] = sat_s1bL_info;
          P64[Hp - 24] = _s1bE::P64;
          _c1ei::P64 = Hp - 40;
          I64[Hp - 16] = sat_s1bG_info;
          P64[Hp] = _s1bB::P64;
          _c1eP::P64 = Hp - 16;
          R1 = showParen_closure;
          P64[Sp + 8] = _c1eP::P64;
          P64[Sp + 16] = _c1ei::P64;
          Sp = Sp + 8;
          call stg_ap_pp_fast(R1) args: 24, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:37.593873 UTC

$cshowsPrec_r18d_entry() //  []
        { info_tbl: [(c1eW,
                      label: $cshowsPrec_r18d_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1eW:
          _s1bB::P64 = P64[Sp];
          _s1bC::P64 = P64[Sp + 8];
          if ((Sp + 24) - 32 < SpLim) goto c1eX; else goto c1eY;
      c1eX:
          R1 = $cshowsPrec_r18d_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
      c1eY:
          I64[Sp - 8] = block_c1ed_info;
          R1 = _s1bC::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto u1f2; else goto c1ee;
      u1f2:
          call block_c1ed_entry(R1) args: 0, res: 0, upd: 0;
      c1ee:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:37.596885 UTC

block_c1ed_entry() //  [R1]
        { info_tbl: [(c1ed,
                      label: block_c1ed_info
                      rep:StackRep [False, True])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1ed:
          _s1bB::P64 = P64[Sp + 8];
          _s1bD::P64 = R1;
          Hp = Hp + 48;
          if (Hp > HpLim) goto c1f1; else goto c1f0;
      c1f1:
          HpAlloc = 48;
          R1 = _s1bD::P64;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c1f0:
          _s1bE::P64 = P64[_s1bD::P64 + 7];
          I64[Hp - 40] = sat_s1bL_info;
          P64[Hp - 24] = _s1bE::P64;
          _c1ei::P64 = Hp - 40;
          I64[Hp - 16] = sat_s1bG_info;
          P64[Hp] = _s1bB::P64;
          _c1eP::P64 = Hp - 16;
          R1 = showParen_closure;
          P64[Sp + 8] = _c1eP::P64;
          P64[Sp + 16] = _c1ei::P64;
          Sp = Sp + 8;
          call stg_ap_pp_fast(R1) args: 24, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:37.601418 UTC

$cshowsPrec_r18d_entry() //  []
        { info_tbl: [(c1eW,
                      label: $cshowsPrec_r18d_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1eW:
          _s1bB::P64 = P64[Sp];
          _s1bC::P64 = P64[Sp + 8];
          if ((Sp + 24) - 32 < SpLim) goto c1eX; else goto c1eY;
      c1eX:
          R1 = $cshowsPrec_r18d_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
      c1eY:
          I64[Sp - 8] = block_c1ed_info;
          R1 = _s1bC::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto u1f2; else goto c1ee;
      u1f2:
          call block_c1ed_entry(R1) args: 0, res: 0, upd: 0;
      c1ee:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:37.604442 UTC

block_c1ed_entry() //  [R1]
        { info_tbl: [(c1ed,
                      label: block_c1ed_info
                      rep:StackRep [False, True])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1ed:
          _s1bB::P64 = P64[Sp + 8];
          _s1bD::P64 = R1;
          Hp = Hp + 48;
          if (Hp > HpLim) goto c1f1; else goto c1f0;
      c1f1:
          HpAlloc = 48;
          R1 = _s1bD::P64;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c1f0:
          _s1bE::P64 = P64[_s1bD::P64 + 7];
          I64[Hp - 40] = sat_s1bL_info;
          P64[Hp - 24] = _s1bE::P64;
          _c1ei::P64 = Hp - 40;
          I64[Hp - 16] = sat_s1bG_info;
          P64[Hp] = _s1bB::P64;
          _c1eP::P64 = Hp - 16;
          R1 = showParen_closure;
          P64[Sp + 8] = _c1eP::P64;
          P64[Sp + 16] = _c1ei::P64;
          Sp = Sp + 8;
          call stg_ap_pp_fast(R1) args: 24, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-01 18:20:37.608038 UTC

[section "data" {
     $cshowsPrec_r18d_closure:
         const $cshowsPrec_r18d_info;
         const 0;
 },
 sat_s1bK_entry() //  [R1]
         { info_tbl: [(c1eq,
                       label: sat_s1bK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1eq:
           _s1bK::P64 = R1;
           if ((Sp + 8) - 56 < SpLim) goto c1er; else goto c1es;
       c1er:
           R1 = _s1bK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1es:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1bK::P64;
           _s1bE::P64 = P64[_s1bK::P64 + 16];
           P64[Sp - 48] = $fShowInt_closure;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = stg_INTLIKE_closure+433;
           P64[Sp - 24] = _s1bE::P64;
           Sp = Sp - 48;
           call showsPrec_entry() args: 56, res: 0, upd: 24;
     }
 },
 section "readonly" {
     c1eB_str:
         I8[] [70,111,111,32]
 },
 sat_s1bH_entry() //  [R1]
         { info_tbl: [(c1eC,
                       label: sat_s1bH_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1eC:
           _s1bH::P64 = R1;
           if ((Sp + 8) - 32 < SpLim) goto c1eD; else goto c1eE;
       c1eD:
           R1 = _s1bH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1eE:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1bH::P64;
           R1 = unpackCString#_closure;
           I64[Sp - 24] = c1eB_str;
           Sp = Sp - 24;
           call stg_ap_n_fast(R1) args: 32, res: 0, upd: 24;
     }
 },
 sat_s1bI_entry() //  [R1]
         { info_tbl: [(c1eF,
                       label: sat_s1bI_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1eF:
           _s1bI::P64 = R1;
           if ((Sp + 8) - 32 < SpLim) goto c1eG; else goto c1eH;
       c1eH:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c1eJ; else goto c1eI;
       c1eJ:
           HpAlloc = 16;
           goto c1eG;
       c1eG:
           R1 = _s1bI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1eI:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1bI::P64;
           I64[Hp - 8] = sat_s1bH_info;
           _c1ex::P64 = Hp - 8;
           R1 = showString_closure;
           P64[Sp - 24] = _c1ex::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
     }
 },
 sat_s1bL_entry() //  [R1]
         { info_tbl: [(c1eK,
                       label: sat_s1bL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1eK:
           _s1bL::P64 = R1;
           if ((Sp + 8) - 40 < SpLim) goto c1eL; else goto c1eM;
       c1eM:
           Hp = Hp + 40;
           if (Hp > HpLim) goto c1eO; else goto c1eN;
       c1eO:
           HpAlloc = 40;
           goto c1eL;
       c1eL:
           R1 = _s1bL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1eN:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1bL::P64;
           _s1bE::P64 = P64[_s1bL::P64 + 16];
           I64[Hp - 32] = sat_s1bK_info;
           P64[Hp - 16] = _s1bE::P64;
           _c1em::P64 = Hp - 32;
           I64[Hp - 8] = sat_s1bI_info;
           _c1et::P64 = Hp - 8;
           R1 = ._closure;
           P64[Sp - 32] = _c1et::P64;
           P64[Sp - 24] = _c1em::P64;
           Sp = Sp - 32;
           call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1bG_entry() //  [R1]
         { info_tbl: [(c1eT,
                       label: sat_s1bG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1eT:
           _s1bG::P64 = R1;
           if ((Sp + 8) - 56 < SpLim) goto c1eU; else goto c1eV;
       c1eU:
           R1 = _s1bG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1eV:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1bG::P64;
           _s1bB::P64 = P64[_s1bG::P64 + 16];
           P64[Sp - 48] = $fOrdInt_closure;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s1bB::P64;
           P64[Sp - 24] = stg_INTLIKE_closure+433;
           Sp = Sp - 48;
           call >=_entry() args: 56, res: 0, upd: 24;
     }
 },
 $cshowsPrec_r18d_entry() //  []
         { info_tbl: [(c1eW,
                       label: $cshowsPrec_r18d_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1eW:
           _s1bB::P64 = P64[Sp];
           _s1bC::P64 = P64[Sp + 8];
           if ((Sp + 24) - 32 < SpLim) goto c1eX; else goto c1eY;
       c1eX:
           R1 = $cshowsPrec_r18d_closure;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
       c1eY:
           I64[Sp - 8] = block_c1ed_info;
           R1 = _s1bC::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1f2; else goto c1ee;
       u1f2:
           call block_c1ed_entry(R1) args: 0, res: 0, upd: 0;
       c1ee:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c1ed_entry() //  [R1]
         { info_tbl: [(c1ed,
                       label: block_c1ed_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ed:
           _s1bB::P64 = P64[Sp + 8];
           _s1bD::P64 = R1;
           Hp = Hp + 48;
           if (Hp > HpLim) goto c1f1; else goto c1f0;
       c1f1:
           HpAlloc = 48;
           R1 = _s1bD::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1f0:
           _s1bE::P64 = P64[_s1bD::P64 + 7];
           I64[Hp - 40] = sat_s1bL_info;
           P64[Hp - 24] = _s1bE::P64;
           _c1ei::P64 = Hp - 40;
           I64[Hp - 16] = sat_s1bG_info;
           P64[Hp] = _s1bB::P64;
           _c1eP::P64 = Hp - 16;
           R1 = showParen_closure;
           P64[Sp + 8] = _c1eP::P64;
           P64[Sp + 16] = _c1ei::P64;
           Sp = Sp + 8;
           call stg_ap_pp_fast(R1) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-01 18:20:37.628328 UTC

[section "data" {
     $cshowsPrec_r18d_closure:
         const $cshowsPrec_r18d_info;
         const 0;
 },
 sat_s1bK_entry() //  [R1]
         { info_tbl: [(c1eq,
                       label: sat_s1bK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1eq:
           _s1bK::P64 = R1;
           if ((Sp + 8) - 56 < SpLim) goto c1er; else goto c1es;
       c1er:
           R1 = _s1bK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1es:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1bK::P64;
           _s1bE::P64 = P64[_s1bK::P64 + 16];
           P64[Sp - 48] = $fShowInt_closure;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = stg_INTLIKE_closure+433;
           P64[Sp - 24] = _s1bE::P64;
           Sp = Sp - 48;
           call showsPrec_entry() args: 56, res: 0, upd: 24;
     }
 },
 section "readonly" {
     c1eB_str:
         I8[] [70,111,111,32]
 },
 sat_s1bH_entry() //  [R1]
         { info_tbl: [(c1eC,
                       label: sat_s1bH_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1eC:
           _s1bH::P64 = R1;
           if ((Sp + 8) - 32 < SpLim) goto c1eD; else goto c1eE;
       c1eD:
           R1 = _s1bH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1eE:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1bH::P64;
           R1 = unpackCString#_closure;
           I64[Sp - 24] = c1eB_str;
           Sp = Sp - 24;
           call stg_ap_n_fast(R1) args: 32, res: 0, upd: 24;
     }
 },
 sat_s1bI_entry() //  [R1]
         { info_tbl: [(c1eF,
                       label: sat_s1bI_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1eF:
           _s1bI::P64 = R1;
           if ((Sp + 8) - 32 < SpLim) goto c1eG; else goto c1eH;
       c1eH:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c1eJ; else goto c1eI;
       c1eJ:
           HpAlloc = 16;
           goto c1eG;
       c1eG:
           R1 = _s1bI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1eI:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1bI::P64;
           I64[Hp - 8] = sat_s1bH_info;
           _c1ex::P64 = Hp - 8;
           R1 = showString_closure;
           P64[Sp - 24] = _c1ex::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
     }
 },
 sat_s1bL_entry() //  [R1]
         { info_tbl: [(c1eK,
                       label: sat_s1bL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1eK:
           _s1bL::P64 = R1;
           if ((Sp + 8) - 40 < SpLim) goto c1eL; else goto c1eM;
       c1eM:
           Hp = Hp + 40;
           if (Hp > HpLim) goto c1eO; else goto c1eN;
       c1eO:
           HpAlloc = 40;
           goto c1eL;
       c1eL:
           R1 = _s1bL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1eN:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1bL::P64;
           _s1bE::P64 = P64[_s1bL::P64 + 16];
           I64[Hp - 32] = sat_s1bK_info;
           P64[Hp - 16] = _s1bE::P64;
           _c1em::P64 = Hp - 32;
           I64[Hp - 8] = sat_s1bI_info;
           _c1et::P64 = Hp - 8;
           R1 = ._closure;
           P64[Sp - 32] = _c1et::P64;
           P64[Sp - 24] = _c1em::P64;
           Sp = Sp - 32;
           call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1bG_entry() //  [R1]
         { info_tbl: [(c1eT,
                       label: sat_s1bG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1eT:
           _s1bG::P64 = R1;
           if ((Sp + 8) - 56 < SpLim) goto c1eU; else goto c1eV;
       c1eU:
           R1 = _s1bG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1eV:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1bG::P64;
           _s1bB::P64 = P64[_s1bG::P64 + 16];
           P64[Sp - 48] = $fOrdInt_closure;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s1bB::P64;
           P64[Sp - 24] = stg_INTLIKE_closure+433;
           Sp = Sp - 48;
           call >=_entry() args: 56, res: 0, upd: 24;
     }
 },
 $cshowsPrec_r18d_entry() //  []
         { info_tbl: [(c1eW,
                       label: $cshowsPrec_r18d_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1eW:
           _s1bB::P64 = P64[Sp];
           _s1bC::P64 = P64[Sp + 8];
           if ((Sp + 24) - 32 < SpLim) goto c1eX; else goto c1eY;
       c1eX:
           R1 = $cshowsPrec_r18d_closure;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
       c1eY:
           I64[Sp - 8] = block_c1ed_info;
           R1 = _s1bC::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1f2; else goto c1ee;
       u1f2:
           call block_c1ed_entry(R1) args: 0, res: 0, upd: 0;
       c1ee:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c1ed_entry() //  [R1]
         { info_tbl: [(c1ed,
                       label: block_c1ed_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ed:
           _s1bB::P64 = P64[Sp + 8];
           _s1bD::P64 = R1;
           Hp = Hp + 48;
           if (Hp > HpLim) goto c1f1; else goto c1f0;
       c1f1:
           HpAlloc = 48;
           R1 = _s1bD::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1f0:
           _s1bE::P64 = P64[_s1bD::P64 + 7];
           I64[Hp - 40] = sat_s1bL_info;
           P64[Hp - 24] = _s1bE::P64;
           _c1ei::P64 = Hp - 40;
           I64[Hp - 16] = sat_s1bG_info;
           P64[Hp] = _s1bB::P64;
           _c1eP::P64 = Hp - 16;
           R1 = showParen_closure;
           P64[Sp + 8] = _c1eP::P64;
           P64[Sp + 16] = _c1ei::P64;
           Sp = Sp + 8;
           call stg_ap_pp_fast(R1) args: 24, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:20:37.808506 UTC

[section "data" {
     sat_s1bN_closure:
         const sat_s1bN_info;
         const 0;
         const 0;
         const 0;
 },
 sat_s1bN_entry() //  [R1]
         { info_tbl: [(c1oQ,
                       label: sat_s1bN_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c1oQ:
           _s1bN::P64 = R1;
           goto c1oL;
       c1oL:
           if ((old + 0) - <highSp> < SpLim) goto c1oR; else goto c1oS;
       c1oR:
           R1 = _s1bN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oS:
           (_c1oN::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s1bN::P64);
           if (_c1oN::I64 == 0) goto c1oP; else goto c1oO;
       c1oP:
           call (I64[I64[_s1bN::P64]])() args: 8, res: 0, upd: 8;
       c1oO:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _c1oN::I64;
           P64[(old + 48)] = $fShowFoo_closure+1;
           I64[(old + 40)] = stg_ap_p_info;
           P64[(old + 32)] = stg_INTLIKE_closure+257;
           call showsPrec_entry() args: 48, res: 0, upd: 24;
     }
 },
 section "data" {
     $fShowFoo_closure:
         const D:Show_static_info;
         const $cshowsPrec_r18d_closure+2;
         const $cshow_r1bh_closure;
         const $cshowList_r1bg_closure;
         const 0;
 },
 section "data" {
     $cshowList_r1bg_closure:
         const $cshowList_r1bg_info;
         const 0;
         const 0;
         const 0;
 },
 $cshowList_r1bg_entry() //  [R1]
         { info_tbl: [(c1oZ,
                       label: $cshowList_r1bg_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c1oZ:
           _r1bg::P64 = R1;
           goto c1oU;
       c1oU:
           if ((old + 0) - <highSp> < SpLim) goto c1p0; else goto c1p1;
       c1p0:
           R1 = _r1bg::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1p1:
           (_c1oW::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r1bg::P64);
           if (_c1oW::I64 == 0) goto c1oY; else goto c1oX;
       c1oY:
           call (I64[I64[_r1bg::P64]])() args: 8, res: 0, upd: 8;
       c1oX:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _c1oW::I64;
           R1 = showList___closure;
           P64[(old + 32)] = sat_s1bN_closure;
           call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
     }
 },
 section "data" {
     $cshow_r1bh_closure:
         const $cshow_r1bh_info;
         const 0;
         const 0;
         const 0;
 },
 $cshow_r1bh_entry() //  [R1]
         { info_tbl: [(c1p8,
                       label: $cshow_r1bh_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c1p8:
           _r1bh::P64 = R1;
           goto c1p3;
       c1p3:
           if ((old + 0) - <highSp> < SpLim) goto c1p9; else goto c1pa;
       c1p9:
           R1 = _r1bh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pa:
           (_c1p5::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r1bh::P64);
           if (_c1p5::I64 == 0) goto c1p7; else goto c1p6;
       c1p7:
           call (I64[I64[_r1bh::P64]])() args: 8, res: 0, upd: 8;
       c1p6:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _c1p5::I64;
           R1 = $dmshow_closure;
           P64[(old + 32)] = $fShowFoo_closure+1;
           call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-01 18:20:37.822679 UTC

{offset
  c1oQ:
      _s1bN::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1oR; else goto c1oS;
  c1oR:
      R1 = _s1bN::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1oS:
      (_c1oN::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s1bN::P64);
      if (_c1oN::I64 == 0) goto c1oP; else goto c1oO;
  c1oP:
      call (I64[I64[_s1bN::P64]])() args: 8, res: 0, upd: 8;
  c1oO:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c1oN::I64;
      P64[(old + 48)] = $fShowFoo_closure+1;
      I64[(old + 40)] = stg_ap_p_info;
      P64[(old + 32)] = stg_INTLIKE_closure+257;
      call showsPrec_entry() args: 48, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-01 18:20:37.825576 UTC

sat_s1bN_entry
[c1oQ]
{offset
  c1oQ:
      _s1bN::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1oR; else goto c1oS;
  c1oR:
      R1 = _s1bN::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1oS:
      (_c1oN::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s1bN::P64);
      if (_c1oN::I64 == 0) goto c1oP; else goto c1oO;
  c1oP:
      call (I64[I64[_s1bN::P64]])() args: 8, res: 0, upd: 8;
  c1oO:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c1oN::I64;
      P64[(old + 48)] = $fShowFoo_closure+1;
      I64[(old + 40)] = stg_ap_p_info;
      P64[(old + 32)] = stg_INTLIKE_closure+257;
      call showsPrec_entry() args: 48, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-01 18:20:37.829013 UTC

{offset
  c1oQ:
      _s1bN::P64 = R1;
      if ((Sp + 8) - 48 < SpLim) goto c1oR; else goto c1oS;
  c1oR:
      R1 = _s1bN::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1oS:
      (_c1oN::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s1bN::P64);
      if (_c1oN::I64 == 0) goto c1oP; else goto c1oO;
  c1oP:
      call (I64[I64[_s1bN::P64]])() args: 8, res: 0, upd: 8;
  c1oO:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _c1oN::I64;
      P64[Sp - 40] = $fShowFoo_closure+1;
      I64[Sp - 32] = stg_ap_p_info;
      P64[Sp - 24] = stg_INTLIKE_closure+257;
      Sp = Sp - 40;
      call showsPrec_entry() args: 48, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-01 18:20:37.832009 UTC

[(c1oO, {$fShowFoo_closure}), (c1oP, {}),
 (c1oQ, {$fShowFoo_closure}), (c1oR, {}),
 (c1oS, {$fShowFoo_closure})]


==================== procpoint map ====================
2016-08-01 18:20:37.833182 UTC

[(c1oO, reached by c1oQ), (c1oP, reached by c1oQ),
 (c1oQ, <procpt>), (c1oR, reached by c1oQ), (c1oS, reached by c1oQ)]


==================== Post splitting ====================
2016-08-01 18:20:37.834283 UTC

sat_s1bN_entry() //  [R1]
        { info_tbl: [(c1oQ,
                      label: sat_s1bN_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1oQ:
          _s1bN::P64 = R1;
          if ((Sp + 8) - 48 < SpLim) goto c1oR; else goto c1oS;
      c1oR:
          R1 = _s1bN::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1oS:
          (_c1oN::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s1bN::P64);
          if (_c1oN::I64 == 0) goto c1oP; else goto c1oO;
      c1oP:
          call (I64[I64[_s1bN::P64]])() args: 8, res: 0, upd: 8;
      c1oO:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c1oN::I64;
          P64[Sp - 40] = $fShowFoo_closure+1;
          I64[Sp - 32] = stg_ap_p_info;
          P64[Sp - 24] = stg_INTLIKE_closure+257;
          Sp = Sp - 40;
          call showsPrec_entry() args: 48, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:37.838054 UTC

sat_s1bN_entry() //  [R1]
        { info_tbl: [(c1oQ,
                      label: sat_s1bN_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1oQ:
          _s1bN::P64 = R1;
          if ((Sp + 8) - 48 < SpLim) goto c1oR; else goto c1oS;
      c1oR:
          R1 = _s1bN::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1oS:
          (_c1oN::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s1bN::P64);
          if (_c1oN::I64 == 0) goto c1oP; else goto c1oO;
      c1oP:
          call (I64[I64[_s1bN::P64]])() args: 8, res: 0, upd: 8;
      c1oO:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c1oN::I64;
          P64[Sp - 40] = $fShowFoo_closure+1;
          I64[Sp - 32] = stg_ap_p_info;
          P64[Sp - 24] = stg_INTLIKE_closure+257;
          Sp = Sp - 40;
          call showsPrec_entry() args: 48, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:37.841635 UTC

sat_s1bN_entry() //  [R1]
        { info_tbl: [(c1oQ,
                      label: sat_s1bN_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1oQ:
          _s1bN::P64 = R1;
          if ((Sp + 8) - 48 < SpLim) goto c1oR; else goto c1oS;
      c1oR:
          R1 = _s1bN::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1oS:
          (_c1oN::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s1bN::P64);
          if (_c1oN::I64 == 0) goto c1oP; else goto c1oO;
      c1oP:
          call (I64[I64[_s1bN::P64]])() args: 8, res: 0, upd: 8;
      c1oO:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c1oN::I64;
          P64[Sp - 40] = $fShowFoo_closure+1;
          I64[Sp - 32] = stg_ap_p_info;
          P64[Sp - 24] = stg_INTLIKE_closure+257;
          Sp = Sp - 40;
          call showsPrec_entry() args: 48, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:37.845439 UTC

{offset
  c1oZ:
      _r1bg::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1p0; else goto c1p1;
  c1p0:
      R1 = _r1bg::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1p1:
      (_c1oW::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r1bg::P64);
      if (_c1oW::I64 == 0) goto c1oY; else goto c1oX;
  c1oY:
      call (I64[I64[_r1bg::P64]])() args: 8, res: 0, upd: 8;
  c1oX:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c1oW::I64;
      R1 = showList___closure;
      P64[(old + 32)] = sat_s1bN_closure;
      call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-01 18:20:37.848124 UTC

$cshowList_r1bg_entry
[c1oZ]
{offset
  c1oZ:
      _r1bg::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1p0; else goto c1p1;
  c1p0:
      R1 = _r1bg::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1p1:
      (_c1oW::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r1bg::P64);
      if (_c1oW::I64 == 0) goto c1oY; else goto c1oX;
  c1oY:
      call (I64[I64[_r1bg::P64]])() args: 8, res: 0, upd: 8;
  c1oX:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c1oW::I64;
      R1 = showList___closure;
      P64[(old + 32)] = sat_s1bN_closure;
      call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-01 18:20:37.851369 UTC

{offset
  c1oZ:
      _r1bg::P64 = R1;
      if ((Sp + 8) - 32 < SpLim) goto c1p0; else goto c1p1;
  c1p0:
      R1 = _r1bg::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1p1:
      (_c1oW::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r1bg::P64);
      if (_c1oW::I64 == 0) goto c1oY; else goto c1oX;
  c1oY:
      call (I64[I64[_r1bg::P64]])() args: 8, res: 0, upd: 8;
  c1oX:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _c1oW::I64;
      R1 = showList___closure;
      P64[Sp - 24] = sat_s1bN_closure;
      Sp = Sp - 24;
      call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-01 18:20:37.854164 UTC

[(c1oX, {showList___closure, sat_s1bN_closure}), (c1oY, {}),
 (c1oZ, {showList___closure, sat_s1bN_closure}), (c1p0, {}),
 (c1p1, {showList___closure, sat_s1bN_closure})]


==================== procpoint map ====================
2016-08-01 18:20:37.855484 UTC

[(c1oX, reached by c1oZ), (c1oY, reached by c1oZ),
 (c1oZ, <procpt>), (c1p0, reached by c1oZ), (c1p1, reached by c1oZ)]


==================== Post splitting ====================
2016-08-01 18:20:37.856547 UTC

$cshowList_r1bg_entry() //  [R1]
        { info_tbl: [(c1oZ,
                      label: $cshowList_r1bg_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1oZ:
          _r1bg::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1p0; else goto c1p1;
      c1p0:
          R1 = _r1bg::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1p1:
          (_c1oW::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r1bg::P64);
          if (_c1oW::I64 == 0) goto c1oY; else goto c1oX;
      c1oY:
          call (I64[I64[_r1bg::P64]])() args: 8, res: 0, upd: 8;
      c1oX:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c1oW::I64;
          R1 = showList___closure;
          P64[Sp - 24] = sat_s1bN_closure;
          Sp = Sp - 24;
          call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:37.860114 UTC

$cshowList_r1bg_entry() //  [R1]
        { info_tbl: [(c1oZ,
                      label: $cshowList_r1bg_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1oZ:
          _r1bg::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1p0; else goto c1p1;
      c1p0:
          R1 = _r1bg::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1p1:
          (_c1oW::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r1bg::P64);
          if (_c1oW::I64 == 0) goto c1oY; else goto c1oX;
      c1oY:
          call (I64[I64[_r1bg::P64]])() args: 8, res: 0, upd: 8;
      c1oX:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c1oW::I64;
          R1 = showList___closure;
          P64[Sp - 24] = sat_s1bN_closure;
          Sp = Sp - 24;
          call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:37.86353 UTC

$cshowList_r1bg_entry() //  [R1]
        { info_tbl: [(c1oZ,
                      label: $cshowList_r1bg_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1oZ:
          _r1bg::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1p0; else goto c1p1;
      c1p0:
          R1 = _r1bg::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1p1:
          (_c1oW::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r1bg::P64);
          if (_c1oW::I64 == 0) goto c1oY; else goto c1oX;
      c1oY:
          call (I64[I64[_r1bg::P64]])() args: 8, res: 0, upd: 8;
      c1oX:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c1oW::I64;
          R1 = showList___closure;
          P64[Sp - 24] = sat_s1bN_closure;
          Sp = Sp - 24;
          call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:37.86719 UTC

{offset
  c1p8:
      _r1bh::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1p9; else goto c1pa;
  c1p9:
      R1 = _r1bh::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1pa:
      (_c1p5::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r1bh::P64);
      if (_c1p5::I64 == 0) goto c1p7; else goto c1p6;
  c1p7:
      call (I64[I64[_r1bh::P64]])() args: 8, res: 0, upd: 8;
  c1p6:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c1p5::I64;
      R1 = $dmshow_closure;
      P64[(old + 32)] = $fShowFoo_closure+1;
      call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-01 18:20:37.869923 UTC

$cshow_r1bh_entry
[c1p8]
{offset
  c1p8:
      _r1bh::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1p9; else goto c1pa;
  c1p9:
      R1 = _r1bh::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1pa:
      (_c1p5::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r1bh::P64);
      if (_c1p5::I64 == 0) goto c1p7; else goto c1p6;
  c1p7:
      call (I64[I64[_r1bh::P64]])() args: 8, res: 0, upd: 8;
  c1p6:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c1p5::I64;
      R1 = $dmshow_closure;
      P64[(old + 32)] = $fShowFoo_closure+1;
      call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-01 18:20:37.874031 UTC

{offset
  c1p8:
      _r1bh::P64 = R1;
      if ((Sp + 8) - 32 < SpLim) goto c1p9; else goto c1pa;
  c1p9:
      R1 = _r1bh::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1pa:
      (_c1p5::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r1bh::P64);
      if (_c1p5::I64 == 0) goto c1p7; else goto c1p6;
  c1p7:
      call (I64[I64[_r1bh::P64]])() args: 8, res: 0, upd: 8;
  c1p6:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _c1p5::I64;
      R1 = $dmshow_closure;
      P64[Sp - 24] = $fShowFoo_closure+1;
      Sp = Sp - 24;
      call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-01 18:20:37.876813 UTC

[(c1p6, {$dmshow_closure, $fShowFoo_closure}), (c1p7, {}),
 (c1p8, {$dmshow_closure, $fShowFoo_closure}), (c1p9, {}),
 (c1pa, {$dmshow_closure, $fShowFoo_closure})]


==================== procpoint map ====================
2016-08-01 18:20:37.87808 UTC

[(c1p6, reached by c1p8), (c1p7, reached by c1p8),
 (c1p8, <procpt>), (c1p9, reached by c1p8), (c1pa, reached by c1p8)]


==================== Post splitting ====================
2016-08-01 18:20:37.879141 UTC

$cshow_r1bh_entry() //  [R1]
        { info_tbl: [(c1p8,
                      label: $cshow_r1bh_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1p8:
          _r1bh::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1p9; else goto c1pa;
      c1p9:
          R1 = _r1bh::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1pa:
          (_c1p5::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r1bh::P64);
          if (_c1p5::I64 == 0) goto c1p7; else goto c1p6;
      c1p7:
          call (I64[I64[_r1bh::P64]])() args: 8, res: 0, upd: 8;
      c1p6:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c1p5::I64;
          R1 = $dmshow_closure;
          P64[Sp - 24] = $fShowFoo_closure+1;
          Sp = Sp - 24;
          call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:37.88284 UTC

$cshow_r1bh_entry() //  [R1]
        { info_tbl: [(c1p8,
                      label: $cshow_r1bh_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1p8:
          _r1bh::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1p9; else goto c1pa;
      c1p9:
          R1 = _r1bh::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1pa:
          (_c1p5::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r1bh::P64);
          if (_c1p5::I64 == 0) goto c1p7; else goto c1p6;
      c1p7:
          call (I64[I64[_r1bh::P64]])() args: 8, res: 0, upd: 8;
      c1p6:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c1p5::I64;
          R1 = $dmshow_closure;
          P64[Sp - 24] = $fShowFoo_closure+1;
          Sp = Sp - 24;
          call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:37.886165 UTC

$cshow_r1bh_entry() //  [R1]
        { info_tbl: [(c1p8,
                      label: $cshow_r1bh_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1p8:
          _r1bh::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1p9; else goto c1pa;
      c1p9:
          R1 = _r1bh::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1pa:
          (_c1p5::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r1bh::P64);
          if (_c1p5::I64 == 0) goto c1p7; else goto c1p6;
      c1p7:
          call (I64[I64[_r1bh::P64]])() args: 8, res: 0, upd: 8;
      c1p6:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c1p5::I64;
          R1 = $dmshow_closure;
          P64[Sp - 24] = $fShowFoo_closure+1;
          Sp = Sp - 24;
          call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2016-08-01 18:20:37.889521 UTC

[section "data" {
     sat_s1bN_closure:
         const sat_s1bN_info;
         const 0;
         const 0;
         const 0;
 },
 sat_s1bN_entry() //  [R1]
         { info_tbl: [(c1oQ,
                       label: sat_s1bN_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oQ:
           _s1bN::P64 = R1;
           if ((Sp + 8) - 48 < SpLim) goto c1oR; else goto c1oS;
       c1oR:
           R1 = _s1bN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oS:
           (_c1oN::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s1bN::P64);
           if (_c1oN::I64 == 0) goto c1oP; else goto c1oO;
       c1oP:
           call (I64[I64[_s1bN::P64]])() args: 8, res: 0, upd: 8;
       c1oO:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1oN::I64;
           P64[Sp - 40] = $fShowFoo_closure+1;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = stg_INTLIKE_closure+257;
           Sp = Sp - 40;
           call showsPrec_entry() args: 48, res: 0, upd: 24;
     }
 },
 section "data" {
     $fShowFoo_closure:
         const D:Show_static_info;
         const $cshowsPrec_r18d_closure+2;
         const $cshow_r1bh_closure;
         const $cshowList_r1bg_closure;
         const 0;
 },
 section "data" {
     $cshowList_r1bg_closure:
         const $cshowList_r1bg_info;
         const 0;
         const 0;
         const 0;
 },
 $cshowList_r1bg_entry() //  [R1]
         { info_tbl: [(c1oZ,
                       label: $cshowList_r1bg_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oZ:
           _r1bg::P64 = R1;
           if ((Sp + 8) - 32 < SpLim) goto c1p0; else goto c1p1;
       c1p0:
           R1 = _r1bg::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1p1:
           (_c1oW::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r1bg::P64);
           if (_c1oW::I64 == 0) goto c1oY; else goto c1oX;
       c1oY:
           call (I64[I64[_r1bg::P64]])() args: 8, res: 0, upd: 8;
       c1oX:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1oW::I64;
           R1 = showList___closure;
           P64[Sp - 24] = sat_s1bN_closure;
           Sp = Sp - 24;
           call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
     }
 },
 section "data" {
     $cshow_r1bh_closure:
         const $cshow_r1bh_info;
         const 0;
         const 0;
         const 0;
 },
 $cshow_r1bh_entry() //  [R1]
         { info_tbl: [(c1p8,
                       label: $cshow_r1bh_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p8:
           _r1bh::P64 = R1;
           if ((Sp + 8) - 32 < SpLim) goto c1p9; else goto c1pa;
       c1p9:
           R1 = _r1bh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pa:
           (_c1p5::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r1bh::P64);
           if (_c1p5::I64 == 0) goto c1p7; else goto c1p6;
       c1p7:
           call (I64[I64[_r1bh::P64]])() args: 8, res: 0, upd: 8;
       c1p6:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1p5::I64;
           R1 = $dmshow_closure;
           P64[Sp - 24] = $fShowFoo_closure+1;
           Sp = Sp - 24;
           call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2016-08-01 18:20:37.90132 UTC

[section "data" {
     sat_s1bN_closure:
         const sat_s1bN_info;
         const 0;
         const 0;
         const 0;
 },
 sat_s1bN_entry() //  [R1]
         { info_tbl: [(c1oQ,
                       label: sat_s1bN_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oQ:
           _s1bN::P64 = R1;
           if ((Sp + 8) - 48 < SpLim) goto c1oR; else goto c1oS;
       c1oR:
           R1 = _s1bN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1oS:
           (_c1oN::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s1bN::P64);
           if (_c1oN::I64 == 0) goto c1oP; else goto c1oO;
       c1oP:
           call (I64[I64[_s1bN::P64]])() args: 8, res: 0, upd: 8;
       c1oO:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1oN::I64;
           P64[Sp - 40] = $fShowFoo_closure+1;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = stg_INTLIKE_closure+257;
           Sp = Sp - 40;
           call showsPrec_entry() args: 48, res: 0, upd: 24;
     }
 },
 section "data" {
     $fShowFoo_closure:
         const D:Show_static_info;
         const $cshowsPrec_r18d_closure+2;
         const $cshow_r1bh_closure;
         const $cshowList_r1bg_closure;
         const 0;
 },
 section "data" {
     $cshowList_r1bg_closure:
         const $cshowList_r1bg_info;
         const 0;
         const 0;
         const 0;
 },
 $cshowList_r1bg_entry() //  [R1]
         { info_tbl: [(c1oZ,
                       label: $cshowList_r1bg_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1oZ:
           _r1bg::P64 = R1;
           if ((Sp + 8) - 32 < SpLim) goto c1p0; else goto c1p1;
       c1p0:
           R1 = _r1bg::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1p1:
           (_c1oW::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r1bg::P64);
           if (_c1oW::I64 == 0) goto c1oY; else goto c1oX;
       c1oY:
           call (I64[I64[_r1bg::P64]])() args: 8, res: 0, upd: 8;
       c1oX:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1oW::I64;
           R1 = showList___closure;
           P64[Sp - 24] = sat_s1bN_closure;
           Sp = Sp - 24;
           call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
     }
 },
 section "data" {
     $cshow_r1bh_closure:
         const $cshow_r1bh_info;
         const 0;
         const 0;
         const 0;
 },
 $cshow_r1bh_entry() //  [R1]
         { info_tbl: [(c1p8,
                       label: $cshow_r1bh_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1p8:
           _r1bh::P64 = R1;
           if ((Sp + 8) - 32 < SpLim) goto c1p9; else goto c1pa;
       c1p9:
           R1 = _r1bh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1pa:
           (_c1p5::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r1bh::P64);
           if (_c1p5::I64 == 0) goto c1p7; else goto c1p6;
       c1p7:
           call (I64[I64[_r1bh::P64]])() args: 8, res: 0, upd: 8;
       c1p6:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1p5::I64;
           R1 = $dmshow_closure;
           P64[Sp - 24] = $fShowFoo_closure+1;
           Sp = Sp - 24;
           call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:20:37.982692 UTC

[section "data" {
     sat_s1c5_closure:
         const sat_s1c5_info;
         const 0;
         const 0;
         const 0;
 },
 sat_s1c2_entry() //  [R1]
         { info_tbl: [(c1ti,
                       label: sat_s1c2_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 16 updfr_space: Just 8
         }
     {offset
       c1ti:
           _s1c2::P64 = R1;
           _s1c1::P64 = P64[(old + 16)];
           goto c1tg;
       c1tg:
           if ((old + 0) - <highSp> < SpLim) goto c1tj; else goto c1tk;
       c1tj:
           R1 = _s1c2::P64;
           P64[(old + 16)] = _s1c1::P64;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c1tk:
           goto c1tf;
       c1tf:
           R1 = print_closure;
           P64[(old + 24)] = $fShowFoo_closure+1;
           P64[(old + 16)] = _s1c1::P64;
           call stg_ap_pp_fast(R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_s1c0_entry() //  [R1]
         { info_tbl: [(c1tp,
                       label: sat_s1c0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c1tp:
           _s1c0::P64 = R1;
           goto c1tn;
       c1tn:
           if ((old + 0) - <highSp> < SpLim) goto c1tq; else goto c1tr;
       c1tq:
           R1 = _s1c0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tr:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _s1c0::P64;
           _s1bU::P64 = P64[_s1c0::P64 + 16];
           R1 = readIORef_closure;
           P64[(old + 32)] = _s1bU::P64;
           call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
     }
 },
 sat_s1c3_entry() //  [R1]
         { info_tbl: [(c1ts,
                       label: sat_s1c3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c1ts:
           _s1c3::P64 = R1;
           goto c1tb;
       c1tb:
           if ((old + 0) - <highSp> < SpLim) goto c1tt; else goto c1tu;
       c1tu:
           Hp = Hp + 40;
           if (Hp > HpLim) goto c1tw; else goto c1tv;
       c1tw:
           HpAlloc = 40;
           goto c1tt;
       c1tt:
           R1 = _s1c3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tv:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _s1c3::P64;
           _s1bU::P64 = P64[_s1c3::P64 + 16];
           I64[Hp - 32] = sat_s1c2_info;
           _c1td::P64 = Hp - 31;
           I64[Hp - 16] = sat_s1c0_info;
           P64[Hp] = _s1bU::P64;
           _c1tl::P64 = Hp - 16;
           P64[(old + 56)] = $fMonadIO_closure;
           I64[(old + 48)] = stg_ap_pp_info;
           P64[(old + 40)] = _c1tl::P64;
           P64[(old + 32)] = _c1td::P64;
           call >>=_entry() args: 56, res: 0, upd: 24;
     }
 },
 sat_s1bX_entry() //  [R1]
         { info_tbl: [(c1tJ,
                       label: sat_s1bX_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c1tJ:
           _s1bX::P64 = R1;
           goto c1tH;
       c1tH:
           if ((old + 0) - <highSp> < SpLim) goto c1tK; else goto c1tL;
       c1tK:
           R1 = _s1bX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tL:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _s1bX::P64;
           P64[(old + 32)] = stg_INTLIKE_closure+321;
           call mkfoo_rnV_entry() args: 32, res: 0, upd: 24;
     }
 },
 sat_s1bV_entry() //  [R1]
         { info_tbl: [(c1tQ,
                       label: sat_s1bV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c1tQ:
           _s1bV::P64 = R1;
           goto c1tO;
       c1tO:
           if ((old + 0) - <highSp> < SpLim) goto c1tR; else goto c1tS;
       c1tR:
           R1 = _s1bV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tS:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _s1bV::P64;
           _s1bU::P64 = P64[_s1bV::P64 + 16];
           R1 = writeIORef_closure;
           P64[(old + 32)] = _s1bU::P64;
           call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
     }
 },
 sat_s1bY_entry() //  [R1]
         { info_tbl: [(c1tT,
                       label: sat_s1bY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c1tT:
           _s1bY::P64 = R1;
           goto c1tD;
       c1tD:
           if ((old + 0) - <highSp> < SpLim) goto c1tU; else goto c1tV;
       c1tV:
           Hp = Hp + 40;
           if (Hp > HpLim) goto c1tX; else goto c1tW;
       c1tX:
           HpAlloc = 40;
           goto c1tU;
       c1tU:
           R1 = _s1bY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tW:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _s1bY::P64;
           _s1bU::P64 = P64[_s1bY::P64 + 16];
           I64[Hp - 32] = sat_s1bX_info;
           _c1tF::P64 = Hp - 32;
           I64[Hp - 16] = sat_s1bV_info;
           P64[Hp] = _s1bU::P64;
           _c1tM::P64 = Hp - 16;
           R1 = $!_closure;
           P64[(old + 40)] = _c1tM::P64;
           P64[(old + 32)] = _c1tF::P64;
           call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1bZ_entry() //  [R1]
         { info_tbl: [(c1tY,
                       label: sat_s1bZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c1tY:
           _s1bZ::P64 = R1;
           goto c1tz;
       c1tz:
           if ((old + 0) - <highSp> < SpLim) goto c1tZ; else goto c1u0;
       c1u0:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c1u2; else goto c1u1;
       c1u2:
           HpAlloc = 24;
           goto c1tZ;
       c1tZ:
           R1 = _s1bZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1u1:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _s1bZ::P64;
           _s1bU::P64 = P64[_s1bZ::P64 + 16];
           I64[Hp - 16] = sat_s1bY_info;
           P64[Hp] = _s1bU::P64;
           _c1tB::P64 = Hp - 16;
           R1 = forkIO_closure;
           P64[(old + 32)] = _c1tB::P64;
           call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
     }
 },
 sat_s1c4_entry() //  [R1]
         { info_tbl: [(c1u3,
                       label: sat_s1c4_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 16 updfr_space: Just 8
         }
     {offset
       c1u3:
           _s1c4::P64 = R1;
           _s1bU::P64 = P64[(old + 16)];
           goto c1t7;
       c1t7:
           if ((old + 0) - <highSp> < SpLim) goto c1u4; else goto c1u5;
       c1u5:
           goto c1t6;
       c1t6:
           Hp = Hp + 48;
           if (Hp > HpLim) goto c1u7; else goto c1u6;
       c1u7:
           HpAlloc = 48;
           goto c1u4;
       c1u4:
           R1 = _s1c4::P64;
           P64[(old + 16)] = _s1bU::P64;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c1u6:
           I64[Hp - 40] = sat_s1c3_info;
           P64[Hp - 24] = _s1bU::P64;
           _c1t9::P64 = Hp - 40;
           I64[Hp - 16] = sat_s1bZ_info;
           P64[Hp] = _s1bU::P64;
           _c1tx::P64 = Hp - 16;
           P64[(old + 40)] = $fMonadIO_closure;
           I64[(old + 32)] = stg_ap_pp_info;
           P64[(old + 24)] = _c1tx::P64;
           P64[(old + 16)] = _c1t9::P64;
           call >>_entry() args: 40, res: 0, upd: 8;
     }
 },
 sat_s1bT_entry() //  [R1]
         { info_tbl: [(c1ud,
                       label: sat_s1bT_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c1ud:
           _s1bT::P64 = R1;
           goto c1ua;
       c1ua:
           if ((old + 0) - <highSp> < SpLim) goto c1ue; else goto c1uf;
       c1uf:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c1uh; else goto c1ug;
       c1uh:
           HpAlloc = 16;
           goto c1ue;
       c1ue:
           R1 = _s1bT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ug:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _s1bT::P64;
           I64[Hp - 8] = Foo_con_info;
           P64[Hp] = stg_INTLIKE_closure+305;
           _c1uc::P64 = Hp - 7;
           R1 = $!_closure;
           P64[(old + 40)] = newIORef_closure;
           P64[(old + 32)] = _c1uc::P64;
           call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1c5_entry() //  [R1]
         { info_tbl: [(c1ui,
                       label: sat_s1c5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c1ui:
           _s1c5::P64 = R1;
           goto c1sZ;
       c1sZ:
           if ((old + 0) - <highSp> < SpLim) goto c1uj; else goto c1uk;
       c1uk:
           Hp = Hp + 32;
           if (Hp > HpLim) goto c1um; else goto c1ul;
       c1um:
           HpAlloc = 32;
           goto c1uj;
       c1uj:
           R1 = _s1c5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ul:
           (_c1t1::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s1c5::P64);
           if (_c1t1::I64 == 0) goto c1t3; else goto c1t2;
       c1t3:
           call (I64[I64[_s1c5::P64]])() args: 8, res: 0, upd: 8;
       c1t2:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _c1t1::I64;
           I64[Hp - 24] = sat_s1c4_info;
           _c1t4::P64 = Hp - 23;
           I64[Hp - 8] = sat_s1bT_info;
           _c1u8::P64 = Hp - 8;
           P64[(old + 56)] = $fMonadIO_closure;
           I64[(old + 48)] = stg_ap_pp_info;
           P64[(old + 40)] = _c1u8::P64;
           P64[(old + 32)] = _c1t4::P64;
           call >>=_entry() args: 56, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.018931 UTC

{offset
  c1ti:
      _s1c2::P64 = R1;
      _s1c1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c1tj; else goto c1tk;
  c1tj:
      R1 = _s1c2::P64;
      P64[(old + 16)] = _s1c1::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c1tk:
      R1 = print_closure;
      P64[(old + 24)] = $fShowFoo_closure+1;
      P64[(old + 16)] = _s1c1::P64;
      call stg_ap_pp_fast(R1) args: 24, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-01 18:20:38.021036 UTC

sat_s1c2_entry
[c1ti]
{offset
  c1ti:
      _s1c2::P64 = R1;
      _s1c1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c1tj; else goto c1tk;
  c1tj:
      R1 = _s1c2::P64;
      P64[(old + 16)] = _s1c1::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c1tk:
      R1 = print_closure;
      P64[(old + 24)] = $fShowFoo_closure+1;
      P64[(old + 16)] = _s1c1::P64;
      call stg_ap_pp_fast(R1) args: 24, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-01 18:20:38.023745 UTC

{offset
  c1ti:
      _s1c2::P64 = R1;
      _s1c1::P64 = P64[Sp];
      if ((Sp + 16) - 24 < SpLim) goto c1tj; else goto c1tk;
  c1tj:
      R1 = _s1c2::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c1tk:
      R1 = print_closure;
      P64[Sp - 8] = $fShowFoo_closure+1;
      Sp = Sp - 8;
      call stg_ap_pp_fast(R1) args: 24, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-01 18:20:38.025579 UTC

[(c1ti, {print_closure, $fShowFoo_closure}), (c1tj, {}),
 (c1tk, {print_closure, $fShowFoo_closure})]


==================== procpoint map ====================
2016-08-01 18:20:38.026611 UTC

[(c1ti, <procpt>), (c1tj, reached by c1ti),
 (c1tk, reached by c1ti)]


==================== Post splitting ====================
2016-08-01 18:20:38.027533 UTC

sat_s1c2_entry() //  [R1]
        { info_tbl: [(c1ti,
                      label: sat_s1c2_info
                      rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1ti:
          _s1c2::P64 = R1;
          _s1c1::P64 = P64[Sp];
          if ((Sp + 16) - 24 < SpLim) goto c1tj; else goto c1tk;
      c1tj:
          R1 = _s1c2::P64;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c1tk:
          R1 = print_closure;
          P64[Sp - 8] = $fShowFoo_closure+1;
          Sp = Sp - 8;
          call stg_ap_pp_fast(R1) args: 24, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:38.0302 UTC

sat_s1c2_entry() //  [R1]
        { info_tbl: [(c1ti,
                      label: sat_s1c2_info
                      rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1ti:
          _s1c2::P64 = R1;
          _s1c1::P64 = P64[Sp];
          if ((Sp + 16) - 24 < SpLim) goto c1tj; else goto c1tk;
      c1tj:
          R1 = _s1c2::P64;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c1tk:
          R1 = print_closure;
          P64[Sp - 8] = $fShowFoo_closure+1;
          Sp = Sp - 8;
          call stg_ap_pp_fast(R1) args: 24, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.032731 UTC

sat_s1c2_entry() //  [R1]
        { info_tbl: [(c1ti,
                      label: sat_s1c2_info
                      rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1ti:
          _s1c2::P64 = R1;
          _s1c1::P64 = P64[Sp];
          if ((Sp + 16) - 24 < SpLim) goto c1tj; else goto c1tk;
      c1tj:
          R1 = _s1c2::P64;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c1tk:
          R1 = print_closure;
          P64[Sp - 8] = $fShowFoo_closure+1;
          Sp = Sp - 8;
          call stg_ap_pp_fast(R1) args: 24, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.035441 UTC

{offset
  c1tp:
      _s1c0::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1tq; else goto c1tr;
  c1tq:
      R1 = _s1c0::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1tr:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1c0::P64;
      _s1bU::P64 = P64[_s1c0::P64 + 16];
      R1 = readIORef_closure;
      P64[(old + 32)] = _s1bU::P64;
      call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-01 18:20:38.037547 UTC

sat_s1c0_entry
[c1tp]
{offset
  c1tp:
      _s1c0::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1tq; else goto c1tr;
  c1tq:
      R1 = _s1c0::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1tr:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1c0::P64;
      _s1bU::P64 = P64[_s1c0::P64 + 16];
      R1 = readIORef_closure;
      P64[(old + 32)] = _s1bU::P64;
      call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-01 18:20:38.040065 UTC

{offset
  c1tp:
      _s1c0::P64 = R1;
      if ((Sp + 8) - 32 < SpLim) goto c1tq; else goto c1tr;
  c1tq:
      R1 = _s1c0::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1tr:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _s1c0::P64;
      _s1bU::P64 = P64[_s1c0::P64 + 16];
      R1 = readIORef_closure;
      P64[Sp - 24] = _s1bU::P64;
      Sp = Sp - 24;
      call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-01 18:20:38.04251 UTC

[(c1tp, {readIORef_closure}), (c1tq, {}),
 (c1tr, {readIORef_closure})]


==================== procpoint map ====================
2016-08-01 18:20:38.043452 UTC

[(c1tp, <procpt>), (c1tq, reached by c1tp),
 (c1tr, reached by c1tp)]


==================== Post splitting ====================
2016-08-01 18:20:38.044368 UTC

sat_s1c0_entry() //  [R1]
        { info_tbl: [(c1tp,
                      label: sat_s1c0_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1tp:
          _s1c0::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1tq; else goto c1tr;
      c1tq:
          R1 = _s1c0::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1tr:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1c0::P64;
          _s1bU::P64 = P64[_s1c0::P64 + 16];
          R1 = readIORef_closure;
          P64[Sp - 24] = _s1bU::P64;
          Sp = Sp - 24;
          call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:38.047288 UTC

sat_s1c0_entry() //  [R1]
        { info_tbl: [(c1tp,
                      label: sat_s1c0_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1tp:
          _s1c0::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1tq; else goto c1tr;
      c1tq:
          R1 = _s1c0::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1tr:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1c0::P64;
          _s1bU::P64 = P64[_s1c0::P64 + 16];
          R1 = readIORef_closure;
          P64[Sp - 24] = _s1bU::P64;
          Sp = Sp - 24;
          call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.050044 UTC

sat_s1c0_entry() //  [R1]
        { info_tbl: [(c1tp,
                      label: sat_s1c0_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1tp:
          _s1c0::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1tq; else goto c1tr;
      c1tq:
          R1 = _s1c0::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1tr:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1c0::P64;
          _s1bU::P64 = P64[_s1c0::P64 + 16];
          R1 = readIORef_closure;
          P64[Sp - 24] = _s1bU::P64;
          Sp = Sp - 24;
          call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.053186 UTC

{offset
  c1ts:
      _s1c3::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1tt; else goto c1tu;
  c1tu:
      Hp = Hp + 40;
      if (Hp > HpLim) goto c1tw; else goto c1tv;
  c1tw:
      HpAlloc = 40;
      goto c1tt;
  c1tt:
      R1 = _s1c3::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1tv:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1c3::P64;
      _s1bU::P64 = P64[_s1c3::P64 + 16];
      I64[Hp - 32] = sat_s1c2_info;
      _c1td::P64 = Hp - 31;
      I64[Hp - 16] = sat_s1c0_info;
      P64[Hp] = _s1bU::P64;
      _c1tl::P64 = Hp - 16;
      P64[(old + 56)] = $fMonadIO_closure;
      I64[(old + 48)] = stg_ap_pp_info;
      P64[(old + 40)] = _c1tl::P64;
      P64[(old + 32)] = _c1td::P64;
      call >>=_entry() args: 56, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-01 18:20:38.057575 UTC

sat_s1c3_entry
[c1ts]
{offset
  c1ts:
      _s1c3::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1tt; else goto c1tu;
  c1tu:
      Hp = Hp + 40;
      if (Hp > HpLim) goto c1tw; else goto c1tv;
  c1tw:
      HpAlloc = 40;
      goto c1tt;
  c1tt:
      R1 = _s1c3::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1tv:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1c3::P64;
      _s1bU::P64 = P64[_s1c3::P64 + 16];
      I64[Hp - 32] = sat_s1c2_info;
      _c1td::P64 = Hp - 31;
      I64[Hp - 16] = sat_s1c0_info;
      P64[Hp] = _s1bU::P64;
      _c1tl::P64 = Hp - 16;
      P64[(old + 56)] = $fMonadIO_closure;
      I64[(old + 48)] = stg_ap_pp_info;
      P64[(old + 40)] = _c1tl::P64;
      P64[(old + 32)] = _c1td::P64;
      call >>=_entry() args: 56, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-01 18:20:38.061683 UTC

{offset
  c1ts:
      _s1c3::P64 = R1;
      if ((Sp + 8) - 56 < SpLim) goto c1tt; else goto c1tu;
  c1tu:
      Hp = Hp + 40;
      if (Hp > HpLim) goto c1tw; else goto c1tv;
  c1tw:
      HpAlloc = 40;
      goto c1tt;
  c1tt:
      R1 = _s1c3::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1tv:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _s1c3::P64;
      _s1bU::P64 = P64[_s1c3::P64 + 16];
      I64[Hp - 32] = sat_s1c2_info;
      _c1td::P64 = Hp - 31;
      I64[Hp - 16] = sat_s1c0_info;
      P64[Hp] = _s1bU::P64;
      _c1tl::P64 = Hp - 16;
      P64[Sp - 48] = $fMonadIO_closure;
      I64[Sp - 40] = stg_ap_pp_info;
      P64[Sp - 32] = _c1tl::P64;
      P64[Sp - 24] = _c1td::P64;
      Sp = Sp - 48;
      call >>=_entry() args: 56, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-01 18:20:38.065169 UTC

[(c1ts, {$fMonadIO_closure, sat_s1c0_closure, sat_s1c2_closure}),
 (c1tt, {}),
 (c1tu, {$fMonadIO_closure, sat_s1c0_closure, sat_s1c2_closure}),
 (c1tv, {$fMonadIO_closure, sat_s1c0_closure, sat_s1c2_closure}),
 (c1tw, {})]


==================== procpoint map ====================
2016-08-01 18:20:38.066716 UTC

[(c1ts, <procpt>), (c1tt, reached by c1ts),
 (c1tu, reached by c1ts), (c1tv, reached by c1ts),
 (c1tw, reached by c1ts)]


==================== Post splitting ====================
2016-08-01 18:20:38.067807 UTC

sat_s1c3_entry() //  [R1]
        { info_tbl: [(c1ts,
                      label: sat_s1c3_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1ts:
          _s1c3::P64 = R1;
          if ((Sp + 8) - 56 < SpLim) goto c1tt; else goto c1tu;
      c1tu:
          Hp = Hp + 40;
          if (Hp > HpLim) goto c1tw; else goto c1tv;
      c1tw:
          HpAlloc = 40;
          goto c1tt;
      c1tt:
          R1 = _s1c3::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1tv:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1c3::P64;
          _s1bU::P64 = P64[_s1c3::P64 + 16];
          I64[Hp - 32] = sat_s1c2_info;
          _c1td::P64 = Hp - 31;
          I64[Hp - 16] = sat_s1c0_info;
          P64[Hp] = _s1bU::P64;
          _c1tl::P64 = Hp - 16;
          P64[Sp - 48] = $fMonadIO_closure;
          I64[Sp - 40] = stg_ap_pp_info;
          P64[Sp - 32] = _c1tl::P64;
          P64[Sp - 24] = _c1td::P64;
          Sp = Sp - 48;
          call >>=_entry() args: 56, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:38.072226 UTC

sat_s1c3_entry() //  [R1]
        { info_tbl: [(c1ts,
                      label: sat_s1c3_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1ts:
          _s1c3::P64 = R1;
          if ((Sp + 8) - 56 < SpLim) goto c1tt; else goto c1tu;
      c1tu:
          Hp = Hp + 40;
          if (Hp > HpLim) goto c1tw; else goto c1tv;
      c1tw:
          HpAlloc = 40;
          goto c1tt;
      c1tt:
          R1 = _s1c3::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1tv:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1c3::P64;
          _s1bU::P64 = P64[_s1c3::P64 + 16];
          I64[Hp - 32] = sat_s1c2_info;
          _c1td::P64 = Hp - 31;
          I64[Hp - 16] = sat_s1c0_info;
          P64[Hp] = _s1bU::P64;
          _c1tl::P64 = Hp - 16;
          P64[Sp - 48] = $fMonadIO_closure;
          I64[Sp - 40] = stg_ap_pp_info;
          P64[Sp - 32] = _c1tl::P64;
          P64[Sp - 24] = _c1td::P64;
          Sp = Sp - 48;
          call >>=_entry() args: 56, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.076348 UTC

sat_s1c3_entry() //  [R1]
        { info_tbl: [(c1ts,
                      label: sat_s1c3_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1ts:
          _s1c3::P64 = R1;
          if ((Sp + 8) - 56 < SpLim) goto c1tt; else goto c1tu;
      c1tu:
          Hp = Hp + 40;
          if (Hp > HpLim) goto c1tw; else goto c1tv;
      c1tw:
          HpAlloc = 40;
          goto c1tt;
      c1tt:
          R1 = _s1c3::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1tv:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1c3::P64;
          _s1bU::P64 = P64[_s1c3::P64 + 16];
          I64[Hp - 32] = sat_s1c2_info;
          _c1td::P64 = Hp - 31;
          I64[Hp - 16] = sat_s1c0_info;
          P64[Hp] = _s1bU::P64;
          _c1tl::P64 = Hp - 16;
          P64[Sp - 48] = $fMonadIO_closure;
          I64[Sp - 40] = stg_ap_pp_info;
          P64[Sp - 32] = _c1tl::P64;
          P64[Sp - 24] = _c1td::P64;
          Sp = Sp - 48;
          call >>=_entry() args: 56, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.080704 UTC

{offset
  c1tJ:
      _s1bX::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1tK; else goto c1tL;
  c1tK:
      R1 = _s1bX::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1tL:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1bX::P64;
      P64[(old + 32)] = stg_INTLIKE_closure+321;
      call mkfoo_rnV_entry() args: 32, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-01 18:20:38.082633 UTC

sat_s1bX_entry
[c1tJ]
{offset
  c1tJ:
      _s1bX::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1tK; else goto c1tL;
  c1tK:
      R1 = _s1bX::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1tL:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1bX::P64;
      P64[(old + 32)] = stg_INTLIKE_closure+321;
      call mkfoo_rnV_entry() args: 32, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-01 18:20:38.084887 UTC

{offset
  c1tJ:
      _s1bX::P64 = R1;
      if ((Sp + 8) - 32 < SpLim) goto c1tK; else goto c1tL;
  c1tK:
      R1 = _s1bX::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1tL:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _s1bX::P64;
      P64[Sp - 24] = stg_INTLIKE_closure+321;
      Sp = Sp - 24;
      call mkfoo_rnV_entry() args: 32, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-01 18:20:38.086802 UTC

[(c1tJ, {}), (c1tK, {}), (c1tL, {})]


==================== procpoint map ====================
2016-08-01 18:20:38.087657 UTC

[(c1tJ, <procpt>), (c1tK, reached by c1tJ),
 (c1tL, reached by c1tJ)]


==================== Post splitting ====================
2016-08-01 18:20:38.088556 UTC

sat_s1bX_entry() //  [R1]
        { info_tbl: [(c1tJ,
                      label: sat_s1bX_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1tJ:
          _s1bX::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1tK; else goto c1tL;
      c1tK:
          R1 = _s1bX::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1tL:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bX::P64;
          P64[Sp - 24] = stg_INTLIKE_closure+321;
          Sp = Sp - 24;
          call mkfoo_rnV_entry() args: 32, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:38.091197 UTC

sat_s1bX_entry() //  [R1]
        { info_tbl: [(c1tJ,
                      label: sat_s1bX_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1tJ:
          _s1bX::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1tK; else goto c1tL;
      c1tK:
          R1 = _s1bX::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1tL:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bX::P64;
          P64[Sp - 24] = stg_INTLIKE_closure+321;
          Sp = Sp - 24;
          call mkfoo_rnV_entry() args: 32, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.093625 UTC

sat_s1bX_entry() //  [R1]
        { info_tbl: [(c1tJ,
                      label: sat_s1bX_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1tJ:
          _s1bX::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1tK; else goto c1tL;
      c1tK:
          R1 = _s1bX::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1tL:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bX::P64;
          P64[Sp - 24] = stg_INTLIKE_closure+321;
          Sp = Sp - 24;
          call mkfoo_rnV_entry() args: 32, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.096285 UTC

{offset
  c1tQ:
      _s1bV::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1tR; else goto c1tS;
  c1tR:
      R1 = _s1bV::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1tS:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1bV::P64;
      _s1bU::P64 = P64[_s1bV::P64 + 16];
      R1 = writeIORef_closure;
      P64[(old + 32)] = _s1bU::P64;
      call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-01 18:20:38.0984 UTC

sat_s1bV_entry
[c1tQ]
{offset
  c1tQ:
      _s1bV::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1tR; else goto c1tS;
  c1tR:
      R1 = _s1bV::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1tS:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1bV::P64;
      _s1bU::P64 = P64[_s1bV::P64 + 16];
      R1 = writeIORef_closure;
      P64[(old + 32)] = _s1bU::P64;
      call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-01 18:20:38.100934 UTC

{offset
  c1tQ:
      _s1bV::P64 = R1;
      if ((Sp + 8) - 32 < SpLim) goto c1tR; else goto c1tS;
  c1tR:
      R1 = _s1bV::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1tS:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _s1bV::P64;
      _s1bU::P64 = P64[_s1bV::P64 + 16];
      R1 = writeIORef_closure;
      P64[Sp - 24] = _s1bU::P64;
      Sp = Sp - 24;
      call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-01 18:20:38.10316 UTC

[(c1tQ, {writeIORef_closure}), (c1tR, {}),
 (c1tS, {writeIORef_closure})]


==================== procpoint map ====================
2016-08-01 18:20:38.104116 UTC

[(c1tQ, <procpt>), (c1tR, reached by c1tQ),
 (c1tS, reached by c1tQ)]


==================== Post splitting ====================
2016-08-01 18:20:38.105055 UTC

sat_s1bV_entry() //  [R1]
        { info_tbl: [(c1tQ,
                      label: sat_s1bV_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1tQ:
          _s1bV::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1tR; else goto c1tS;
      c1tR:
          R1 = _s1bV::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1tS:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bV::P64;
          _s1bU::P64 = P64[_s1bV::P64 + 16];
          R1 = writeIORef_closure;
          P64[Sp - 24] = _s1bU::P64;
          Sp = Sp - 24;
          call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:38.108761 UTC

sat_s1bV_entry() //  [R1]
        { info_tbl: [(c1tQ,
                      label: sat_s1bV_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1tQ:
          _s1bV::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1tR; else goto c1tS;
      c1tR:
          R1 = _s1bV::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1tS:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bV::P64;
          _s1bU::P64 = P64[_s1bV::P64 + 16];
          R1 = writeIORef_closure;
          P64[Sp - 24] = _s1bU::P64;
          Sp = Sp - 24;
          call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.11155 UTC

sat_s1bV_entry() //  [R1]
        { info_tbl: [(c1tQ,
                      label: sat_s1bV_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1tQ:
          _s1bV::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1tR; else goto c1tS;
      c1tR:
          R1 = _s1bV::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1tS:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bV::P64;
          _s1bU::P64 = P64[_s1bV::P64 + 16];
          R1 = writeIORef_closure;
          P64[Sp - 24] = _s1bU::P64;
          Sp = Sp - 24;
          call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.114574 UTC

{offset
  c1tT:
      _s1bY::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1tU; else goto c1tV;
  c1tV:
      Hp = Hp + 40;
      if (Hp > HpLim) goto c1tX; else goto c1tW;
  c1tX:
      HpAlloc = 40;
      goto c1tU;
  c1tU:
      R1 = _s1bY::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1tW:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1bY::P64;
      _s1bU::P64 = P64[_s1bY::P64 + 16];
      I64[Hp - 32] = sat_s1bX_info;
      _c1tF::P64 = Hp - 32;
      I64[Hp - 16] = sat_s1bV_info;
      P64[Hp] = _s1bU::P64;
      _c1tM::P64 = Hp - 16;
      R1 = $!_closure;
      P64[(old + 40)] = _c1tM::P64;
      P64[(old + 32)] = _c1tF::P64;
      call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-01 18:20:38.117849 UTC

sat_s1bY_entry
[c1tT]
{offset
  c1tT:
      _s1bY::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1tU; else goto c1tV;
  c1tV:
      Hp = Hp + 40;
      if (Hp > HpLim) goto c1tX; else goto c1tW;
  c1tX:
      HpAlloc = 40;
      goto c1tU;
  c1tU:
      R1 = _s1bY::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1tW:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1bY::P64;
      _s1bU::P64 = P64[_s1bY::P64 + 16];
      I64[Hp - 32] = sat_s1bX_info;
      _c1tF::P64 = Hp - 32;
      I64[Hp - 16] = sat_s1bV_info;
      P64[Hp] = _s1bU::P64;
      _c1tM::P64 = Hp - 16;
      R1 = $!_closure;
      P64[(old + 40)] = _c1tM::P64;
      P64[(old + 32)] = _c1tF::P64;
      call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-01 18:20:38.121793 UTC

{offset
  c1tT:
      _s1bY::P64 = R1;
      if ((Sp + 8) - 40 < SpLim) goto c1tU; else goto c1tV;
  c1tV:
      Hp = Hp + 40;
      if (Hp > HpLim) goto c1tX; else goto c1tW;
  c1tX:
      HpAlloc = 40;
      goto c1tU;
  c1tU:
      R1 = _s1bY::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1tW:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _s1bY::P64;
      _s1bU::P64 = P64[_s1bY::P64 + 16];
      I64[Hp - 32] = sat_s1bX_info;
      _c1tF::P64 = Hp - 32;
      I64[Hp - 16] = sat_s1bV_info;
      P64[Hp] = _s1bU::P64;
      _c1tM::P64 = Hp - 16;
      R1 = $!_closure;
      P64[Sp - 32] = _c1tM::P64;
      P64[Sp - 24] = _c1tF::P64;
      Sp = Sp - 32;
      call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-01 18:20:38.125087 UTC

[(c1tT, {$!_closure, sat_s1bV_closure, sat_s1bX_closure}),
 (c1tU, {}),
 (c1tV, {$!_closure, sat_s1bV_closure, sat_s1bX_closure}),
 (c1tW, {$!_closure, sat_s1bV_closure, sat_s1bX_closure}),
 (c1tX, {})]


==================== procpoint map ====================
2016-08-01 18:20:38.126624 UTC

[(c1tT, <procpt>), (c1tU, reached by c1tT),
 (c1tV, reached by c1tT), (c1tW, reached by c1tT),
 (c1tX, reached by c1tT)]


==================== Post splitting ====================
2016-08-01 18:20:38.127731 UTC

sat_s1bY_entry() //  [R1]
        { info_tbl: [(c1tT,
                      label: sat_s1bY_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1tT:
          _s1bY::P64 = R1;
          if ((Sp + 8) - 40 < SpLim) goto c1tU; else goto c1tV;
      c1tV:
          Hp = Hp + 40;
          if (Hp > HpLim) goto c1tX; else goto c1tW;
      c1tX:
          HpAlloc = 40;
          goto c1tU;
      c1tU:
          R1 = _s1bY::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1tW:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bY::P64;
          _s1bU::P64 = P64[_s1bY::P64 + 16];
          I64[Hp - 32] = sat_s1bX_info;
          _c1tF::P64 = Hp - 32;
          I64[Hp - 16] = sat_s1bV_info;
          P64[Hp] = _s1bU::P64;
          _c1tM::P64 = Hp - 16;
          R1 = $!_closure;
          P64[Sp - 32] = _c1tM::P64;
          P64[Sp - 24] = _c1tF::P64;
          Sp = Sp - 32;
          call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:38.131964 UTC

sat_s1bY_entry() //  [R1]
        { info_tbl: [(c1tT,
                      label: sat_s1bY_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1tT:
          _s1bY::P64 = R1;
          if ((Sp + 8) - 40 < SpLim) goto c1tU; else goto c1tV;
      c1tV:
          Hp = Hp + 40;
          if (Hp > HpLim) goto c1tX; else goto c1tW;
      c1tX:
          HpAlloc = 40;
          goto c1tU;
      c1tU:
          R1 = _s1bY::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1tW:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bY::P64;
          _s1bU::P64 = P64[_s1bY::P64 + 16];
          I64[Hp - 32] = sat_s1bX_info;
          _c1tF::P64 = Hp - 32;
          I64[Hp - 16] = sat_s1bV_info;
          P64[Hp] = _s1bU::P64;
          _c1tM::P64 = Hp - 16;
          R1 = $!_closure;
          P64[Sp - 32] = _c1tM::P64;
          P64[Sp - 24] = _c1tF::P64;
          Sp = Sp - 32;
          call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.135892 UTC

sat_s1bY_entry() //  [R1]
        { info_tbl: [(c1tT,
                      label: sat_s1bY_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1tT:
          _s1bY::P64 = R1;
          if ((Sp + 8) - 40 < SpLim) goto c1tU; else goto c1tV;
      c1tV:
          Hp = Hp + 40;
          if (Hp > HpLim) goto c1tX; else goto c1tW;
      c1tX:
          HpAlloc = 40;
          goto c1tU;
      c1tU:
          R1 = _s1bY::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1tW:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bY::P64;
          _s1bU::P64 = P64[_s1bY::P64 + 16];
          I64[Hp - 32] = sat_s1bX_info;
          _c1tF::P64 = Hp - 32;
          I64[Hp - 16] = sat_s1bV_info;
          P64[Hp] = _s1bU::P64;
          _c1tM::P64 = Hp - 16;
          R1 = $!_closure;
          P64[Sp - 32] = _c1tM::P64;
          P64[Sp - 24] = _c1tF::P64;
          Sp = Sp - 32;
          call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.140099 UTC

{offset
  c1tY:
      _s1bZ::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1tZ; else goto c1u0;
  c1u0:
      Hp = Hp + 24;
      if (Hp > HpLim) goto c1u2; else goto c1u1;
  c1u2:
      HpAlloc = 24;
      goto c1tZ;
  c1tZ:
      R1 = _s1bZ::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1u1:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1bZ::P64;
      _s1bU::P64 = P64[_s1bZ::P64 + 16];
      I64[Hp - 16] = sat_s1bY_info;
      P64[Hp] = _s1bU::P64;
      _c1tB::P64 = Hp - 16;
      R1 = forkIO_closure;
      P64[(old + 32)] = _c1tB::P64;
      call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-01 18:20:38.143022 UTC

sat_s1bZ_entry
[c1tY]
{offset
  c1tY:
      _s1bZ::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1tZ; else goto c1u0;
  c1u0:
      Hp = Hp + 24;
      if (Hp > HpLim) goto c1u2; else goto c1u1;
  c1u2:
      HpAlloc = 24;
      goto c1tZ;
  c1tZ:
      R1 = _s1bZ::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1u1:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1bZ::P64;
      _s1bU::P64 = P64[_s1bZ::P64 + 16];
      I64[Hp - 16] = sat_s1bY_info;
      P64[Hp] = _s1bU::P64;
      _c1tB::P64 = Hp - 16;
      R1 = forkIO_closure;
      P64[(old + 32)] = _c1tB::P64;
      call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-01 18:20:38.146446 UTC

{offset
  c1tY:
      _s1bZ::P64 = R1;
      if ((Sp + 8) - 32 < SpLim) goto c1tZ; else goto c1u0;
  c1u0:
      Hp = Hp + 24;
      if (Hp > HpLim) goto c1u2; else goto c1u1;
  c1u2:
      HpAlloc = 24;
      goto c1tZ;
  c1tZ:
      R1 = _s1bZ::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1u1:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _s1bZ::P64;
      _s1bU::P64 = P64[_s1bZ::P64 + 16];
      I64[Hp - 16] = sat_s1bY_info;
      P64[Hp] = _s1bU::P64;
      _c1tB::P64 = Hp - 16;
      R1 = forkIO_closure;
      P64[Sp - 24] = _c1tB::P64;
      Sp = Sp - 24;
      call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-01 18:20:38.14938 UTC

[(c1tY, {forkIO_closure, sat_s1bY_closure}), (c1tZ, {}),
 (c1u0, {forkIO_closure, sat_s1bY_closure}),
 (c1u1, {forkIO_closure, sat_s1bY_closure}), (c1u2, {})]


==================== procpoint map ====================
2016-08-01 18:20:38.150698 UTC

[(c1tY, <procpt>), (c1tZ, reached by c1tY),
 (c1u0, reached by c1tY), (c1u1, reached by c1tY),
 (c1u2, reached by c1tY)]


==================== Post splitting ====================
2016-08-01 18:20:38.151848 UTC

sat_s1bZ_entry() //  [R1]
        { info_tbl: [(c1tY,
                      label: sat_s1bZ_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1tY:
          _s1bZ::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1tZ; else goto c1u0;
      c1u0:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c1u2; else goto c1u1;
      c1u2:
          HpAlloc = 24;
          goto c1tZ;
      c1tZ:
          R1 = _s1bZ::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1u1:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bZ::P64;
          _s1bU::P64 = P64[_s1bZ::P64 + 16];
          I64[Hp - 16] = sat_s1bY_info;
          P64[Hp] = _s1bU::P64;
          _c1tB::P64 = Hp - 16;
          R1 = forkIO_closure;
          P64[Sp - 24] = _c1tB::P64;
          Sp = Sp - 24;
          call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:38.155664 UTC

sat_s1bZ_entry() //  [R1]
        { info_tbl: [(c1tY,
                      label: sat_s1bZ_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1tY:
          _s1bZ::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1tZ; else goto c1u0;
      c1u0:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c1u2; else goto c1u1;
      c1u2:
          HpAlloc = 24;
          goto c1tZ;
      c1tZ:
          R1 = _s1bZ::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1u1:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bZ::P64;
          _s1bU::P64 = P64[_s1bZ::P64 + 16];
          I64[Hp - 16] = sat_s1bY_info;
          P64[Hp] = _s1bU::P64;
          _c1tB::P64 = Hp - 16;
          R1 = forkIO_closure;
          P64[Sp - 24] = _c1tB::P64;
          Sp = Sp - 24;
          call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.159899 UTC

sat_s1bZ_entry() //  [R1]
        { info_tbl: [(c1tY,
                      label: sat_s1bZ_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1tY:
          _s1bZ::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1tZ; else goto c1u0;
      c1u0:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c1u2; else goto c1u1;
      c1u2:
          HpAlloc = 24;
          goto c1tZ;
      c1tZ:
          R1 = _s1bZ::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1u1:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bZ::P64;
          _s1bU::P64 = P64[_s1bZ::P64 + 16];
          I64[Hp - 16] = sat_s1bY_info;
          P64[Hp] = _s1bU::P64;
          _c1tB::P64 = Hp - 16;
          R1 = forkIO_closure;
          P64[Sp - 24] = _c1tB::P64;
          Sp = Sp - 24;
          call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.16387 UTC

{offset
  c1u3:
      _s1c4::P64 = R1;
      _s1bU::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c1u4; else goto c1u5;
  c1u5:
      Hp = Hp + 48;
      if (Hp > HpLim) goto c1u7; else goto c1u6;
  c1u7:
      HpAlloc = 48;
      goto c1u4;
  c1u4:
      R1 = _s1c4::P64;
      P64[(old + 16)] = _s1bU::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c1u6:
      I64[Hp - 40] = sat_s1c3_info;
      P64[Hp - 24] = _s1bU::P64;
      _c1t9::P64 = Hp - 40;
      I64[Hp - 16] = sat_s1bZ_info;
      P64[Hp] = _s1bU::P64;
      _c1tx::P64 = Hp - 16;
      P64[(old + 40)] = $fMonadIO_closure;
      I64[(old + 32)] = stg_ap_pp_info;
      P64[(old + 24)] = _c1tx::P64;
      P64[(old + 16)] = _c1t9::P64;
      call >>_entry() args: 40, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-01 18:20:38.167244 UTC

sat_s1c4_entry
[c1u3]
{offset
  c1u3:
      _s1c4::P64 = R1;
      _s1bU::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c1u4; else goto c1u5;
  c1u5:
      Hp = Hp + 48;
      if (Hp > HpLim) goto c1u7; else goto c1u6;
  c1u7:
      HpAlloc = 48;
      goto c1u4;
  c1u4:
      R1 = _s1c4::P64;
      P64[(old + 16)] = _s1bU::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c1u6:
      I64[Hp - 40] = sat_s1c3_info;
      P64[Hp - 24] = _s1bU::P64;
      _c1t9::P64 = Hp - 40;
      I64[Hp - 16] = sat_s1bZ_info;
      P64[Hp] = _s1bU::P64;
      _c1tx::P64 = Hp - 16;
      P64[(old + 40)] = $fMonadIO_closure;
      I64[(old + 32)] = stg_ap_pp_info;
      P64[(old + 24)] = _c1tx::P64;
      P64[(old + 16)] = _c1t9::P64;
      call >>_entry() args: 40, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-01 18:20:38.171355 UTC

{offset
  c1u3:
      _s1c4::P64 = R1;
      _s1bU::P64 = P64[Sp];
      if ((Sp + 16) - 40 < SpLim) goto c1u4; else goto c1u5;
  c1u5:
      Hp = Hp + 48;
      if (Hp > HpLim) goto c1u7; else goto c1u6;
  c1u7:
      HpAlloc = 48;
      goto c1u4;
  c1u4:
      R1 = _s1c4::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c1u6:
      I64[Hp - 40] = sat_s1c3_info;
      P64[Hp - 24] = _s1bU::P64;
      _c1t9::P64 = Hp - 40;
      I64[Hp - 16] = sat_s1bZ_info;
      P64[Hp] = _s1bU::P64;
      _c1tx::P64 = Hp - 16;
      P64[Sp - 24] = $fMonadIO_closure;
      I64[Sp - 16] = stg_ap_pp_info;
      P64[Sp - 8] = _c1tx::P64;
      P64[Sp] = _c1t9::P64;
      Sp = Sp - 24;
      call >>_entry() args: 40, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-01 18:20:38.174605 UTC

[(c1u3, {$fMonadIO_closure, sat_s1bZ_closure, sat_s1c3_closure}),
 (c1u4, {}),
 (c1u5, {$fMonadIO_closure, sat_s1bZ_closure, sat_s1c3_closure}),
 (c1u6, {$fMonadIO_closure, sat_s1bZ_closure, sat_s1c3_closure}),
 (c1u7, {})]


==================== procpoint map ====================
2016-08-01 18:20:38.176168 UTC

[(c1u3, <procpt>), (c1u4, reached by c1u3),
 (c1u5, reached by c1u3), (c1u6, reached by c1u3),
 (c1u7, reached by c1u3)]


==================== Post splitting ====================
2016-08-01 18:20:38.177265 UTC

sat_s1c4_entry() //  [R1]
        { info_tbl: [(c1u3,
                      label: sat_s1c4_info
                      rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1u3:
          _s1c4::P64 = R1;
          _s1bU::P64 = P64[Sp];
          if ((Sp + 16) - 40 < SpLim) goto c1u4; else goto c1u5;
      c1u5:
          Hp = Hp + 48;
          if (Hp > HpLim) goto c1u7; else goto c1u6;
      c1u7:
          HpAlloc = 48;
          goto c1u4;
      c1u4:
          R1 = _s1c4::P64;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c1u6:
          I64[Hp - 40] = sat_s1c3_info;
          P64[Hp - 24] = _s1bU::P64;
          _c1t9::P64 = Hp - 40;
          I64[Hp - 16] = sat_s1bZ_info;
          P64[Hp] = _s1bU::P64;
          _c1tx::P64 = Hp - 16;
          P64[Sp - 24] = $fMonadIO_closure;
          I64[Sp - 16] = stg_ap_pp_info;
          P64[Sp - 8] = _c1tx::P64;
          P64[Sp] = _c1t9::P64;
          Sp = Sp - 24;
          call >>_entry() args: 40, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:38.181452 UTC

sat_s1c4_entry() //  [R1]
        { info_tbl: [(c1u3,
                      label: sat_s1c4_info
                      rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1u3:
          _s1c4::P64 = R1;
          _s1bU::P64 = P64[Sp];
          if ((Sp + 16) - 40 < SpLim) goto c1u4; else goto c1u5;
      c1u5:
          Hp = Hp + 48;
          if (Hp > HpLim) goto c1u7; else goto c1u6;
      c1u7:
          HpAlloc = 48;
          goto c1u4;
      c1u4:
          R1 = _s1c4::P64;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c1u6:
          I64[Hp - 40] = sat_s1c3_info;
          P64[Hp - 24] = _s1bU::P64;
          _c1t9::P64 = Hp - 40;
          I64[Hp - 16] = sat_s1bZ_info;
          P64[Hp] = _s1bU::P64;
          _c1tx::P64 = Hp - 16;
          P64[Sp - 24] = $fMonadIO_closure;
          I64[Sp - 16] = stg_ap_pp_info;
          P64[Sp - 8] = _c1tx::P64;
          P64[Sp] = _c1t9::P64;
          Sp = Sp - 24;
          call >>_entry() args: 40, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.185263 UTC

sat_s1c4_entry() //  [R1]
        { info_tbl: [(c1u3,
                      label: sat_s1c4_info
                      rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1u3:
          _s1c4::P64 = R1;
          _s1bU::P64 = P64[Sp];
          if ((Sp + 16) - 40 < SpLim) goto c1u4; else goto c1u5;
      c1u5:
          Hp = Hp + 48;
          if (Hp > HpLim) goto c1u7; else goto c1u6;
      c1u7:
          HpAlloc = 48;
          goto c1u4;
      c1u4:
          R1 = _s1c4::P64;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c1u6:
          I64[Hp - 40] = sat_s1c3_info;
          P64[Hp - 24] = _s1bU::P64;
          _c1t9::P64 = Hp - 40;
          I64[Hp - 16] = sat_s1bZ_info;
          P64[Hp] = _s1bU::P64;
          _c1tx::P64 = Hp - 16;
          P64[Sp - 24] = $fMonadIO_closure;
          I64[Sp - 16] = stg_ap_pp_info;
          P64[Sp - 8] = _c1tx::P64;
          P64[Sp] = _c1t9::P64;
          Sp = Sp - 24;
          call >>_entry() args: 40, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.189366 UTC

{offset
  c1ud:
      _s1bT::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1ue; else goto c1uf;
  c1uf:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c1uh; else goto c1ug;
  c1uh:
      HpAlloc = 16;
      goto c1ue;
  c1ue:
      R1 = _s1bT::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1ug:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1bT::P64;
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = stg_INTLIKE_closure+305;
      _c1uc::P64 = Hp - 7;
      R1 = $!_closure;
      P64[(old + 40)] = newIORef_closure;
      P64[(old + 32)] = _c1uc::P64;
      call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-01 18:20:38.192248 UTC

sat_s1bT_entry
[c1ud]
{offset
  c1ud:
      _s1bT::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1ue; else goto c1uf;
  c1uf:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c1uh; else goto c1ug;
  c1uh:
      HpAlloc = 16;
      goto c1ue;
  c1ue:
      R1 = _s1bT::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1ug:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1bT::P64;
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = stg_INTLIKE_closure+305;
      _c1uc::P64 = Hp - 7;
      R1 = $!_closure;
      P64[(old + 40)] = newIORef_closure;
      P64[(old + 32)] = _c1uc::P64;
      call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-01 18:20:38.195668 UTC

{offset
  c1ud:
      _s1bT::P64 = R1;
      if ((Sp + 8) - 40 < SpLim) goto c1ue; else goto c1uf;
  c1uf:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c1uh; else goto c1ug;
  c1uh:
      HpAlloc = 16;
      goto c1ue;
  c1ue:
      R1 = _s1bT::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1ug:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _s1bT::P64;
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = stg_INTLIKE_closure+305;
      _c1uc::P64 = Hp - 7;
      R1 = $!_closure;
      P64[Sp - 32] = newIORef_closure;
      P64[Sp - 24] = _c1uc::P64;
      Sp = Sp - 32;
      call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-01 18:20:38.19853 UTC

[(c1ud, {$!_closure, newIORef_closure}), (c1ue, {}),
 (c1uf, {$!_closure, newIORef_closure}),
 (c1ug, {$!_closure, newIORef_closure}), (c1uh, {})]


==================== procpoint map ====================
2016-08-01 18:20:38.199793 UTC

[(c1ud, <procpt>), (c1ue, reached by c1ud),
 (c1uf, reached by c1ud), (c1ug, reached by c1ud),
 (c1uh, reached by c1ud)]


==================== Post splitting ====================
2016-08-01 18:20:38.200892 UTC

sat_s1bT_entry() //  [R1]
        { info_tbl: [(c1ud,
                      label: sat_s1bT_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1ud:
          _s1bT::P64 = R1;
          if ((Sp + 8) - 40 < SpLim) goto c1ue; else goto c1uf;
      c1uf:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c1uh; else goto c1ug;
      c1uh:
          HpAlloc = 16;
          goto c1ue;
      c1ue:
          R1 = _s1bT::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1ug:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bT::P64;
          I64[Hp - 8] = Foo_con_info;
          P64[Hp] = stg_INTLIKE_closure+305;
          _c1uc::P64 = Hp - 7;
          R1 = $!_closure;
          P64[Sp - 32] = newIORef_closure;
          P64[Sp - 24] = _c1uc::P64;
          Sp = Sp - 32;
          call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:38.204657 UTC

sat_s1bT_entry() //  [R1]
        { info_tbl: [(c1ud,
                      label: sat_s1bT_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1ud:
          _s1bT::P64 = R1;
          if ((Sp + 8) - 40 < SpLim) goto c1ue; else goto c1uf;
      c1uf:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c1uh; else goto c1ug;
      c1uh:
          HpAlloc = 16;
          goto c1ue;
      c1ue:
          R1 = _s1bT::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1ug:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bT::P64;
          I64[Hp - 8] = Foo_con_info;
          P64[Hp] = stg_INTLIKE_closure+305;
          _c1uc::P64 = Hp - 7;
          R1 = $!_closure;
          P64[Sp - 32] = newIORef_closure;
          P64[Sp - 24] = _c1uc::P64;
          Sp = Sp - 32;
          call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.208103 UTC

sat_s1bT_entry() //  [R1]
        { info_tbl: [(c1ud,
                      label: sat_s1bT_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1ud:
          _s1bT::P64 = R1;
          if ((Sp + 8) - 40 < SpLim) goto c1ue; else goto c1uf;
      c1uf:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c1uh; else goto c1ug;
      c1uh:
          HpAlloc = 16;
          goto c1ue;
      c1ue:
          R1 = _s1bT::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1ug:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bT::P64;
          I64[Hp - 8] = Foo_con_info;
          P64[Hp] = stg_INTLIKE_closure+305;
          _c1uc::P64 = Hp - 7;
          R1 = $!_closure;
          P64[Sp - 32] = newIORef_closure;
          P64[Sp - 24] = _c1uc::P64;
          Sp = Sp - 32;
          call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.21268 UTC

{offset
  c1ui:
      _s1c5::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1uj; else goto c1uk;
  c1uk:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c1um; else goto c1ul;
  c1um:
      HpAlloc = 32;
      goto c1uj;
  c1uj:
      R1 = _s1c5::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1ul:
      (_c1t1::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s1c5::P64);
      if (_c1t1::I64 == 0) goto c1t3; else goto c1t2;
  c1t3:
      call (I64[I64[_s1c5::P64]])() args: 8, res: 0, upd: 8;
  c1t2:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c1t1::I64;
      I64[Hp - 24] = sat_s1c4_info;
      _c1t4::P64 = Hp - 23;
      I64[Hp - 8] = sat_s1bT_info;
      _c1u8::P64 = Hp - 8;
      P64[(old + 56)] = $fMonadIO_closure;
      I64[(old + 48)] = stg_ap_pp_info;
      P64[(old + 40)] = _c1u8::P64;
      P64[(old + 32)] = _c1t4::P64;
      call >>=_entry() args: 56, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-01 18:20:38.216617 UTC

sat_s1c5_entry
[c1ui]
{offset
  c1ui:
      _s1c5::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1uj; else goto c1uk;
  c1uk:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c1um; else goto c1ul;
  c1um:
      HpAlloc = 32;
      goto c1uj;
  c1uj:
      R1 = _s1c5::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1ul:
      (_c1t1::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s1c5::P64);
      if (_c1t1::I64 == 0) goto c1t3; else goto c1t2;
  c1t3:
      call (I64[I64[_s1c5::P64]])() args: 8, res: 0, upd: 8;
  c1t2:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c1t1::I64;
      I64[Hp - 24] = sat_s1c4_info;
      _c1t4::P64 = Hp - 23;
      I64[Hp - 8] = sat_s1bT_info;
      _c1u8::P64 = Hp - 8;
      P64[(old + 56)] = $fMonadIO_closure;
      I64[(old + 48)] = stg_ap_pp_info;
      P64[(old + 40)] = _c1u8::P64;
      P64[(old + 32)] = _c1t4::P64;
      call >>=_entry() args: 56, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-01 18:20:38.221353 UTC

{offset
  c1ui:
      _s1c5::P64 = R1;
      if ((Sp + 8) - 56 < SpLim) goto c1uj; else goto c1uk;
  c1uk:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c1um; else goto c1ul;
  c1um:
      HpAlloc = 32;
      goto c1uj;
  c1uj:
      R1 = _s1c5::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1ul:
      (_c1t1::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s1c5::P64);
      if (_c1t1::I64 == 0) goto c1t3; else goto c1t2;
  c1t3:
      call (I64[I64[_s1c5::P64]])() args: 8, res: 0, upd: 8;
  c1t2:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _c1t1::I64;
      I64[Hp - 24] = sat_s1c4_info;
      _c1t4::P64 = Hp - 23;
      I64[Hp - 8] = sat_s1bT_info;
      _c1u8::P64 = Hp - 8;
      P64[Sp - 48] = $fMonadIO_closure;
      I64[Sp - 40] = stg_ap_pp_info;
      P64[Sp - 32] = _c1u8::P64;
      P64[Sp - 24] = _c1t4::P64;
      Sp = Sp - 48;
      call >>=_entry() args: 56, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-01 18:20:38.225339 UTC

[(c1t2, {$fMonadIO_closure, sat_s1bT_closure, sat_s1c4_closure}),
 (c1t3, {}),
 (c1ui, {$fMonadIO_closure, sat_s1bT_closure, sat_s1c4_closure}),
 (c1uj, {}),
 (c1uk, {$fMonadIO_closure, sat_s1bT_closure, sat_s1c4_closure}),
 (c1ul, {$fMonadIO_closure, sat_s1bT_closure, sat_s1c4_closure}),
 (c1um, {})]


==================== procpoint map ====================
2016-08-01 18:20:38.227271 UTC

[(c1t2, reached by c1ui), (c1t3, reached by c1ui),
 (c1ui, <procpt>), (c1uj, reached by c1ui), (c1uk, reached by c1ui),
 (c1ul, reached by c1ui), (c1um, reached by c1ui)]


==================== Post splitting ====================
2016-08-01 18:20:38.228528 UTC

sat_s1c5_entry() //  [R1]
        { info_tbl: [(c1ui,
                      label: sat_s1c5_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1ui:
          _s1c5::P64 = R1;
          if ((Sp + 8) - 56 < SpLim) goto c1uj; else goto c1uk;
      c1uk:
          Hp = Hp + 32;
          if (Hp > HpLim) goto c1um; else goto c1ul;
      c1um:
          HpAlloc = 32;
          goto c1uj;
      c1uj:
          R1 = _s1c5::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1ul:
          (_c1t1::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s1c5::P64);
          if (_c1t1::I64 == 0) goto c1t3; else goto c1t2;
      c1t3:
          call (I64[I64[_s1c5::P64]])() args: 8, res: 0, upd: 8;
      c1t2:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c1t1::I64;
          I64[Hp - 24] = sat_s1c4_info;
          _c1t4::P64 = Hp - 23;
          I64[Hp - 8] = sat_s1bT_info;
          _c1u8::P64 = Hp - 8;
          P64[Sp - 48] = $fMonadIO_closure;
          I64[Sp - 40] = stg_ap_pp_info;
          P64[Sp - 32] = _c1u8::P64;
          P64[Sp - 24] = _c1t4::P64;
          Sp = Sp - 48;
          call >>=_entry() args: 56, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:38.233481 UTC

sat_s1c5_entry() //  [R1]
        { info_tbl: [(c1ui,
                      label: sat_s1c5_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1ui:
          _s1c5::P64 = R1;
          if ((Sp + 8) - 56 < SpLim) goto c1uj; else goto c1uk;
      c1uk:
          Hp = Hp + 32;
          if (Hp > HpLim) goto c1um; else goto c1ul;
      c1um:
          HpAlloc = 32;
          goto c1uj;
      c1uj:
          R1 = _s1c5::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1ul:
          (_c1t1::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s1c5::P64);
          if (_c1t1::I64 == 0) goto c1t3; else goto c1t2;
      c1t3:
          call (I64[I64[_s1c5::P64]])() args: 8, res: 0, upd: 8;
      c1t2:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c1t1::I64;
          I64[Hp - 24] = sat_s1c4_info;
          _c1t4::P64 = Hp - 23;
          I64[Hp - 8] = sat_s1bT_info;
          _c1u8::P64 = Hp - 8;
          P64[Sp - 48] = $fMonadIO_closure;
          I64[Sp - 40] = stg_ap_pp_info;
          P64[Sp - 32] = _c1u8::P64;
          P64[Sp - 24] = _c1t4::P64;
          Sp = Sp - 48;
          call >>=_entry() args: 56, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.238087 UTC

sat_s1c5_entry() //  [R1]
        { info_tbl: [(c1ui,
                      label: sat_s1c5_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1ui:
          _s1c5::P64 = R1;
          if ((Sp + 8) - 56 < SpLim) goto c1uj; else goto c1uk;
      c1uk:
          Hp = Hp + 32;
          if (Hp > HpLim) goto c1um; else goto c1ul;
      c1um:
          HpAlloc = 32;
          goto c1uj;
      c1uj:
          R1 = _s1c5::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1ul:
          (_c1t1::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s1c5::P64);
          if (_c1t1::I64 == 0) goto c1t3; else goto c1t2;
      c1t3:
          call (I64[I64[_s1c5::P64]])() args: 8, res: 0, upd: 8;
      c1t2:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c1t1::I64;
          I64[Hp - 24] = sat_s1c4_info;
          _c1t4::P64 = Hp - 23;
          I64[Hp - 8] = sat_s1bT_info;
          _c1u8::P64 = Hp - 8;
          P64[Sp - 48] = $fMonadIO_closure;
          I64[Sp - 40] = stg_ap_pp_info;
          P64[Sp - 32] = _c1u8::P64;
          P64[Sp - 24] = _c1t4::P64;
          Sp = Sp - 48;
          call >>=_entry() args: 56, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2016-08-01 18:20:38.242781 UTC

[section "data" {
     sat_s1c5_closure:
         const sat_s1c5_info;
         const 0;
         const 0;
         const 0;
 },
 sat_s1c2_entry() //  [R1]
         { info_tbl: [(c1ti,
                       label: sat_s1c2_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ti:
           _s1c2::P64 = R1;
           _s1c1::P64 = P64[Sp];
           if ((Sp + 16) - 24 < SpLim) goto c1tj; else goto c1tk;
       c1tj:
           R1 = _s1c2::P64;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c1tk:
           R1 = print_closure;
           P64[Sp - 8] = $fShowFoo_closure+1;
           Sp = Sp - 8;
           call stg_ap_pp_fast(R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_s1c0_entry() //  [R1]
         { info_tbl: [(c1tp,
                       label: sat_s1c0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tp:
           _s1c0::P64 = R1;
           if ((Sp + 8) - 32 < SpLim) goto c1tq; else goto c1tr;
       c1tq:
           R1 = _s1c0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tr:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1c0::P64;
           _s1bU::P64 = P64[_s1c0::P64 + 16];
           R1 = readIORef_closure;
           P64[Sp - 24] = _s1bU::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
     }
 },
 sat_s1c3_entry() //  [R1]
         { info_tbl: [(c1ts,
                       label: sat_s1c3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ts:
           _s1c3::P64 = R1;
           if ((Sp + 8) - 56 < SpLim) goto c1tt; else goto c1tu;
       c1tu:
           Hp = Hp + 40;
           if (Hp > HpLim) goto c1tw; else goto c1tv;
       c1tw:
           HpAlloc = 40;
           goto c1tt;
       c1tt:
           R1 = _s1c3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tv:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1c3::P64;
           _s1bU::P64 = P64[_s1c3::P64 + 16];
           I64[Hp - 32] = sat_s1c2_info;
           _c1td::P64 = Hp - 31;
           I64[Hp - 16] = sat_s1c0_info;
           P64[Hp] = _s1bU::P64;
           _c1tl::P64 = Hp - 16;
           P64[Sp - 48] = $fMonadIO_closure;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _c1tl::P64;
           P64[Sp - 24] = _c1td::P64;
           Sp = Sp - 48;
           call >>=_entry() args: 56, res: 0, upd: 24;
     }
 },
 sat_s1bX_entry() //  [R1]
         { info_tbl: [(c1tJ,
                       label: sat_s1bX_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tJ:
           _s1bX::P64 = R1;
           if ((Sp + 8) - 32 < SpLim) goto c1tK; else goto c1tL;
       c1tK:
           R1 = _s1bX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tL:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1bX::P64;
           P64[Sp - 24] = stg_INTLIKE_closure+321;
           Sp = Sp - 24;
           call mkfoo_rnV_entry() args: 32, res: 0, upd: 24;
     }
 },
 sat_s1bV_entry() //  [R1]
         { info_tbl: [(c1tQ,
                       label: sat_s1bV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tQ:
           _s1bV::P64 = R1;
           if ((Sp + 8) - 32 < SpLim) goto c1tR; else goto c1tS;
       c1tR:
           R1 = _s1bV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tS:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1bV::P64;
           _s1bU::P64 = P64[_s1bV::P64 + 16];
           R1 = writeIORef_closure;
           P64[Sp - 24] = _s1bU::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
     }
 },
 sat_s1bY_entry() //  [R1]
         { info_tbl: [(c1tT,
                       label: sat_s1bY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tT:
           _s1bY::P64 = R1;
           if ((Sp + 8) - 40 < SpLim) goto c1tU; else goto c1tV;
       c1tV:
           Hp = Hp + 40;
           if (Hp > HpLim) goto c1tX; else goto c1tW;
       c1tX:
           HpAlloc = 40;
           goto c1tU;
       c1tU:
           R1 = _s1bY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tW:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1bY::P64;
           _s1bU::P64 = P64[_s1bY::P64 + 16];
           I64[Hp - 32] = sat_s1bX_info;
           _c1tF::P64 = Hp - 32;
           I64[Hp - 16] = sat_s1bV_info;
           P64[Hp] = _s1bU::P64;
           _c1tM::P64 = Hp - 16;
           R1 = $!_closure;
           P64[Sp - 32] = _c1tM::P64;
           P64[Sp - 24] = _c1tF::P64;
           Sp = Sp - 32;
           call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1bZ_entry() //  [R1]
         { info_tbl: [(c1tY,
                       label: sat_s1bZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tY:
           _s1bZ::P64 = R1;
           if ((Sp + 8) - 32 < SpLim) goto c1tZ; else goto c1u0;
       c1u0:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c1u2; else goto c1u1;
       c1u2:
           HpAlloc = 24;
           goto c1tZ;
       c1tZ:
           R1 = _s1bZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1u1:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1bZ::P64;
           _s1bU::P64 = P64[_s1bZ::P64 + 16];
           I64[Hp - 16] = sat_s1bY_info;
           P64[Hp] = _s1bU::P64;
           _c1tB::P64 = Hp - 16;
           R1 = forkIO_closure;
           P64[Sp - 24] = _c1tB::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
     }
 },
 sat_s1c4_entry() //  [R1]
         { info_tbl: [(c1u3,
                       label: sat_s1c4_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u3:
           _s1c4::P64 = R1;
           _s1bU::P64 = P64[Sp];
           if ((Sp + 16) - 40 < SpLim) goto c1u4; else goto c1u5;
       c1u5:
           Hp = Hp + 48;
           if (Hp > HpLim) goto c1u7; else goto c1u6;
       c1u7:
           HpAlloc = 48;
           goto c1u4;
       c1u4:
           R1 = _s1c4::P64;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c1u6:
           I64[Hp - 40] = sat_s1c3_info;
           P64[Hp - 24] = _s1bU::P64;
           _c1t9::P64 = Hp - 40;
           I64[Hp - 16] = sat_s1bZ_info;
           P64[Hp] = _s1bU::P64;
           _c1tx::P64 = Hp - 16;
           P64[Sp - 24] = $fMonadIO_closure;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = _c1tx::P64;
           P64[Sp] = _c1t9::P64;
           Sp = Sp - 24;
           call >>_entry() args: 40, res: 0, upd: 8;
     }
 },
 sat_s1bT_entry() //  [R1]
         { info_tbl: [(c1ud,
                       label: sat_s1bT_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ud:
           _s1bT::P64 = R1;
           if ((Sp + 8) - 40 < SpLim) goto c1ue; else goto c1uf;
       c1uf:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c1uh; else goto c1ug;
       c1uh:
           HpAlloc = 16;
           goto c1ue;
       c1ue:
           R1 = _s1bT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ug:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1bT::P64;
           I64[Hp - 8] = Foo_con_info;
           P64[Hp] = stg_INTLIKE_closure+305;
           _c1uc::P64 = Hp - 7;
           R1 = $!_closure;
           P64[Sp - 32] = newIORef_closure;
           P64[Sp - 24] = _c1uc::P64;
           Sp = Sp - 32;
           call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1c5_entry() //  [R1]
         { info_tbl: [(c1ui,
                       label: sat_s1c5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ui:
           _s1c5::P64 = R1;
           if ((Sp + 8) - 56 < SpLim) goto c1uj; else goto c1uk;
       c1uk:
           Hp = Hp + 32;
           if (Hp > HpLim) goto c1um; else goto c1ul;
       c1um:
           HpAlloc = 32;
           goto c1uj;
       c1uj:
           R1 = _s1c5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ul:
           (_c1t1::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s1c5::P64);
           if (_c1t1::I64 == 0) goto c1t3; else goto c1t2;
       c1t3:
           call (I64[I64[_s1c5::P64]])() args: 8, res: 0, upd: 8;
       c1t2:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1t1::I64;
           I64[Hp - 24] = sat_s1c4_info;
           _c1t4::P64 = Hp - 23;
           I64[Hp - 8] = sat_s1bT_info;
           _c1u8::P64 = Hp - 8;
           P64[Sp - 48] = $fMonadIO_closure;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _c1u8::P64;
           P64[Sp - 24] = _c1t4::P64;
           Sp = Sp - 48;
           call >>=_entry() args: 56, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2016-08-01 18:20:38.273981 UTC

[section "data" {
     sat_s1c5_closure:
         const sat_s1c5_info;
         const 0;
         const 0;
         const 0;
 },
 sat_s1c2_entry() //  [R1]
         { info_tbl: [(c1ti,
                       label: sat_s1c2_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ti:
           _s1c2::P64 = R1;
           _s1c1::P64 = P64[Sp];
           if ((Sp + 16) - 24 < SpLim) goto c1tj; else goto c1tk;
       c1tj:
           R1 = _s1c2::P64;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c1tk:
           R1 = print_closure;
           P64[Sp - 8] = $fShowFoo_closure+1;
           Sp = Sp - 8;
           call stg_ap_pp_fast(R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_s1c0_entry() //  [R1]
         { info_tbl: [(c1tp,
                       label: sat_s1c0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tp:
           _s1c0::P64 = R1;
           if ((Sp + 8) - 32 < SpLim) goto c1tq; else goto c1tr;
       c1tq:
           R1 = _s1c0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tr:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1c0::P64;
           _s1bU::P64 = P64[_s1c0::P64 + 16];
           R1 = readIORef_closure;
           P64[Sp - 24] = _s1bU::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
     }
 },
 sat_s1c3_entry() //  [R1]
         { info_tbl: [(c1ts,
                       label: sat_s1c3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ts:
           _s1c3::P64 = R1;
           if ((Sp + 8) - 56 < SpLim) goto c1tt; else goto c1tu;
       c1tu:
           Hp = Hp + 40;
           if (Hp > HpLim) goto c1tw; else goto c1tv;
       c1tw:
           HpAlloc = 40;
           goto c1tt;
       c1tt:
           R1 = _s1c3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tv:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1c3::P64;
           _s1bU::P64 = P64[_s1c3::P64 + 16];
           I64[Hp - 32] = sat_s1c2_info;
           _c1td::P64 = Hp - 31;
           I64[Hp - 16] = sat_s1c0_info;
           P64[Hp] = _s1bU::P64;
           _c1tl::P64 = Hp - 16;
           P64[Sp - 48] = $fMonadIO_closure;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _c1tl::P64;
           P64[Sp - 24] = _c1td::P64;
           Sp = Sp - 48;
           call >>=_entry() args: 56, res: 0, upd: 24;
     }
 },
 sat_s1bX_entry() //  [R1]
         { info_tbl: [(c1tJ,
                       label: sat_s1bX_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tJ:
           _s1bX::P64 = R1;
           if ((Sp + 8) - 32 < SpLim) goto c1tK; else goto c1tL;
       c1tK:
           R1 = _s1bX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tL:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1bX::P64;
           P64[Sp - 24] = stg_INTLIKE_closure+321;
           Sp = Sp - 24;
           call mkfoo_rnV_entry() args: 32, res: 0, upd: 24;
     }
 },
 sat_s1bV_entry() //  [R1]
         { info_tbl: [(c1tQ,
                       label: sat_s1bV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tQ:
           _s1bV::P64 = R1;
           if ((Sp + 8) - 32 < SpLim) goto c1tR; else goto c1tS;
       c1tR:
           R1 = _s1bV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tS:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1bV::P64;
           _s1bU::P64 = P64[_s1bV::P64 + 16];
           R1 = writeIORef_closure;
           P64[Sp - 24] = _s1bU::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
     }
 },
 sat_s1bY_entry() //  [R1]
         { info_tbl: [(c1tT,
                       label: sat_s1bY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tT:
           _s1bY::P64 = R1;
           if ((Sp + 8) - 40 < SpLim) goto c1tU; else goto c1tV;
       c1tV:
           Hp = Hp + 40;
           if (Hp > HpLim) goto c1tX; else goto c1tW;
       c1tX:
           HpAlloc = 40;
           goto c1tU;
       c1tU:
           R1 = _s1bY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1tW:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1bY::P64;
           _s1bU::P64 = P64[_s1bY::P64 + 16];
           I64[Hp - 32] = sat_s1bX_info;
           _c1tF::P64 = Hp - 32;
           I64[Hp - 16] = sat_s1bV_info;
           P64[Hp] = _s1bU::P64;
           _c1tM::P64 = Hp - 16;
           R1 = $!_closure;
           P64[Sp - 32] = _c1tM::P64;
           P64[Sp - 24] = _c1tF::P64;
           Sp = Sp - 32;
           call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1bZ_entry() //  [R1]
         { info_tbl: [(c1tY,
                       label: sat_s1bZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1tY:
           _s1bZ::P64 = R1;
           if ((Sp + 8) - 32 < SpLim) goto c1tZ; else goto c1u0;
       c1u0:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c1u2; else goto c1u1;
       c1u2:
           HpAlloc = 24;
           goto c1tZ;
       c1tZ:
           R1 = _s1bZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1u1:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1bZ::P64;
           _s1bU::P64 = P64[_s1bZ::P64 + 16];
           I64[Hp - 16] = sat_s1bY_info;
           P64[Hp] = _s1bU::P64;
           _c1tB::P64 = Hp - 16;
           R1 = forkIO_closure;
           P64[Sp - 24] = _c1tB::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
     }
 },
 sat_s1c4_entry() //  [R1]
         { info_tbl: [(c1u3,
                       label: sat_s1c4_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1u3:
           _s1c4::P64 = R1;
           _s1bU::P64 = P64[Sp];
           if ((Sp + 16) - 40 < SpLim) goto c1u4; else goto c1u5;
       c1u5:
           Hp = Hp + 48;
           if (Hp > HpLim) goto c1u7; else goto c1u6;
       c1u7:
           HpAlloc = 48;
           goto c1u4;
       c1u4:
           R1 = _s1c4::P64;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c1u6:
           I64[Hp - 40] = sat_s1c3_info;
           P64[Hp - 24] = _s1bU::P64;
           _c1t9::P64 = Hp - 40;
           I64[Hp - 16] = sat_s1bZ_info;
           P64[Hp] = _s1bU::P64;
           _c1tx::P64 = Hp - 16;
           P64[Sp - 24] = $fMonadIO_closure;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = _c1tx::P64;
           P64[Sp] = _c1t9::P64;
           Sp = Sp - 24;
           call >>_entry() args: 40, res: 0, upd: 8;
     }
 },
 sat_s1bT_entry() //  [R1]
         { info_tbl: [(c1ud,
                       label: sat_s1bT_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ud:
           _s1bT::P64 = R1;
           if ((Sp + 8) - 40 < SpLim) goto c1ue; else goto c1uf;
       c1uf:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c1uh; else goto c1ug;
       c1uh:
           HpAlloc = 16;
           goto c1ue;
       c1ue:
           R1 = _s1bT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ug:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1bT::P64;
           I64[Hp - 8] = Foo_con_info;
           P64[Hp] = stg_INTLIKE_closure+305;
           _c1uc::P64 = Hp - 7;
           R1 = $!_closure;
           P64[Sp - 32] = newIORef_closure;
           P64[Sp - 24] = _c1uc::P64;
           Sp = Sp - 32;
           call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1c5_entry() //  [R1]
         { info_tbl: [(c1ui,
                       label: sat_s1c5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ui:
           _s1c5::P64 = R1;
           if ((Sp + 8) - 56 < SpLim) goto c1uj; else goto c1uk;
       c1uk:
           Hp = Hp + 32;
           if (Hp > HpLim) goto c1um; else goto c1ul;
       c1um:
           HpAlloc = 32;
           goto c1uj;
       c1uj:
           R1 = _s1c5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ul:
           (_c1t1::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s1c5::P64);
           if (_c1t1::I64 == 0) goto c1t3; else goto c1t2;
       c1t3:
           call (I64[I64[_s1c5::P64]])() args: 8, res: 0, upd: 8;
       c1t2:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1t1::I64;
           I64[Hp - 24] = sat_s1c4_info;
           _c1t4::P64 = Hp - 23;
           I64[Hp - 8] = sat_s1bT_info;
           _c1u8::P64 = Hp - 8;
           P64[Sp - 48] = $fMonadIO_closure;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _c1u8::P64;
           P64[Sp - 24] = _c1t4::P64;
           Sp = Sp - 48;
           call >>=_entry() args: 56, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:20:38.548804 UTC

[section "data" {
     sat_s1bQ_closure:
         const sat_s1bQ_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     c1JH_str:
         I8[] [104,105]
 },
 sat_s1bP_entry() //  [R1]
         { info_tbl: [(c1JI,
                       label: sat_s1bP_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c1JI:
           _s1bP::P64 = R1;
           goto c1JF;
       c1JF:
           if ((old + 0) - <highSp> < SpLim) goto c1JJ; else goto c1JK;
       c1JJ:
           R1 = _s1bP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1JK:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _s1bP::P64;
           R1 = unpackCString#_closure;
           I64[(old + 32)] = c1JH_str;
           call stg_ap_n_fast(R1) args: 32, res: 0, upd: 24;
     }
 },
 sat_s1bO_entry() //  [R1]
         { info_tbl: [(c1JP,
                       label: sat_s1bO_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c1JP:
           _s1bO::P64 = R1;
           goto c1JN;
       c1JN:
           if ((old + 0) - <highSp> < SpLim) goto c1JQ; else goto c1JR;
       c1JQ:
           R1 = _s1bO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1JR:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _s1bO::P64;
           R1 = $fShow[]_closure;
           P64[(old + 32)] = $fShowChar_closure;
           call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
     }
 },
 sat_s1bQ_entry() //  [R1]
         { info_tbl: [(c1JS,
                       label: sat_s1bQ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c1JS:
           _s1bQ::P64 = R1;
           goto c1Jy;
       c1Jy:
           if ((old + 0) - <highSp> < SpLim) goto c1JT; else goto c1JU;
       c1JU:
           Hp = Hp + 32;
           if (Hp > HpLim) goto c1JW; else goto c1JV;
       c1JW:
           HpAlloc = 32;
           goto c1JT;
       c1JT:
           R1 = _s1bQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1JV:
           (_c1JA::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s1bQ::P64);
           if (_c1JA::I64 == 0) goto c1JC; else goto c1JB;
       c1JC:
           call (I64[I64[_s1bQ::P64]])() args: 8, res: 0, upd: 8;
       c1JB:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _c1JA::I64;
           I64[Hp - 24] = sat_s1bP_info;
           _c1JD::P64 = Hp - 24;
           I64[Hp - 8] = sat_s1bO_info;
           _c1JL::P64 = Hp - 8;
           R1 = print_closure;
           P64[(old + 40)] = _c1JL::P64;
           P64[(old + 32)] = _c1JD::P64;
           call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.560438 UTC

{offset
  c1JI:
      _s1bP::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1JJ; else goto c1JK;
  c1JJ:
      R1 = _s1bP::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1JK:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1bP::P64;
      R1 = unpackCString#_closure;
      I64[(old + 32)] = c1JH_str;
      call stg_ap_n_fast(R1) args: 32, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-01 18:20:38.562518 UTC

sat_s1bP_entry
[c1JI]
{offset
  c1JI:
      _s1bP::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1JJ; else goto c1JK;
  c1JJ:
      R1 = _s1bP::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1JK:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1bP::P64;
      R1 = unpackCString#_closure;
      I64[(old + 32)] = c1JH_str;
      call stg_ap_n_fast(R1) args: 32, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-01 18:20:38.564924 UTC

{offset
  c1JI:
      _s1bP::P64 = R1;
      if ((Sp + 8) - 32 < SpLim) goto c1JJ; else goto c1JK;
  c1JJ:
      R1 = _s1bP::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1JK:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _s1bP::P64;
      R1 = unpackCString#_closure;
      I64[Sp - 24] = c1JH_str;
      Sp = Sp - 24;
      call stg_ap_n_fast(R1) args: 32, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-01 18:20:38.566934 UTC

[(c1JI, {unpackCString#_closure}), (c1JJ, {}),
 (c1JK, {unpackCString#_closure})]


==================== procpoint map ====================
2016-08-01 18:20:38.567889 UTC

[(c1JI, <procpt>), (c1JJ, reached by c1JI),
 (c1JK, reached by c1JI)]


==================== Post splitting ====================
2016-08-01 18:20:38.568819 UTC

sat_s1bP_entry() //  [R1]
        { info_tbl: [(c1JI,
                      label: sat_s1bP_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1JI:
          _s1bP::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1JJ; else goto c1JK;
      c1JJ:
          R1 = _s1bP::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1JK:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bP::P64;
          R1 = unpackCString#_closure;
          I64[Sp - 24] = c1JH_str;
          Sp = Sp - 24;
          call stg_ap_n_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:38.571583 UTC

sat_s1bP_entry() //  [R1]
        { info_tbl: [(c1JI,
                      label: sat_s1bP_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1JI:
          _s1bP::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1JJ; else goto c1JK;
      c1JJ:
          R1 = _s1bP::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1JK:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bP::P64;
          R1 = unpackCString#_closure;
          I64[Sp - 24] = c1JH_str;
          Sp = Sp - 24;
          call stg_ap_n_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.5741 UTC

sat_s1bP_entry() //  [R1]
        { info_tbl: [(c1JI,
                      label: sat_s1bP_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1JI:
          _s1bP::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1JJ; else goto c1JK;
      c1JJ:
          R1 = _s1bP::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1JK:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bP::P64;
          R1 = unpackCString#_closure;
          I64[Sp - 24] = c1JH_str;
          Sp = Sp - 24;
          call stg_ap_n_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.576839 UTC

{offset
  c1JP:
      _s1bO::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1JQ; else goto c1JR;
  c1JQ:
      R1 = _s1bO::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1JR:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1bO::P64;
      R1 = $fShow[]_closure;
      P64[(old + 32)] = $fShowChar_closure;
      call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-01 18:20:38.57878 UTC

sat_s1bO_entry
[c1JP]
{offset
  c1JP:
      _s1bO::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1JQ; else goto c1JR;
  c1JQ:
      R1 = _s1bO::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1JR:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s1bO::P64;
      R1 = $fShow[]_closure;
      P64[(old + 32)] = $fShowChar_closure;
      call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-01 18:20:38.581155 UTC

{offset
  c1JP:
      _s1bO::P64 = R1;
      if ((Sp + 8) - 32 < SpLim) goto c1JQ; else goto c1JR;
  c1JQ:
      R1 = _s1bO::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1JR:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _s1bO::P64;
      R1 = $fShow[]_closure;
      P64[Sp - 24] = $fShowChar_closure;
      Sp = Sp - 24;
      call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-01 18:20:38.583182 UTC

[(c1JP, {$fShow[]_closure, $fShowChar_closure}), (c1JQ, {}),
 (c1JR, {$fShow[]_closure, $fShowChar_closure})]


==================== procpoint map ====================
2016-08-01 18:20:38.584201 UTC

[(c1JP, <procpt>), (c1JQ, reached by c1JP),
 (c1JR, reached by c1JP)]


==================== Post splitting ====================
2016-08-01 18:20:38.585114 UTC

sat_s1bO_entry() //  [R1]
        { info_tbl: [(c1JP,
                      label: sat_s1bO_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1JP:
          _s1bO::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1JQ; else goto c1JR;
      c1JQ:
          R1 = _s1bO::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1JR:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bO::P64;
          R1 = $fShow[]_closure;
          P64[Sp - 24] = $fShowChar_closure;
          Sp = Sp - 24;
          call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:38.587806 UTC

sat_s1bO_entry() //  [R1]
        { info_tbl: [(c1JP,
                      label: sat_s1bO_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1JP:
          _s1bO::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1JQ; else goto c1JR;
      c1JQ:
          R1 = _s1bO::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1JR:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bO::P64;
          R1 = $fShow[]_closure;
          P64[Sp - 24] = $fShowChar_closure;
          Sp = Sp - 24;
          call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.590315 UTC

sat_s1bO_entry() //  [R1]
        { info_tbl: [(c1JP,
                      label: sat_s1bO_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1JP:
          _s1bO::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1JQ; else goto c1JR;
      c1JQ:
          R1 = _s1bO::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1JR:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s1bO::P64;
          R1 = $fShow[]_closure;
          P64[Sp - 24] = $fShowChar_closure;
          Sp = Sp - 24;
          call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.593159 UTC

{offset
  c1JS:
      _s1bQ::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1JT; else goto c1JU;
  c1JU:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c1JW; else goto c1JV;
  c1JW:
      HpAlloc = 32;
      goto c1JT;
  c1JT:
      R1 = _s1bQ::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1JV:
      (_c1JA::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s1bQ::P64);
      if (_c1JA::I64 == 0) goto c1JC; else goto c1JB;
  c1JC:
      call (I64[I64[_s1bQ::P64]])() args: 8, res: 0, upd: 8;
  c1JB:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c1JA::I64;
      I64[Hp - 24] = sat_s1bP_info;
      _c1JD::P64 = Hp - 24;
      I64[Hp - 8] = sat_s1bO_info;
      _c1JL::P64 = Hp - 8;
      R1 = print_closure;
      P64[(old + 40)] = _c1JL::P64;
      P64[(old + 32)] = _c1JD::P64;
      call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-01 18:20:38.596912 UTC

sat_s1bQ_entry
[c1JS]
{offset
  c1JS:
      _s1bQ::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1JT; else goto c1JU;
  c1JU:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c1JW; else goto c1JV;
  c1JW:
      HpAlloc = 32;
      goto c1JT;
  c1JT:
      R1 = _s1bQ::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1JV:
      (_c1JA::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s1bQ::P64);
      if (_c1JA::I64 == 0) goto c1JC; else goto c1JB;
  c1JC:
      call (I64[I64[_s1bQ::P64]])() args: 8, res: 0, upd: 8;
  c1JB:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c1JA::I64;
      I64[Hp - 24] = sat_s1bP_info;
      _c1JD::P64 = Hp - 24;
      I64[Hp - 8] = sat_s1bO_info;
      _c1JL::P64 = Hp - 8;
      R1 = print_closure;
      P64[(old + 40)] = _c1JL::P64;
      P64[(old + 32)] = _c1JD::P64;
      call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-01 18:20:38.601377 UTC

{offset
  c1JS:
      _s1bQ::P64 = R1;
      if ((Sp + 8) - 40 < SpLim) goto c1JT; else goto c1JU;
  c1JU:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c1JW; else goto c1JV;
  c1JW:
      HpAlloc = 32;
      goto c1JT;
  c1JT:
      R1 = _s1bQ::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1JV:
      (_c1JA::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s1bQ::P64);
      if (_c1JA::I64 == 0) goto c1JC; else goto c1JB;
  c1JC:
      call (I64[I64[_s1bQ::P64]])() args: 8, res: 0, upd: 8;
  c1JB:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _c1JA::I64;
      I64[Hp - 24] = sat_s1bP_info;
      _c1JD::P64 = Hp - 24;
      I64[Hp - 8] = sat_s1bO_info;
      _c1JL::P64 = Hp - 8;
      R1 = print_closure;
      P64[Sp - 32] = _c1JL::P64;
      P64[Sp - 24] = _c1JD::P64;
      Sp = Sp - 32;
      call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-01 18:20:38.605161 UTC

[(c1JB, {print_closure, sat_s1bO_closure, sat_s1bP_closure}),
 (c1JC, {}),
 (c1JS, {print_closure, sat_s1bO_closure, sat_s1bP_closure}),
 (c1JT, {}),
 (c1JU, {print_closure, sat_s1bO_closure, sat_s1bP_closure}),
 (c1JV, {print_closure, sat_s1bO_closure, sat_s1bP_closure}),
 (c1JW, {})]


==================== procpoint map ====================
2016-08-01 18:20:38.607919 UTC

[(c1JB, reached by c1JS), (c1JC, reached by c1JS),
 (c1JS, <procpt>), (c1JT, reached by c1JS), (c1JU, reached by c1JS),
 (c1JV, reached by c1JS), (c1JW, reached by c1JS)]


==================== Post splitting ====================
2016-08-01 18:20:38.609174 UTC

sat_s1bQ_entry() //  [R1]
        { info_tbl: [(c1JS,
                      label: sat_s1bQ_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1JS:
          _s1bQ::P64 = R1;
          if ((Sp + 8) - 40 < SpLim) goto c1JT; else goto c1JU;
      c1JU:
          Hp = Hp + 32;
          if (Hp > HpLim) goto c1JW; else goto c1JV;
      c1JW:
          HpAlloc = 32;
          goto c1JT;
      c1JT:
          R1 = _s1bQ::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1JV:
          (_c1JA::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s1bQ::P64);
          if (_c1JA::I64 == 0) goto c1JC; else goto c1JB;
      c1JC:
          call (I64[I64[_s1bQ::P64]])() args: 8, res: 0, upd: 8;
      c1JB:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c1JA::I64;
          I64[Hp - 24] = sat_s1bP_info;
          _c1JD::P64 = Hp - 24;
          I64[Hp - 8] = sat_s1bO_info;
          _c1JL::P64 = Hp - 8;
          R1 = print_closure;
          P64[Sp - 32] = _c1JL::P64;
          P64[Sp - 24] = _c1JD::P64;
          Sp = Sp - 32;
          call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:38.613961 UTC

sat_s1bQ_entry() //  [R1]
        { info_tbl: [(c1JS,
                      label: sat_s1bQ_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1JS:
          _s1bQ::P64 = R1;
          if ((Sp + 8) - 40 < SpLim) goto c1JT; else goto c1JU;
      c1JU:
          Hp = Hp + 32;
          if (Hp > HpLim) goto c1JW; else goto c1JV;
      c1JW:
          HpAlloc = 32;
          goto c1JT;
      c1JT:
          R1 = _s1bQ::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1JV:
          (_c1JA::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s1bQ::P64);
          if (_c1JA::I64 == 0) goto c1JC; else goto c1JB;
      c1JC:
          call (I64[I64[_s1bQ::P64]])() args: 8, res: 0, upd: 8;
      c1JB:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c1JA::I64;
          I64[Hp - 24] = sat_s1bP_info;
          _c1JD::P64 = Hp - 24;
          I64[Hp - 8] = sat_s1bO_info;
          _c1JL::P64 = Hp - 8;
          R1 = print_closure;
          P64[Sp - 32] = _c1JL::P64;
          P64[Sp - 24] = _c1JD::P64;
          Sp = Sp - 32;
          call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.618342 UTC

sat_s1bQ_entry() //  [R1]
        { info_tbl: [(c1JS,
                      label: sat_s1bQ_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1JS:
          _s1bQ::P64 = R1;
          if ((Sp + 8) - 40 < SpLim) goto c1JT; else goto c1JU;
      c1JU:
          Hp = Hp + 32;
          if (Hp > HpLim) goto c1JW; else goto c1JV;
      c1JW:
          HpAlloc = 32;
          goto c1JT;
      c1JT:
          R1 = _s1bQ::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1JV:
          (_c1JA::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s1bQ::P64);
          if (_c1JA::I64 == 0) goto c1JC; else goto c1JB;
      c1JC:
          call (I64[I64[_s1bQ::P64]])() args: 8, res: 0, upd: 8;
      c1JB:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c1JA::I64;
          I64[Hp - 24] = sat_s1bP_info;
          _c1JD::P64 = Hp - 24;
          I64[Hp - 8] = sat_s1bO_info;
          _c1JL::P64 = Hp - 8;
          R1 = print_closure;
          P64[Sp - 32] = _c1JL::P64;
          P64[Sp - 24] = _c1JD::P64;
          Sp = Sp - 32;
          call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2016-08-01 18:20:38.622956 UTC

[section "data" {
     sat_s1bQ_closure:
         const sat_s1bQ_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     c1JH_str:
         I8[] [104,105]
 },
 sat_s1bP_entry() //  [R1]
         { info_tbl: [(c1JI,
                       label: sat_s1bP_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1JI:
           _s1bP::P64 = R1;
           if ((Sp + 8) - 32 < SpLim) goto c1JJ; else goto c1JK;
       c1JJ:
           R1 = _s1bP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1JK:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1bP::P64;
           R1 = unpackCString#_closure;
           I64[Sp - 24] = c1JH_str;
           Sp = Sp - 24;
           call stg_ap_n_fast(R1) args: 32, res: 0, upd: 24;
     }
 },
 sat_s1bO_entry() //  [R1]
         { info_tbl: [(c1JP,
                       label: sat_s1bO_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1JP:
           _s1bO::P64 = R1;
           if ((Sp + 8) - 32 < SpLim) goto c1JQ; else goto c1JR;
       c1JQ:
           R1 = _s1bO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1JR:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1bO::P64;
           R1 = $fShow[]_closure;
           P64[Sp - 24] = $fShowChar_closure;
           Sp = Sp - 24;
           call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
     }
 },
 sat_s1bQ_entry() //  [R1]
         { info_tbl: [(c1JS,
                       label: sat_s1bQ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1JS:
           _s1bQ::P64 = R1;
           if ((Sp + 8) - 40 < SpLim) goto c1JT; else goto c1JU;
       c1JU:
           Hp = Hp + 32;
           if (Hp > HpLim) goto c1JW; else goto c1JV;
       c1JW:
           HpAlloc = 32;
           goto c1JT;
       c1JT:
           R1 = _s1bQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1JV:
           (_c1JA::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s1bQ::P64);
           if (_c1JA::I64 == 0) goto c1JC; else goto c1JB;
       c1JC:
           call (I64[I64[_s1bQ::P64]])() args: 8, res: 0, upd: 8;
       c1JB:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1JA::I64;
           I64[Hp - 24] = sat_s1bP_info;
           _c1JD::P64 = Hp - 24;
           I64[Hp - 8] = sat_s1bO_info;
           _c1JL::P64 = Hp - 8;
           R1 = print_closure;
           P64[Sp - 32] = _c1JL::P64;
           P64[Sp - 24] = _c1JD::P64;
           Sp = Sp - 32;
           call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2016-08-01 18:20:38.632521 UTC

[section "data" {
     sat_s1bQ_closure:
         const sat_s1bQ_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     c1JH_str:
         I8[] [104,105]
 },
 sat_s1bP_entry() //  [R1]
         { info_tbl: [(c1JI,
                       label: sat_s1bP_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1JI:
           _s1bP::P64 = R1;
           if ((Sp + 8) - 32 < SpLim) goto c1JJ; else goto c1JK;
       c1JJ:
           R1 = _s1bP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1JK:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1bP::P64;
           R1 = unpackCString#_closure;
           I64[Sp - 24] = c1JH_str;
           Sp = Sp - 24;
           call stg_ap_n_fast(R1) args: 32, res: 0, upd: 24;
     }
 },
 sat_s1bO_entry() //  [R1]
         { info_tbl: [(c1JP,
                       label: sat_s1bO_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1JP:
           _s1bO::P64 = R1;
           if ((Sp + 8) - 32 < SpLim) goto c1JQ; else goto c1JR;
       c1JQ:
           R1 = _s1bO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1JR:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1bO::P64;
           R1 = $fShow[]_closure;
           P64[Sp - 24] = $fShowChar_closure;
           Sp = Sp - 24;
           call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
     }
 },
 sat_s1bQ_entry() //  [R1]
         { info_tbl: [(c1JS,
                       label: sat_s1bQ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1JS:
           _s1bQ::P64 = R1;
           if ((Sp + 8) - 40 < SpLim) goto c1JT; else goto c1JU;
       c1JU:
           Hp = Hp + 32;
           if (Hp > HpLim) goto c1JW; else goto c1JV;
       c1JW:
           HpAlloc = 32;
           goto c1JT;
       c1JT:
           R1 = _s1bQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1JV:
           (_c1JA::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s1bQ::P64);
           if (_c1JA::I64 == 0) goto c1JC; else goto c1JB;
       c1JC:
           call (I64[I64[_s1bQ::P64]])() args: 8, res: 0, upd: 8;
       c1JB:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1JA::I64;
           I64[Hp - 24] = sat_s1bP_info;
           _c1JD::P64 = Hp - 24;
           I64[Hp - 8] = sat_s1bO_info;
           _c1JL::P64 = Hp - 8;
           R1 = print_closure;
           P64[Sp - 32] = _c1JL::P64;
           P64[Sp - 24] = _c1JD::P64;
           Sp = Sp - 32;
           call stg_ap_pp_fast(R1) args: 40, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:20:38.709444 UTC

[section "data" {
     main_closure:
         const main_info;
         const 0;
         const 0;
         const 0;
 },
 main_entry() //  [R1]
         { info_tbl: [(c1NW,
                       label: main_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c1NW:
           _rnW::P64 = R1;
           goto c1NR;
       c1NR:
           if ((old + 0) - <highSp> < SpLim) goto c1NX; else goto c1NY;
       c1NX:
           R1 = _rnW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1NY:
           (_c1NT::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rnW::P64);
           if (_c1NT::I64 == 0) goto c1NV; else goto c1NU;
       c1NV:
           call (I64[I64[_rnW::P64]])() args: 8, res: 0, upd: 8;
       c1NU:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _c1NT::I64;
           P64[(old + 56)] = $fMonadIO_closure;
           I64[(old + 48)] = stg_ap_pp_info;
           P64[(old + 40)] = sat_s1bQ_closure;
           P64[(old + 32)] = sat_s1c5_closure;
           call >>_entry() args: 56, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.714643 UTC

{offset
  c1NW:
      _rnW::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1NX; else goto c1NY;
  c1NX:
      R1 = _rnW::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1NY:
      (_c1NT::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rnW::P64);
      if (_c1NT::I64 == 0) goto c1NV; else goto c1NU;
  c1NV:
      call (I64[I64[_rnW::P64]])() args: 8, res: 0, upd: 8;
  c1NU:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c1NT::I64;
      P64[(old + 56)] = $fMonadIO_closure;
      I64[(old + 48)] = stg_ap_pp_info;
      P64[(old + 40)] = sat_s1bQ_closure;
      P64[(old + 32)] = sat_s1c5_closure;
      call >>_entry() args: 56, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-01 18:20:38.717669 UTC

main_entry
[c1NW]
{offset
  c1NW:
      _rnW::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1NX; else goto c1NY;
  c1NX:
      R1 = _rnW::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1NY:
      (_c1NT::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rnW::P64);
      if (_c1NT::I64 == 0) goto c1NV; else goto c1NU;
  c1NV:
      call (I64[I64[_rnW::P64]])() args: 8, res: 0, upd: 8;
  c1NU:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c1NT::I64;
      P64[(old + 56)] = $fMonadIO_closure;
      I64[(old + 48)] = stg_ap_pp_info;
      P64[(old + 40)] = sat_s1bQ_closure;
      P64[(old + 32)] = sat_s1c5_closure;
      call >>_entry() args: 56, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-01 18:20:38.721283 UTC

{offset
  c1NW:
      _rnW::P64 = R1;
      if ((Sp + 8) - 56 < SpLim) goto c1NX; else goto c1NY;
  c1NX:
      R1 = _rnW::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1NY:
      (_c1NT::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rnW::P64);
      if (_c1NT::I64 == 0) goto c1NV; else goto c1NU;
  c1NV:
      call (I64[I64[_rnW::P64]])() args: 8, res: 0, upd: 8;
  c1NU:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _c1NT::I64;
      P64[Sp - 48] = $fMonadIO_closure;
      I64[Sp - 40] = stg_ap_pp_info;
      P64[Sp - 32] = sat_s1bQ_closure;
      P64[Sp - 24] = sat_s1c5_closure;
      Sp = Sp - 48;
      call >>_entry() args: 56, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-01 18:20:38.724349 UTC

[(c1NU, {$fMonadIO_closure, sat_s1bQ_closure, sat_s1c5_closure}),
 (c1NV, {}),
 (c1NW, {$fMonadIO_closure, sat_s1bQ_closure, sat_s1c5_closure}),
 (c1NX, {}),
 (c1NY, {$fMonadIO_closure, sat_s1bQ_closure, sat_s1c5_closure})]


==================== procpoint map ====================
2016-08-01 18:20:38.725917 UTC

[(c1NU, reached by c1NW), (c1NV, reached by c1NW),
 (c1NW, <procpt>), (c1NX, reached by c1NW), (c1NY, reached by c1NW)]


==================== Post splitting ====================
2016-08-01 18:20:38.726995 UTC

main_entry() //  [R1]
        { info_tbl: [(c1NW,
                      label: main_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1NW:
          _rnW::P64 = R1;
          if ((Sp + 8) - 56 < SpLim) goto c1NX; else goto c1NY;
      c1NX:
          R1 = _rnW::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1NY:
          (_c1NT::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rnW::P64);
          if (_c1NT::I64 == 0) goto c1NV; else goto c1NU;
      c1NV:
          call (I64[I64[_rnW::P64]])() args: 8, res: 0, upd: 8;
      c1NU:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c1NT::I64;
          P64[Sp - 48] = $fMonadIO_closure;
          I64[Sp - 40] = stg_ap_pp_info;
          P64[Sp - 32] = sat_s1bQ_closure;
          P64[Sp - 24] = sat_s1c5_closure;
          Sp = Sp - 48;
          call >>_entry() args: 56, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:38.730858 UTC

main_entry() //  [R1]
        { info_tbl: [(c1NW,
                      label: main_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1NW:
          _rnW::P64 = R1;
          if ((Sp + 8) - 56 < SpLim) goto c1NX; else goto c1NY;
      c1NX:
          R1 = _rnW::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1NY:
          (_c1NT::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rnW::P64);
          if (_c1NT::I64 == 0) goto c1NV; else goto c1NU;
      c1NV:
          call (I64[I64[_rnW::P64]])() args: 8, res: 0, upd: 8;
      c1NU:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c1NT::I64;
          P64[Sp - 48] = $fMonadIO_closure;
          I64[Sp - 40] = stg_ap_pp_info;
          P64[Sp - 32] = sat_s1bQ_closure;
          P64[Sp - 24] = sat_s1c5_closure;
          Sp = Sp - 48;
          call >>_entry() args: 56, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.734566 UTC

main_entry() //  [R1]
        { info_tbl: [(c1NW,
                      label: main_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1NW:
          _rnW::P64 = R1;
          if ((Sp + 8) - 56 < SpLim) goto c1NX; else goto c1NY;
      c1NX:
          R1 = _rnW::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1NY:
          (_c1NT::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rnW::P64);
          if (_c1NT::I64 == 0) goto c1NV; else goto c1NU;
      c1NV:
          call (I64[I64[_rnW::P64]])() args: 8, res: 0, upd: 8;
      c1NU:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c1NT::I64;
          P64[Sp - 48] = $fMonadIO_closure;
          I64[Sp - 40] = stg_ap_pp_info;
          P64[Sp - 32] = sat_s1bQ_closure;
          P64[Sp - 24] = sat_s1c5_closure;
          Sp = Sp - 48;
          call >>_entry() args: 56, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2016-08-01 18:20:38.738255 UTC

[section "data" {
     main_closure:
         const main_info;
         const 0;
         const 0;
         const 0;
 },
 main_entry() //  [R1]
         { info_tbl: [(c1NW,
                       label: main_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1NW:
           _rnW::P64 = R1;
           if ((Sp + 8) - 56 < SpLim) goto c1NX; else goto c1NY;
       c1NX:
           R1 = _rnW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1NY:
           (_c1NT::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rnW::P64);
           if (_c1NT::I64 == 0) goto c1NV; else goto c1NU;
       c1NV:
           call (I64[I64[_rnW::P64]])() args: 8, res: 0, upd: 8;
       c1NU:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1NT::I64;
           P64[Sp - 48] = $fMonadIO_closure;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = sat_s1bQ_closure;
           P64[Sp - 24] = sat_s1c5_closure;
           Sp = Sp - 48;
           call >>_entry() args: 56, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2016-08-01 18:20:38.743457 UTC

[section "data" {
     main_closure:
         const main_info;
         const 0;
         const 0;
         const 0;
 },
 main_entry() //  [R1]
         { info_tbl: [(c1NW,
                       label: main_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1NW:
           _rnW::P64 = R1;
           if ((Sp + 8) - 56 < SpLim) goto c1NX; else goto c1NY;
       c1NX:
           R1 = _rnW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1NY:
           (_c1NT::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rnW::P64);
           if (_c1NT::I64 == 0) goto c1NV; else goto c1NU;
       c1NV:
           call (I64[I64[_rnW::P64]])() args: 8, res: 0, upd: 8;
       c1NU:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1NT::I64;
           P64[Sp - 48] = $fMonadIO_closure;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = sat_s1bQ_closure;
           P64[Sp - 24] = sat_s1c5_closure;
           Sp = Sp - 48;
           call >>_entry() args: 56, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:20:38.773472 UTC

[section "data" {
     main_closure:
         const main_info;
         const 0;
         const 0;
         const 0;
 },
 main_entry() //  [R1]
         { info_tbl: [(c1Py,
                       label: main_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c1Py:
           _01D::P64 = R1;
           goto c1Pt;
       c1Pt:
           if ((old + 0) - <highSp> < SpLim) goto c1Pz; else goto c1PA;
       c1Pz:
           R1 = _01D::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1PA:
           (_c1Pv::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _01D::P64);
           if (_c1Pv::I64 == 0) goto c1Px; else goto c1Pw;
       c1Px:
           call (I64[I64[_01D::P64]])() args: 8, res: 0, upd: 8;
       c1Pw:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _c1Pv::I64;
           R1 = runMainIO_closure;
           P64[(old + 32)] = main_closure;
           call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.778179 UTC

{offset
  c1Py:
      _01D::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1Pz; else goto c1PA;
  c1Pz:
      R1 = _01D::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1PA:
      (_c1Pv::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _01D::P64);
      if (_c1Pv::I64 == 0) goto c1Px; else goto c1Pw;
  c1Px:
      call (I64[I64[_01D::P64]])() args: 8, res: 0, upd: 8;
  c1Pw:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c1Pv::I64;
      R1 = runMainIO_closure;
      P64[(old + 32)] = main_closure;
      call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-01 18:20:38.780889 UTC

main_entry
[c1Py]
{offset
  c1Py:
      _01D::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c1Pz; else goto c1PA;
  c1Pz:
      R1 = _01D::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1PA:
      (_c1Pv::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _01D::P64);
      if (_c1Pv::I64 == 0) goto c1Px; else goto c1Pw;
  c1Px:
      call (I64[I64[_01D::P64]])() args: 8, res: 0, upd: 8;
  c1Pw:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c1Pv::I64;
      R1 = runMainIO_closure;
      P64[(old + 32)] = main_closure;
      call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-01 18:20:38.784198 UTC

{offset
  c1Py:
      _01D::P64 = R1;
      if ((Sp + 8) - 32 < SpLim) goto c1Pz; else goto c1PA;
  c1Pz:
      R1 = _01D::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c1PA:
      (_c1Pv::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _01D::P64);
      if (_c1Pv::I64 == 0) goto c1Px; else goto c1Pw;
  c1Px:
      call (I64[I64[_01D::P64]])() args: 8, res: 0, upd: 8;
  c1Pw:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _c1Pv::I64;
      R1 = runMainIO_closure;
      P64[Sp - 24] = main_closure;
      Sp = Sp - 24;
      call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-01 18:20:38.787807 UTC

[(c1Pw, {runMainIO_closure, main_closure}), (c1Px, {}),
 (c1Py, {runMainIO_closure, main_closure}), (c1Pz, {}),
 (c1PA, {runMainIO_closure, main_closure})]


==================== procpoint map ====================
2016-08-01 18:20:38.789082 UTC

[(c1Pw, reached by c1Py), (c1Px, reached by c1Py),
 (c1Py, <procpt>), (c1Pz, reached by c1Py), (c1PA, reached by c1Py)]


==================== Post splitting ====================
2016-08-01 18:20:38.79016 UTC

main_entry() //  [R1]
        { info_tbl: [(c1Py,
                      label: main_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1Py:
          _01D::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1Pz; else goto c1PA;
      c1Pz:
          R1 = _01D::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1PA:
          (_c1Pv::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _01D::P64);
          if (_c1Pv::I64 == 0) goto c1Px; else goto c1Pw;
      c1Px:
          call (I64[I64[_01D::P64]])() args: 8, res: 0, upd: 8;
      c1Pw:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c1Pv::I64;
          R1 = runMainIO_closure;
          P64[Sp - 24] = main_closure;
          Sp = Sp - 24;
          call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:38.793932 UTC

main_entry() //  [R1]
        { info_tbl: [(c1Py,
                      label: main_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1Py:
          _01D::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1Pz; else goto c1PA;
      c1Pz:
          R1 = _01D::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1PA:
          (_c1Pv::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _01D::P64);
          if (_c1Pv::I64 == 0) goto c1Px; else goto c1Pw;
      c1Px:
          call (I64[I64[_01D::P64]])() args: 8, res: 0, upd: 8;
      c1Pw:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c1Pv::I64;
          R1 = runMainIO_closure;
          P64[Sp - 24] = main_closure;
          Sp = Sp - 24;
          call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.797275 UTC

main_entry() //  [R1]
        { info_tbl: [(c1Py,
                      label: main_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1Py:
          _01D::P64 = R1;
          if ((Sp + 8) - 32 < SpLim) goto c1Pz; else goto c1PA;
      c1Pz:
          R1 = _01D::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c1PA:
          (_c1Pv::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _01D::P64);
          if (_c1Pv::I64 == 0) goto c1Px; else goto c1Pw;
      c1Px:
          call (I64[I64[_01D::P64]])() args: 8, res: 0, upd: 8;
      c1Pw:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c1Pv::I64;
          R1 = runMainIO_closure;
          P64[Sp - 24] = main_closure;
          Sp = Sp - 24;
          call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2016-08-01 18:20:38.800601 UTC

[section "data" {
     main_closure:
         const main_info;
         const 0;
         const 0;
         const 0;
 },
 main_entry() //  [R1]
         { info_tbl: [(c1Py,
                       label: main_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Py:
           _01D::P64 = R1;
           if ((Sp + 8) - 32 < SpLim) goto c1Pz; else goto c1PA;
       c1Pz:
           R1 = _01D::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1PA:
           (_c1Pv::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _01D::P64);
           if (_c1Pv::I64 == 0) goto c1Px; else goto c1Pw;
       c1Px:
           call (I64[I64[_01D::P64]])() args: 8, res: 0, upd: 8;
       c1Pw:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1Pv::I64;
           R1 = runMainIO_closure;
           P64[Sp - 24] = main_closure;
           Sp = Sp - 24;
           call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2016-08-01 18:20:38.80475 UTC

[section "data" {
     main_closure:
         const main_info;
         const 0;
         const 0;
         const 0;
 },
 main_entry() //  [R1]
         { info_tbl: [(c1Py,
                       label: main_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Py:
           _01D::P64 = R1;
           if ((Sp + 8) - 32 < SpLim) goto c1Pz; else goto c1PA;
       c1Pz:
           R1 = _01D::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1PA:
           (_c1Pv::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _01D::P64);
           if (_c1Pv::I64 == 0) goto c1Px; else goto c1Pw;
       c1Px:
           call (I64[I64[_01D::P64]])() args: 8, res: 0, upd: 8;
       c1Pw:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1Pv::I64;
           R1 = runMainIO_closure;
           P64[Sp - 24] = main_closure;
           Sp = Sp - 24;
           call stg_ap_p_fast(R1) args: 32, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:20:38.83086 UTC

[section "data" {
     Foo_closure:
         const Foo_info;
 },
 Foo_entry() //  []
         { info_tbl: [(c1QS,
                       label: Foo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 16 updfr_space: Just 8
         }
     {offset
       c1QS:
           _B1::P64 = P64[(old + 16)];
           goto c1QP;
       c1QP:
           if ((old + 0) - <highSp> < SpLim) goto c1QT; else goto c1QU;
       c1QU:
           goto c1QO;
       c1QO:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c1QW; else goto c1QV;
       c1QW:
           HpAlloc = 16;
           goto c1QT;
       c1QT:
           R1 = Foo_closure;
           P64[(old + 16)] = _B1::P64;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c1QV:
           I64[Hp - 8] = Foo_con_info;
           P64[Hp] = _B1::P64;
           _c1QR::P64 = Hp - 7;
           R1 = _c1QR::P64;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.836103 UTC

{offset
  c1QS:
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c1QT; else goto c1QU;
  c1QU:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c1QW; else goto c1QV;
  c1QW:
      HpAlloc = 16;
      goto c1QT;
  c1QT:
      R1 = Foo_closure;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c1QV:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c1QR::P64 = Hp - 7;
      R1 = _c1QR::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-01 18:20:38.838624 UTC

Foo_entry
[c1QS]
{offset
  c1QS:
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c1QT; else goto c1QU;
  c1QU:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c1QW; else goto c1QV;
  c1QW:
      HpAlloc = 16;
      goto c1QT;
  c1QT:
      R1 = Foo_closure;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c1QV:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c1QR::P64 = Hp - 7;
      R1 = _c1QR::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-01 18:20:38.841925 UTC

{offset
  c1QS:
      _B1::P64 = P64[Sp];
      goto c1QU;
  c1QU:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c1QW; else goto c1QV;
  c1QW:
      HpAlloc = 16;
      goto c1QT;
  c1QT:
      R1 = Foo_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c1QV:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c1QR::P64 = Hp - 7;
      R1 = _c1QR::P64;
      Sp = Sp + 8;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-01 18:20:38.844183 UTC

[(c1QS, {}), (c1QT, {}), (c1QU, {}), (c1QV, {}), (c1QW, {})]


==================== procpoint map ====================
2016-08-01 18:20:38.845167 UTC

[(c1QS, <procpt>), (c1QT, reached by c1QS),
 (c1QU, reached by c1QS), (c1QV, reached by c1QS),
 (c1QW, reached by c1QS)]


==================== Post splitting ====================
2016-08-01 18:20:38.846265 UTC

Foo_entry() //  []
        { info_tbl: [(c1QS,
                      label: Foo_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1QS:
          _B1::P64 = P64[Sp];
          goto c1QU;
      c1QU:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c1QW; else goto c1QV;
      c1QW:
          HpAlloc = 16;
          goto c1QT;
      c1QT:
          R1 = Foo_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c1QV:
          I64[Hp - 8] = Foo_con_info;
          P64[Hp] = _B1::P64;
          _c1QR::P64 = Hp - 7;
          R1 = _c1QR::P64;
          Sp = Sp + 8;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:38.849321 UTC

Foo_entry() //  []
        { info_tbl: [(c1QS,
                      label: Foo_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1QS:
          _B1::P64 = P64[Sp];
          goto c1QU;
      c1QU:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c1QW; else goto c1QV;
      c1QW:
          HpAlloc = 16;
          goto c1QT;
      c1QT:
          R1 = Foo_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c1QV:
          I64[Hp - 8] = Foo_con_info;
          P64[Hp] = _B1::P64;
          _c1QR::P64 = Hp - 7;
          R1 = _c1QR::P64;
          Sp = Sp + 8;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.852198 UTC

Foo_entry() //  []
        { info_tbl: [(c1QS,
                      label: Foo_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1QS:
          _B1::P64 = P64[Sp];
          goto c1QU;
      c1QU:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c1QW; else goto c1QV;
      c1QW:
          HpAlloc = 16;
          goto c1QT;
      c1QT:
          R1 = Foo_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c1QV:
          I64[Hp - 8] = Foo_con_info;
          P64[Hp] = _B1::P64;
          _c1QR::P64 = Hp - 7;
          R1 = _c1QR::P64;
          Sp = Sp + 8;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-01 18:20:38.855036 UTC

[section "data" {
     Foo_closure:
         const Foo_info;
 },
 Foo_entry() //  []
         { info_tbl: [(c1QS,
                       label: Foo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1QS:
           _B1::P64 = P64[Sp];
           goto c1QU;
       c1QU:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c1QW; else goto c1QV;
       c1QW:
           HpAlloc = 16;
           goto c1QT;
       c1QT:
           R1 = Foo_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c1QV:
           I64[Hp - 8] = Foo_con_info;
           P64[Hp] = _B1::P64;
           _c1QR::P64 = Hp - 7;
           R1 = _c1QR::P64;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-01 18:20:38.858154 UTC

[section "data" {
     Foo_closure:
         const Foo_info;
 },
 Foo_entry() //  []
         { info_tbl: [(c1QS,
                       label: Foo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1QS:
           _B1::P64 = P64[Sp];
           goto c1QU;
       c1QU:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c1QW; else goto c1QV;
       c1QW:
           HpAlloc = 16;
           goto c1QT;
       c1QT:
           R1 = Foo_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c1QV:
           I64[Hp - 8] = Foo_con_info;
           P64[Hp] = _B1::P64;
           _c1QR::P64 = Hp - 7;
           R1 = _c1QR::P64;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:20:38.883239 UTC

[Foo_con_entry() //  []
         { info_tbl: [(c1S9,
                       label: Foo_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c1S9:
           R1 = R1 + 1;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foo_static_entry() //  []
         { info_tbl: [(c1Sa,
                       label: Foo_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c1Sa:
           R1 = R1 + 1;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.886691 UTC

{offset
  c1S9:
      R1 = R1 + 1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-01 18:20:38.887708 UTC

Foo_con_entry
[c1S9]
{offset
  c1S9:
      R1 = R1 + 1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-01 18:20:38.888955 UTC

{offset
  c1S9:
      R1 = R1 + 1;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-01 18:20:38.889914 UTC

[(c1S9, {})]


==================== procpoint map ====================
2016-08-01 18:20:38.890607 UTC

[(c1S9, <procpt>)]


==================== Post splitting ====================
2016-08-01 18:20:38.891352 UTC

Foo_con_entry() //  [R1]
        { info_tbl: [(c1S9,
                      label: Foo_con_info
                      rep:HeapRep 1 ptrs {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1S9:
          R1 = R1 + 1;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:38.893115 UTC

Foo_con_entry() //  [R1]
        { info_tbl: [(c1S9,
                      label: Foo_con_info
                      rep:HeapRep 1 ptrs {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1S9:
          R1 = R1 + 1;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.894758 UTC

Foo_con_entry() //  [R1]
        { info_tbl: [(c1S9,
                      label: Foo_con_info
                      rep:HeapRep 1 ptrs {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1S9:
          R1 = R1 + 1;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.896503 UTC

{offset
  c1Sa:
      R1 = R1 + 1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-01 18:20:38.897513 UTC

Foo_static_entry
[c1Sa]
{offset
  c1Sa:
      R1 = R1 + 1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-01 18:20:38.89874 UTC

{offset
  c1Sa:
      R1 = R1 + 1;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-01 18:20:38.89969 UTC

[(c1Sa, {})]


==================== procpoint map ====================
2016-08-01 18:20:38.900379 UTC

[(c1Sa, <procpt>)]


==================== Post splitting ====================
2016-08-01 18:20:38.901092 UTC

Foo_static_entry() //  [R1]
        { info_tbl: [(c1Sa,
                      label: Foo_static_info
                      rep:HeapRep static {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1Sa:
          R1 = R1 + 1;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:20:38.902805 UTC

Foo_static_entry() //  [R1]
        { info_tbl: [(c1Sa,
                      label: Foo_static_info
                      rep:HeapRep static {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1Sa:
          R1 = R1 + 1;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:20:38.904412 UTC

Foo_static_entry() //  [R1]
        { info_tbl: [(c1Sa,
                      label: Foo_static_info
                      rep:HeapRep static {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c1Sa:
          R1 = R1 + 1;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-01 18:20:38.906034 UTC

[Foo_con_entry() //  [R1]
         { info_tbl: [(c1S9,
                       label: Foo_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1S9:
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foo_static_entry() //  [R1]
         { info_tbl: [(c1Sa,
                       label: Foo_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Sa:
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-01 18:20:38.909117 UTC

[Foo_con_entry() //  [R1]
         { info_tbl: [(c1S9,
                       label: Foo_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1S9:
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foo_static_entry() //  [R1]
         { info_tbl: [(c1Sa,
                       label: Foo_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Sa:
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-01 18:20:38.929449 UTC

[section "relreadonly" {
     S1f3_srt:
         const $fShowInt_closure;
         const unpackCString#_closure;
         const showString_closure;
         const ._closure;
         const $fOrdInt_closure;
         const showParen_closure;
         const $cshowsPrec_r18d_closure;
         const $fShowFoo_closure;
         const showList___closure;
         const sat_s1bN_closure;
         const $dmshow_closure;
         const print_closure;
         const readIORef_closure;
         const $fMonadIO_closure;
         const writeIORef_closure;
         const $!_closure;
         const forkIO_closure;
         const newIORef_closure;
         const $fShow[]_closure;
         const $fShowChar_closure;
         const sat_s1bQ_closure;
         const sat_s1c5_closure;
         const runMainIO_closure;
         const main_closure;
 }]

