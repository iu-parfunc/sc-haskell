
==================== Cmm produced by new codegen ====================
2016-08-01 18:36:30.817952 UTC

[section "data" { __stginit_main@main:Main:
 }]


==================== Post CPS Cmm ====================
2016-08-01 18:36:30.820778 UTC

[section "data" { __stginit_main@main:Main:
 }]


==================== Output Cmm ====================
2016-08-01 18:36:30.821695 UTC

[section "data" { __stginit_main@main:Main:
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:36:30.82418 UTC

[section "data" {
     $fShowFoo2_closure:
         const $fShowFoo2_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     c3Gh_str:
         I8[] [70,111,111,32]
 },
 $fShowFoo2_entry() //  [R1]
         { info_tbl: [(c3Gi,
                       label: $fShowFoo2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c3Gi:
           _r3DM::P64 = R1;
           goto c3Gc;
       c3Gc:
           if ((old + 0) - <highSp> < SpLim) goto c3Gj; else goto c3Gk;
       c3Gj:
           R1 = _r3DM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3Gk:
           (_c3Ge::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3DM::P64);
           if (_c3Ge::I64 == 0) goto c3Gg; else goto c3Gf;
       c3Gg:
           call (I64[I64[_r3DM::P64]])() args: 8, res: 0, upd: 8;
       c3Gf:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _c3Ge::I64;
           I64[(old + 32)] = c3Gh_str;
           call unpackCString#_entry() args: 32, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-01 18:36:30.829802 UTC

{offset
  c3Gi:
      _r3DM::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3Gj; else goto c3Gk;
  c3Gj:
      R1 = _r3DM::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3Gk:
      (_c3Ge::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3DM::P64);
      if (_c3Ge::I64 == 0) goto c3Gg; else goto c3Gf;
  c3Gg:
      call (I64[I64[_r3DM::P64]])() args: 8, res: 0, upd: 8;
  c3Gf:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c3Ge::I64;
      I64[(old + 32)] = c3Gh_str;
      call unpackCString#_entry() args: 32, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2016-08-01 18:36:30.832757 UTC

{offset
  c3Gi:
      _r3DM::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3Gj; else goto c3Gk;
  c3Gj:
      R1 = _r3DM::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3Gk:
      (_c3Ge::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3DM::P64);
      if (_c3Ge::I64 == 0) goto c3Gg; else goto c3Gf;
  c3Gg:
      call (I64[I64[_r3DM::P64]])() args: 8, res: 0, upd: 8;
  c3Gf:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c3Ge::I64;
      I64[(old + 32)] = c3Gh_str;
      call unpackCString#_entry() args: 32, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-01 18:36:30.835327 UTC

$fShowFoo2_entry
[c3Gi]
{offset
  c3Gi:
      _r3DM::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3Gj; else goto c3Gk;
  c3Gj:
      R1 = _r3DM::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3Gk:
      (_c3Ge::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3DM::P64);
      if (_c3Ge::I64 == 0) goto c3Gg; else goto c3Gf;
  c3Gg:
      call (I64[I64[_r3DM::P64]])() args: 8, res: 0, upd: 8;
  c3Gf:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c3Ge::I64;
      I64[(old + 32)] = c3Gh_str;
      call unpackCString#_entry() args: 32, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-01 18:36:30.838637 UTC

{offset
  c3Gi:
      _r3DM::P64 = R1;
      if ((Sp + 8) - 32 < SpLim) goto c3Gj; else goto c3Gk;
  c3Gj:
      R1 = _r3DM::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3Gk:
      (_c3Ge::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3DM::P64);
      if (_c3Ge::I64 == 0) goto c3Gg; else goto c3Gf;
  c3Gg:
      call (I64[I64[_r3DM::P64]])() args: 8, res: 0, upd: 8;
  c3Gf:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _c3Ge::I64;
      I64[Sp - 24] = c3Gh_str;
      Sp = Sp - 24;
      call unpackCString#_entry() args: 32, res: 0, upd: 24;
}


==================== Sink assignments ====================
2016-08-01 18:36:30.841949 UTC

{offset
  c3Gi:
      if ((Sp + -24) < SpLim) goto c3Gj; else goto c3Gk;
  c3Gj:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3Gk:
      (_c3Ge::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
      if (_c3Ge::I64 == 0) goto c3Gg; else goto c3Gf;
  c3Gg:
      call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
  c3Gf:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _c3Ge::I64;
      I64[Sp - 24] = c3Gh_str;
      Sp = Sp - 24;
      call unpackCString#_entry() args: 32, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-01 18:36:30.8444 UTC

[(c3Gf, {}), (c3Gg, {}), (c3Gi, {}), (c3Gj, {}), (c3Gk, {})]


==================== procpoint map ====================
2016-08-01 18:36:30.845426 UTC

[(c3Gf, reached by c3Gi), (c3Gg, reached by c3Gi),
 (c3Gi, <procpt>), (c3Gj, reached by c3Gi), (c3Gk, reached by c3Gi)]


==================== Post splitting ====================
2016-08-01 18:36:30.84653 UTC

$fShowFoo2_entry() //  [R1]
        { info_tbl: [(c3Gi,
                      label: $fShowFoo2_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Gi:
          if ((Sp + -24) < SpLim) goto c3Gj; else goto c3Gk;
      c3Gj:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3Gk:
          (_c3Ge::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
          if (_c3Ge::I64 == 0) goto c3Gg; else goto c3Gf;
      c3Gg:
          call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
      c3Gf:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c3Ge::I64;
          I64[Sp - 24] = c3Gh_str;
          Sp = Sp - 24;
          call unpackCString#_entry() args: 32, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:30.849791 UTC

$fShowFoo2_entry() //  [R1]
        { info_tbl: [(c3Gi,
                      label: $fShowFoo2_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Gi:
          if ((Sp + -24) < SpLim) goto c3Gj; else goto c3Gk;
      c3Gj:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3Gk:
          (_c3Ge::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
          if (_c3Ge::I64 == 0) goto c3Gg; else goto c3Gf;
      c3Gg:
          call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
      c3Gf:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c3Ge::I64;
          I64[Sp - 24] = c3Gh_str;
          Sp = Sp - 24;
          call unpackCString#_entry() args: 32, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:30.852894 UTC

$fShowFoo2_entry() //  [R1]
        { info_tbl: [(c3Gi,
                      label: $fShowFoo2_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Gi:
          if ((Sp + -24) < SpLim) goto c3Gj; else goto c3Gk;
      c3Gj:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3Gk:
          (_c3Ge::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
          if (_c3Ge::I64 == 0) goto c3Gg; else goto c3Gf;
      c3Gg:
          call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
      c3Gf:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c3Ge::I64;
          I64[Sp - 24] = c3Gh_str;
          Sp = Sp - 24;
          call unpackCString#_entry() args: 32, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2016-08-01 18:36:30.856011 UTC

[section "data" {
     $fShowFoo2_closure:
         const $fShowFoo2_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     c3Gh_str:
         I8[] [70,111,111,32]
 },
 $fShowFoo2_entry() //  [R1]
         { info_tbl: [(c3Gi,
                       label: $fShowFoo2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Gi:
           if ((Sp + -24) < SpLim) goto c3Gj; else goto c3Gk;
       c3Gj:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3Gk:
           (_c3Ge::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c3Ge::I64 == 0) goto c3Gg; else goto c3Gf;
       c3Gg:
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c3Gf:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c3Ge::I64;
           I64[Sp - 24] = c3Gh_str;
           Sp = Sp - 24;
           call unpackCString#_entry() args: 32, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2016-08-01 18:36:30.859853 UTC

[section "data" {
     $fShowFoo2_closure:
         const $fShowFoo2_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     c3Gh_str:
         I8[] [70,111,111,32]
 },
 $fShowFoo2_entry() //  [R1]
         { info_tbl: [(c3Gi,
                       label: $fShowFoo2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Gi:
           if ((Sp + -24) < SpLim) goto c3Gj; else goto c3Gk;
       c3Gj:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3Gk:
           (_c3Ge::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c3Ge::I64 == 0) goto c3Gg; else goto c3Gf;
       c3Gg:
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c3Gf:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c3Ge::I64;
           I64[Sp - 24] = c3Gh_str;
           Sp = Sp - 24;
           call unpackCString#_entry() args: 32, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:36:30.886851 UTC

[section "data" {
     $w$cshowsPrec_closure:
         const $w$cshowsPrec_info;
         const 0;
 },
 sat_s3Et_entry() //  [R1]
         { info_tbl: [(c3HN,
                       label: sat_s3Et_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c3HN:
           _s3Et::P64 = R1;
           goto c3HI;
       c3HI:
           if ((old + 0) - <highSp> < SpLim) goto c3HT; else goto c3HU;
       c3HT:
           R1 = _s3Et::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3HU:
           _s3Ek::P64 = P64[_s3Et::P64 + 16];
           _s3El::P64 = P64[_s3Et::P64 + 24];
           I64[(young<c3HK> + 8)] = c3HK;
           R1 = _s3Ek::P64;
           if (R1 & 7 != 0) goto c3HK; else goto c3HL;
       c3HL:
           call (I64[I64[R1]])(R1) returns to c3HK, args: 8, res: 8, upd: 8;
       c3HK:
           _s3Eo::P64 = R1;
           _s3Ep::I64 = I64[_s3Eo::P64 + 7];
           I64[(young<c3HQ> + 8)] = c3HQ;
           I64[(young<c3HQ> + 32)] = 11;
           I64[(young<c3HQ> + 24)] = _s3Ep::I64;
           P64[(young<c3HQ> + 16)] = _s3El::P64;
           call $wshowSignedInt_entry() returns to c3HQ, args: 32, res: 16, upd: 8;
       c3HQ:
           _s3Er::P64 = R1;
           _s3Es::P64 = P64[(young<c3HQ> + 16)];
           Hp = Hp + 24;
           if (Hp > HpLim) goto c3HY; else goto c3HX;
       c3HY:
           HpAlloc = 24;
           goto c3HW;
       c3HW:
           R1 = _s3Er::P64;
           P64[(young<c3HQ> + 16)] = _s3Es::P64;
           call stg_gc_pp(R1) returns to c3HQ, args: 16, res: 16, upd: 8;
       c3HX:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _s3Er::P64;
           P64[Hp] = _s3Es::P64;
           _c3HS::P64 = Hp - 14;
           R1 = _c3HS::P64;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s3EA_entry() //  [R1]
         { info_tbl: [(c3Ib,
                       label: sat_s3EA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c3Ib:
           _s3EA::P64 = R1;
           goto c3I6;
       c3I6:
           if ((old + 0) - <highSp> < SpLim) goto c3Ii; else goto c3Ij;
       c3Ii:
           R1 = _s3EA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3Ij:
           _s3Ek::P64 = P64[_s3EA::P64 + 16];
           _s3El::P64 = P64[_s3EA::P64 + 24];
           I64[(young<c3I8> + 8)] = c3I8;
           R1 = _s3Ek::P64;
           if (R1 & 7 != 0) goto c3I8; else goto c3I9;
       c3I9:
           call (I64[I64[R1]])(R1) returns to c3I8, args: 8, res: 8, upd: 8;
       c3I8:
           _s3Eu::P64 = R1;
           Hp = Hp + 24;
           if (Hp > HpLim) goto c3Im; else goto c3Il;
       c3Im:
           HpAlloc = 24;
           goto c3Ik;
       c3Ik:
           R1 = _s3Eu::P64;
           call stg_gc_unpt_r1(R1) returns to c3I8, args: 8, res: 8, upd: 8;
       c3Il:
           _s3Ev::I64 = I64[_s3Eu::P64 + 7];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = shows8_closure;
           P64[Hp] = _s3El::P64;
           _c3Ie::P64 = Hp - 14;
           I64[(young<c3If> + 8)] = c3If;
           I64[(young<c3If> + 32)] = 11;
           I64[(young<c3If> + 24)] = _s3Ev::I64;
           P64[(young<c3If> + 16)] = _c3Ie::P64;
           call $wshowSignedInt_entry() returns to c3If, args: 32, res: 16, upd: 8;
       c3If:
           _s3Ey::P64 = R1;
           _s3Ez::P64 = P64[(young<c3If> + 16)];
           Hp = Hp + 24;
           if (Hp > HpLim) goto c3Ip; else goto c3Io;
       c3Ip:
           HpAlloc = 24;
           goto c3In;
       c3In:
           R1 = _s3Ey::P64;
           P64[(young<c3If> + 16)] = _s3Ez::P64;
           call stg_gc_pp(R1) returns to c3If, args: 16, res: 16, upd: 8;
       c3Io:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _s3Ey::P64;
           P64[Hp] = _s3Ez::P64;
           _c3Ih::P64 = Hp - 14;
           R1 = _c3Ih::P64;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s3EB_entry() //  [R1]
         { info_tbl: [(c3Iq,
                       label: sat_s3EB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c3Iq:
           _s3EB::P64 = R1;
           goto c3I2;
       c3I2:
           if ((old + 0) - <highSp> < SpLim) goto c3Ir; else goto c3Is;
       c3Is:
           Hp = Hp + 32;
           if (Hp > HpLim) goto c3Iu; else goto c3It;
       c3Iu:
           HpAlloc = 32;
           goto c3Ir;
       c3Ir:
           R1 = _s3EB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3It:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _s3EB::P64;
           _s3Ek::P64 = P64[_s3EB::P64 + 16];
           _s3El::P64 = P64[_s3EB::P64 + 24];
           I64[Hp - 24] = sat_s3EA_info;
           P64[Hp - 8] = _s3Ek::P64;
           P64[Hp] = _s3El::P64;
           _c3I4::P64 = Hp - 24;
           P64[(old + 40)] = $fShowFoo2_closure;
           P64[(old + 32)] = _c3I4::P64;
           call ++_entry() args: 40, res: 0, upd: 24;
     }
 },
 $w$cshowsPrec_entry() //  []
         { info_tbl: [(c3Iv,
                       label: $w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 32 updfr_space: Just 8
         }
     {offset
       c3Iv:
           _s3Ej::I64 = I64[(old + 32)];
           _s3Ek::P64 = P64[(old + 24)];
           _s3El::P64 = P64[(old + 16)];
           goto c3Hz;
       c3Hz:
           if ((old + 0) - <highSp> < SpLim) goto c3Iw; else goto c3Ix;
       c3Ix:
           goto c3Hy;
       c3Hy:
           Hp = Hp + 56;
           if (Hp > HpLim) goto c3Iz; else goto c3Iy;
       c3Iz:
           HpAlloc = 56;
           goto c3Iw;
       c3Iw:
           R1 = $w$cshowsPrec_closure;
           I64[(old + 32)] = _s3Ej::I64;
           P64[(old + 24)] = _s3Ek::P64;
           P64[(old + 16)] = _s3El::P64;
           call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
       c3Iy:
           _c3HB::I64 = %MO_S_Ge_W64(_s3Ej::I64, 11);
           _s3Em::I64 = _c3HB::I64;
           if (_s3Em::I64 >= 1) goto c3IF; else goto c3IG;
       c3IF:
           goto c3ID;
       c3ID:
           I64[Hp - 48] = sat_s3EB_info;
           P64[Hp - 32] = _s3Ek::P64;
           P64[Hp - 24] = _s3El::P64;
           _c3I0::P64 = Hp - 48;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = shows9_closure;
           P64[Hp] = _c3I0::P64;
           _c3IC::P64 = Hp - 14;
           R1 = _c3IC::P64;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
       c3IG:
           goto c3IB;
       c3IB:
           I64[Hp - 48] = sat_s3Et_info;
           P64[Hp - 32] = _s3Ek::P64;
           P64[Hp - 24] = _s3El::P64;
           _c3HG::P64 = Hp - 48;
           Hp = Hp - 24;
           P64[(old + 24)] = $fShowFoo2_closure;
           P64[(old + 16)] = _c3HG::P64;
           call ++_entry() args: 24, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-01 18:36:30.925624 UTC

{offset
  c3HN:
      _s3Et::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3HT; else goto c3HU;
  c3HT:
      R1 = _s3Et::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3HU:
      _s3Ek::P64 = P64[_s3Et::P64 + 16];
      _s3El::P64 = P64[_s3Et::P64 + 24];
      I64[(young<c3HK> + 8)] = c3HK;
      R1 = _s3Ek::P64;
      if (R1 & 7 != 0) goto c3HK; else goto c3HL;
  c3HL:
      call (I64[I64[R1]])(R1) returns to c3HK, args: 8, res: 8, upd: 8;
  c3HK:
      _s3Eo::P64 = R1;
      _s3Ep::I64 = I64[_s3Eo::P64 + 7];
      I64[(young<c3HQ> + 8)] = c3HQ;
      I64[(young<c3HQ> + 32)] = 11;
      I64[(young<c3HQ> + 24)] = _s3Ep::I64;
      P64[(young<c3HQ> + 16)] = _s3El::P64;
      call $wshowSignedInt_entry() returns to c3HQ, args: 32, res: 16, upd: 8;
  c3HQ:
      _s3Er::P64 = R1;
      _s3Es::P64 = P64[(young<c3HQ> + 16)];
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3HY; else goto c3HX;
  c3HY:
      HpAlloc = 24;
      R1 = _s3Er::P64;
      P64[(young<c3HQ> + 16)] = _s3Es::P64;
      call stg_gc_pp(R1) returns to c3HQ, args: 16, res: 16, upd: 8;
  c3HX:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _s3Er::P64;
      P64[Hp] = _s3Es::P64;
      _c3HS::P64 = Hp - 14;
      R1 = _c3HS::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-01 18:36:30.931319 UTC

{offset
  c3HN:
      _s3Et::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3HT; else goto c3HU;
  c3HT:
      R1 = _s3Et::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3HU:
      _s3Ek::P64 = P64[_s3Et::P64 + 16];
      _s3El::P64 = P64[_s3Et::P64 + 24];
      I64[(young<c3HK> + 8)] = c3HK;
      R1 = _s3Ek::P64;
      if (R1 & 7 != 0) goto c3HK; else goto c3HL;
  c3HL:
      call (I64[I64[R1]])(R1) returns to c3HK, args: 8, res: 8, upd: 8;
  c3HK:
      _s3Eo::P64 = R1;
      _s3Ep::I64 = I64[_s3Eo::P64 + 7];
      I64[(young<c3HQ> + 8)] = c3HQ;
      I64[(young<c3HQ> + 32)] = 11;
      I64[(young<c3HQ> + 24)] = _s3Ep::I64;
      P64[(young<c3HQ> + 16)] = _s3El::P64;
      call $wshowSignedInt_entry() returns to c3HQ, args: 32, res: 16, upd: 8;
  c3HQ:
      _s3Er::P64 = R1;
      _s3Es::P64 = P64[(young<c3HQ> + 16)];
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3HY; else goto c3HX;
  c3HY:
      HpAlloc = 24;
      R1 = _s3Er::P64;
      P64[(young<c3HQ> + 16)] = _s3Es::P64;
      call stg_gc_pp(R1) returns to c3HQ, args: 16, res: 16, upd: 8;
  c3HX:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _s3Er::P64;
      P64[Hp] = _s3Es::P64;
      _c3HS::P64 = Hp - 14;
      R1 = _c3HS::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-01 18:36:30.93648 UTC

sat_s3Et_entry
[c3HK, c3HN, c3HQ]
{offset
  c3HN:
      _s3Et::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3HT; else goto c3HU;
  c3HT:
      R1 = _s3Et::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3HU:
      _s3Ek::P64 = P64[_s3Et::P64 + 16];
      _s3El::P64 = P64[_s3Et::P64 + 24];
      I64[(young<c3HK> + 8)] = c3HK;
      R1 = _s3Ek::P64;
      if (R1 & 7 != 0) goto c3HK; else goto c3HL;
  c3HL:
      call (I64[I64[R1]])(R1) returns to c3HK, args: 8, res: 8, upd: 8;
  c3HK:
      _s3Eo::P64 = R1;
      _s3Ep::I64 = I64[_s3Eo::P64 + 7];
      I64[(young<c3HQ> + 8)] = c3HQ;
      I64[(young<c3HQ> + 32)] = 11;
      I64[(young<c3HQ> + 24)] = _s3Ep::I64;
      P64[(young<c3HQ> + 16)] = _s3El::P64;
      call $wshowSignedInt_entry() returns to c3HQ, args: 32, res: 16, upd: 8;
  c3HQ:
      _s3Er::P64 = R1;
      _s3Es::P64 = P64[(young<c3HQ> + 16)];
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3HY; else goto c3HX;
  c3HY:
      HpAlloc = 24;
      R1 = _s3Er::P64;
      P64[(young<c3HQ> + 16)] = _s3Es::P64;
      call stg_gc_pp(R1) returns to c3HQ, args: 16, res: 16, upd: 8;
  c3HX:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _s3Er::P64;
      P64[Hp] = _s3Es::P64;
      _c3HS::P64 = Hp - 14;
      R1 = _c3HS::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-01 18:36:30.942976 UTC

{offset
  c3HN:
      _s3Et::P64 = R1;
      if ((Sp + 8) - 40 < SpLim) goto c3HT; else goto c3HU;
  c3HT:
      R1 = _s3Et::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3HU:
      _s3Ek::P64 = P64[_s3Et::P64 + 16];
      _s3El::P64 = P64[_s3Et::P64 + 24];
      I64[Sp - 16] = c3HK;
      R1 = _s3Ek::P64;
      P64[Sp - 8] = _s3El::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto c3HK; else goto c3HL;
  c3HL:
      call (I64[I64[R1]])(R1) returns to c3HK, args: 8, res: 8, upd: 8;
  c3HK:
      _s3El::P64 = P64[Sp + 8];
      _s3Eo::P64 = R1;
      _s3Ep::I64 = I64[_s3Eo::P64 + 7];
      I64[Sp + 8] = c3HQ;
      I64[Sp - 16] = 11;
      I64[Sp - 8] = _s3Ep::I64;
      P64[Sp] = _s3El::P64;
      Sp = Sp - 16;
      call $wshowSignedInt_entry() returns to c3HQ, args: 32, res: 16, upd: 8;
  c3HQ:
      _s3Er::P64 = R1;
      _s3Es::P64 = P64[Sp];
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3HY; else goto c3HX;
  c3HY:
      HpAlloc = 24;
      R1 = _s3Er::P64;
      call stg_gc_pp(R1) returns to c3HQ, args: 16, res: 16, upd: 8;
  c3HX:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _s3Er::P64;
      P64[Hp] = _s3Es::P64;
      _c3HS::P64 = Hp - 14;
      R1 = _c3HS::P64;
      Sp = Sp + 16;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-01 18:36:30.949345 UTC

{offset
  c3HN:
      if ((Sp + -32) < SpLim) goto c3HT; else goto c3HU;
  c3HT:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3HU:
      I64[Sp - 16] = c3HK;
      _s3El::P64 = P64[R1 + 24];
      R1 = P64[R1 + 16];
      P64[Sp - 8] = _s3El::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto c3HK; else goto c3HL;
  c3HL:
      call (I64[I64[R1]])(R1) returns to c3HK, args: 8, res: 8, upd: 8;
  c3HK:
      _s3El::P64 = P64[Sp + 8];
      I64[Sp + 8] = c3HQ;
      I64[Sp - 16] = 11;
      I64[Sp - 8] = I64[R1 + 7];
      P64[Sp] = _s3El::P64;
      Sp = Sp - 16;
      call $wshowSignedInt_entry() returns to c3HQ, args: 32, res: 16, upd: 8;
  c3HQ:
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3HY; else goto c3HX;
  c3HY:
      HpAlloc = 24;
      R1 = R1;
      call stg_gc_pp(R1) returns to c3HQ, args: 16, res: 16, upd: 8;
  c3HX:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = R1;
      P64[Hp] = P64[Sp];
      R1 = Hp - 14;
      Sp = Sp + 16;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-01 18:36:30.953877 UTC

[(c3HK, {}), (c3HL, {}), (c3HN, {}), (c3HQ, {}), (c3HT, {}),
 (c3HU, {}), (c3HX, {}), (c3HY, {})]


==================== procpoint map ====================
2016-08-01 18:36:30.955127 UTC

[(c3HK, <procpt>), (c3HL, reached by c3HN), (c3HN, <procpt>),
 (c3HQ, <procpt>), (c3HT, reached by c3HN), (c3HU, reached by c3HN),
 (c3HX, reached by c3HQ), (c3HY, reached by c3HQ)]


==================== Post splitting ====================
2016-08-01 18:36:30.956478 UTC

sat_s3Et_entry() //  [R1]
        { info_tbl: [(c3HN,
                      label: sat_s3Et_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3HN:
          if ((Sp + -32) < SpLim) goto c3HT; else goto c3HU;
      c3HT:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3HU:
          I64[Sp - 16] = block_c3HK_info;
          _s3El::P64 = P64[R1 + 24];
          R1 = P64[R1 + 16];
          P64[Sp - 8] = _s3El::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto u3IH; else goto c3HL;
      u3IH:
          call block_c3HK_entry(R1) args: 0, res: 0, upd: 0;
      c3HL:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-01 18:36:30.959881 UTC

block_c3HK_entry() //  [R1]
        { info_tbl: [(c3HK,
                      label: block_c3HK_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3HK:
          _s3El::P64 = P64[Sp + 8];
          I64[Sp + 8] = block_c3HQ_info;
          I64[Sp - 16] = 11;
          I64[Sp - 8] = I64[R1 + 7];
          P64[Sp] = _s3El::P64;
          Sp = Sp - 16;
          call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-01 18:36:30.962035 UTC

block_c3HQ_entry() //  [R1]
        { info_tbl: [(c3HQ,
                      label: block_c3HQ_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3HQ:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c3HY; else goto c3HX;
      c3HY:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
      c3HX:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = P64[Sp];
          R1 = Hp - 14;
          Sp = Sp + 16;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:30.964478 UTC

sat_s3Et_entry() //  [R1]
        { info_tbl: [(c3HN,
                      label: sat_s3Et_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3HN:
          if ((Sp + -32) < SpLim) goto c3HT; else goto c3HU;
      c3HT:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3HU:
          I64[Sp - 16] = block_c3HK_info;
          _s3El::P64 = P64[R1 + 24];
          R1 = P64[R1 + 16];
          P64[Sp - 8] = _s3El::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto u3IH; else goto c3HL;
      u3IH:
          call block_c3HK_entry(R1) args: 0, res: 0, upd: 0;
      c3HL:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:30.967435 UTC

block_c3HK_entry() //  [R1]
        { info_tbl: [(c3HK,
                      label: block_c3HK_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3HK:
          _s3El::P64 = P64[Sp + 8];
          I64[Sp + 8] = block_c3HQ_info;
          I64[Sp - 16] = 11;
          I64[Sp - 8] = I64[R1 + 7];
          P64[Sp] = _s3El::P64;
          Sp = Sp - 16;
          call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:30.969542 UTC

block_c3HQ_entry() //  [R1]
        { info_tbl: [(c3HQ,
                      label: block_c3HQ_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3HQ:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c3HY; else goto c3HX;
      c3HY:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
      c3HX:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = P64[Sp];
          R1 = Hp - 14;
          Sp = Sp + 16;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:30.972071 UTC

sat_s3Et_entry() //  [R1]
        { info_tbl: [(c3HN,
                      label: sat_s3Et_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3HN:
          if ((Sp + -32) < SpLim) goto c3HT; else goto c3HU;
      c3HT:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3HU:
          I64[Sp - 16] = block_c3HK_info;
          _s3El::P64 = P64[R1 + 24];
          R1 = P64[R1 + 16];
          P64[Sp - 8] = _s3El::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto u3IH; else goto c3HL;
      u3IH:
          call block_c3HK_entry(R1) args: 0, res: 0, upd: 0;
      c3HL:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:30.976301 UTC

block_c3HK_entry() //  [R1]
        { info_tbl: [(c3HK,
                      label: block_c3HK_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3HK:
          _s3El::P64 = P64[Sp + 8];
          I64[Sp + 8] = block_c3HQ_info;
          I64[Sp - 16] = 11;
          I64[Sp - 8] = I64[R1 + 7];
          P64[Sp] = _s3El::P64;
          Sp = Sp - 16;
          call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:30.978393 UTC

block_c3HQ_entry() //  [R1]
        { info_tbl: [(c3HQ,
                      label: block_c3HQ_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3HQ:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c3HY; else goto c3HX;
      c3HY:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
      c3HX:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = P64[Sp];
          R1 = Hp - 14;
          Sp = Sp + 16;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:30.981467 UTC

{offset
  c3Ib:
      _s3EA::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3Ii; else goto c3Ij;
  c3Ii:
      R1 = _s3EA::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3Ij:
      _s3Ek::P64 = P64[_s3EA::P64 + 16];
      _s3El::P64 = P64[_s3EA::P64 + 24];
      I64[(young<c3I8> + 8)] = c3I8;
      R1 = _s3Ek::P64;
      if (R1 & 7 != 0) goto c3I8; else goto c3I9;
  c3I9:
      call (I64[I64[R1]])(R1) returns to c3I8, args: 8, res: 8, upd: 8;
  c3I8:
      _s3Eu::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3Im; else goto c3Il;
  c3Im:
      HpAlloc = 24;
      R1 = _s3Eu::P64;
      call stg_gc_unpt_r1(R1) returns to c3I8, args: 8, res: 8, upd: 8;
  c3Il:
      _s3Ev::I64 = I64[_s3Eu::P64 + 7];
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows8_closure;
      P64[Hp] = _s3El::P64;
      _c3Ie::P64 = Hp - 14;
      I64[(young<c3If> + 8)] = c3If;
      I64[(young<c3If> + 32)] = 11;
      I64[(young<c3If> + 24)] = _s3Ev::I64;
      P64[(young<c3If> + 16)] = _c3Ie::P64;
      call $wshowSignedInt_entry() returns to c3If, args: 32, res: 16, upd: 8;
  c3If:
      _s3Ey::P64 = R1;
      _s3Ez::P64 = P64[(young<c3If> + 16)];
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3Ip; else goto c3Io;
  c3Ip:
      HpAlloc = 24;
      R1 = _s3Ey::P64;
      P64[(young<c3If> + 16)] = _s3Ez::P64;
      call stg_gc_pp(R1) returns to c3If, args: 16, res: 16, upd: 8;
  c3Io:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _s3Ey::P64;
      P64[Hp] = _s3Ez::P64;
      _c3Ih::P64 = Hp - 14;
      R1 = _c3Ih::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-01 18:36:30.988257 UTC

{offset
  c3Ib:
      _s3EA::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3Ii; else goto c3Ij;
  c3Ii:
      R1 = _s3EA::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3Ij:
      _s3Ek::P64 = P64[_s3EA::P64 + 16];
      _s3El::P64 = P64[_s3EA::P64 + 24];
      I64[(young<c3I8> + 8)] = c3I8;
      R1 = _s3Ek::P64;
      if (R1 & 7 != 0) goto c3I8; else goto c3I9;
  c3I9:
      call (I64[I64[R1]])(R1) returns to c3I8, args: 8, res: 8, upd: 8;
  c3I8:
      _s3Eu::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3Im; else goto c3Il;
  c3Im:
      HpAlloc = 24;
      R1 = _s3Eu::P64;
      call stg_gc_unpt_r1(R1) returns to c3I8, args: 8, res: 8, upd: 8;
  c3Il:
      _s3Ev::I64 = I64[_s3Eu::P64 + 7];
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows8_closure;
      P64[Hp] = _s3El::P64;
      _c3Ie::P64 = Hp - 14;
      I64[(young<c3If> + 8)] = c3If;
      I64[(young<c3If> + 32)] = 11;
      I64[(young<c3If> + 24)] = _s3Ev::I64;
      P64[(young<c3If> + 16)] = _c3Ie::P64;
      call $wshowSignedInt_entry() returns to c3If, args: 32, res: 16, upd: 8;
  c3If:
      _s3Ey::P64 = R1;
      _s3Ez::P64 = P64[(young<c3If> + 16)];
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3Ip; else goto c3Io;
  c3Ip:
      HpAlloc = 24;
      R1 = _s3Ey::P64;
      P64[(young<c3If> + 16)] = _s3Ez::P64;
      call stg_gc_pp(R1) returns to c3If, args: 16, res: 16, upd: 8;
  c3Io:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _s3Ey::P64;
      P64[Hp] = _s3Ez::P64;
      _c3Ih::P64 = Hp - 14;
      R1 = _c3Ih::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-01 18:36:30.994609 UTC

sat_s3EA_entry
[c3I8, c3Ib, c3If]
{offset
  c3Ib:
      _s3EA::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3Ii; else goto c3Ij;
  c3Ii:
      R1 = _s3EA::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3Ij:
      _s3Ek::P64 = P64[_s3EA::P64 + 16];
      _s3El::P64 = P64[_s3EA::P64 + 24];
      I64[(young<c3I8> + 8)] = c3I8;
      R1 = _s3Ek::P64;
      if (R1 & 7 != 0) goto c3I8; else goto c3I9;
  c3I9:
      call (I64[I64[R1]])(R1) returns to c3I8, args: 8, res: 8, upd: 8;
  c3I8:
      _s3Eu::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3Im; else goto c3Il;
  c3Im:
      HpAlloc = 24;
      R1 = _s3Eu::P64;
      call stg_gc_unpt_r1(R1) returns to c3I8, args: 8, res: 8, upd: 8;
  c3Il:
      _s3Ev::I64 = I64[_s3Eu::P64 + 7];
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows8_closure;
      P64[Hp] = _s3El::P64;
      _c3Ie::P64 = Hp - 14;
      I64[(young<c3If> + 8)] = c3If;
      I64[(young<c3If> + 32)] = 11;
      I64[(young<c3If> + 24)] = _s3Ev::I64;
      P64[(young<c3If> + 16)] = _c3Ie::P64;
      call $wshowSignedInt_entry() returns to c3If, args: 32, res: 16, upd: 8;
  c3If:
      _s3Ey::P64 = R1;
      _s3Ez::P64 = P64[(young<c3If> + 16)];
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3Ip; else goto c3Io;
  c3Ip:
      HpAlloc = 24;
      R1 = _s3Ey::P64;
      P64[(young<c3If> + 16)] = _s3Ez::P64;
      call stg_gc_pp(R1) returns to c3If, args: 16, res: 16, upd: 8;
  c3Io:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _s3Ey::P64;
      P64[Hp] = _s3Ez::P64;
      _c3Ih::P64 = Hp - 14;
      R1 = _c3Ih::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-01 18:36:31.002339 UTC

{offset
  c3Ib:
      _s3EA::P64 = R1;
      if ((Sp + 8) - 40 < SpLim) goto c3Ii; else goto c3Ij;
  c3Ii:
      R1 = _s3EA::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3Ij:
      _s3Ek::P64 = P64[_s3EA::P64 + 16];
      _s3El::P64 = P64[_s3EA::P64 + 24];
      I64[Sp - 16] = c3I8;
      R1 = _s3Ek::P64;
      P64[Sp - 8] = _s3El::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto c3I8; else goto c3I9;
  c3I9:
      call (I64[I64[R1]])(R1) returns to c3I8, args: 8, res: 8, upd: 8;
  c3I8:
      _s3El::P64 = P64[Sp + 8];
      _s3Eu::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3Im; else goto c3Il;
  c3Im:
      HpAlloc = 24;
      R1 = _s3Eu::P64;
      call stg_gc_unpt_r1(R1) returns to c3I8, args: 8, res: 8, upd: 8;
  c3Il:
      _s3Ev::I64 = I64[_s3Eu::P64 + 7];
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows8_closure;
      P64[Hp] = _s3El::P64;
      _c3Ie::P64 = Hp - 14;
      I64[Sp + 8] = c3If;
      I64[Sp - 16] = 11;
      I64[Sp - 8] = _s3Ev::I64;
      P64[Sp] = _c3Ie::P64;
      Sp = Sp - 16;
      call $wshowSignedInt_entry() returns to c3If, args: 32, res: 16, upd: 8;
  c3If:
      _s3Ey::P64 = R1;
      _s3Ez::P64 = P64[Sp];
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3Ip; else goto c3Io;
  c3Ip:
      HpAlloc = 24;
      R1 = _s3Ey::P64;
      call stg_gc_pp(R1) returns to c3If, args: 16, res: 16, upd: 8;
  c3Io:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _s3Ey::P64;
      P64[Hp] = _s3Ez::P64;
      _c3Ih::P64 = Hp - 14;
      R1 = _c3Ih::P64;
      Sp = Sp + 16;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-01 18:36:31.010009 UTC

{offset
  c3Ib:
      if ((Sp + -32) < SpLim) goto c3Ii; else goto c3Ij;
  c3Ii:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3Ij:
      I64[Sp - 16] = c3I8;
      _s3El::P64 = P64[R1 + 24];
      R1 = P64[R1 + 16];
      P64[Sp - 8] = _s3El::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto c3I8; else goto c3I9;
  c3I9:
      call (I64[I64[R1]])(R1) returns to c3I8, args: 8, res: 8, upd: 8;
  c3I8:
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3Im; else goto c3Il;
  c3Im:
      HpAlloc = 24;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to c3I8, args: 8, res: 8, upd: 8;
  c3Il:
      _s3Ev::I64 = I64[R1 + 7];
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows8_closure;
      P64[Hp] = P64[Sp + 8];
      I64[Sp + 8] = c3If;
      I64[Sp - 16] = 11;
      I64[Sp - 8] = _s3Ev::I64;
      P64[Sp] = Hp - 14;
      Sp = Sp - 16;
      call $wshowSignedInt_entry() returns to c3If, args: 32, res: 16, upd: 8;
  c3If:
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3Ip; else goto c3Io;
  c3Ip:
      HpAlloc = 24;
      R1 = R1;
      call stg_gc_pp(R1) returns to c3If, args: 16, res: 16, upd: 8;
  c3Io:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = R1;
      P64[Hp] = P64[Sp];
      R1 = Hp - 14;
      Sp = Sp + 16;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-01 18:36:31.01544 UTC

[(c3I8, {}), (c3I9, {}), (c3Ib, {}), (c3If, {}), (c3Ii, {}),
 (c3Ij, {}), (c3Il, {}), (c3Im, {}), (c3Io, {}), (c3Ip, {})]


==================== procpoint map ====================
2016-08-01 18:36:31.016844 UTC

[(c3I8, <procpt>), (c3I9, reached by c3Ib), (c3Ib, <procpt>),
 (c3If, <procpt>), (c3Ii, reached by c3Ib), (c3Ij, reached by c3Ib),
 (c3Il, reached by c3I8), (c3Im, reached by c3I8),
 (c3Io, reached by c3If), (c3Ip, reached by c3If)]


==================== Post splitting ====================
2016-08-01 18:36:31.018394 UTC

sat_s3EA_entry() //  [R1]
        { info_tbl: [(c3Ib,
                      label: sat_s3EA_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Ib:
          if ((Sp + -32) < SpLim) goto c3Ii; else goto c3Ij;
      c3Ii:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3Ij:
          I64[Sp - 16] = block_c3I8_info;
          _s3El::P64 = P64[R1 + 24];
          R1 = P64[R1 + 16];
          P64[Sp - 8] = _s3El::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto u3II; else goto c3I9;
      u3II:
          call block_c3I8_entry(R1) args: 0, res: 0, upd: 0;
      c3I9:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-01 18:36:31.021945 UTC

block_c3I8_entry() //  [R1]
        { info_tbl: [(c3I8,
                      label: block_c3I8_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3I8:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c3Im; else goto c3Il;
      c3Im:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c3Il:
          _s3Ev::I64 = I64[R1 + 7];
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = shows8_closure;
          P64[Hp] = P64[Sp + 8];
          I64[Sp + 8] = block_c3If_info;
          I64[Sp - 16] = 11;
          I64[Sp - 8] = _s3Ev::I64;
          P64[Sp] = Hp - 14;
          Sp = Sp - 16;
          call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-01 18:36:31.025009 UTC

block_c3If_entry() //  [R1]
        { info_tbl: [(c3If,
                      label: block_c3If_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3If:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c3Ip; else goto c3Io;
      c3Ip:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
      c3Io:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = P64[Sp];
          R1 = Hp - 14;
          Sp = Sp + 16;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:31.027472 UTC

sat_s3EA_entry() //  [R1]
        { info_tbl: [(c3Ib,
                      label: sat_s3EA_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Ib:
          if ((Sp + -32) < SpLim) goto c3Ii; else goto c3Ij;
      c3Ii:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3Ij:
          I64[Sp - 16] = block_c3I8_info;
          _s3El::P64 = P64[R1 + 24];
          R1 = P64[R1 + 16];
          P64[Sp - 8] = _s3El::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto u3II; else goto c3I9;
      u3II:
          call block_c3I8_entry(R1) args: 0, res: 0, upd: 0;
      c3I9:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:31.030438 UTC

block_c3I8_entry() //  [R1]
        { info_tbl: [(c3I8,
                      label: block_c3I8_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3I8:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c3Im; else goto c3Il;
      c3Im:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c3Il:
          _s3Ev::I64 = I64[R1 + 7];
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = shows8_closure;
          P64[Hp] = P64[Sp + 8];
          I64[Sp + 8] = block_c3If_info;
          I64[Sp - 16] = 11;
          I64[Sp - 8] = _s3Ev::I64;
          P64[Sp] = Hp - 14;
          Sp = Sp - 16;
          call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:31.033522 UTC

block_c3If_entry() //  [R1]
        { info_tbl: [(c3If,
                      label: block_c3If_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3If:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c3Ip; else goto c3Io;
      c3Ip:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
      c3Io:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = P64[Sp];
          R1 = Hp - 14;
          Sp = Sp + 16;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.035955 UTC

sat_s3EA_entry() //  [R1]
        { info_tbl: [(c3Ib,
                      label: sat_s3EA_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Ib:
          if ((Sp + -32) < SpLim) goto c3Ii; else goto c3Ij;
      c3Ii:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3Ij:
          I64[Sp - 16] = block_c3I8_info;
          _s3El::P64 = P64[R1 + 24];
          R1 = P64[R1 + 16];
          P64[Sp - 8] = _s3El::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto u3II; else goto c3I9;
      u3II:
          call block_c3I8_entry(R1) args: 0, res: 0, upd: 0;
      c3I9:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.038968 UTC

block_c3I8_entry() //  [R1]
        { info_tbl: [(c3I8,
                      label: block_c3I8_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3I8:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c3Im; else goto c3Il;
      c3Im:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c3Il:
          _s3Ev::I64 = I64[R1 + 7];
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = shows8_closure;
          P64[Hp] = P64[Sp + 8];
          I64[Sp + 8] = block_c3If_info;
          I64[Sp - 16] = 11;
          I64[Sp - 8] = _s3Ev::I64;
          P64[Sp] = Hp - 14;
          Sp = Sp - 16;
          call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.042072 UTC

block_c3If_entry() //  [R1]
        { info_tbl: [(c3If,
                      label: block_c3If_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3If:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c3Ip; else goto c3Io;
      c3Ip:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
      c3Io:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = P64[Sp];
          R1 = Hp - 14;
          Sp = Sp + 16;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.044881 UTC

{offset
  c3Iq:
      _s3EB::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3Ir; else goto c3Is;
  c3Is:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c3Iu; else goto c3It;
  c3Iu:
      HpAlloc = 32;
      goto c3Ir;
  c3Ir:
      R1 = _s3EB::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3It:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s3EB::P64;
      _s3Ek::P64 = P64[_s3EB::P64 + 16];
      _s3El::P64 = P64[_s3EB::P64 + 24];
      I64[Hp - 24] = sat_s3EA_info;
      P64[Hp - 8] = _s3Ek::P64;
      P64[Hp] = _s3El::P64;
      _c3I4::P64 = Hp - 24;
      P64[(old + 40)] = $fShowFoo2_closure;
      P64[(old + 32)] = _c3I4::P64;
      call ++_entry() args: 40, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2016-08-01 18:36:31.04832 UTC

{offset
  c3Iq:
      _s3EB::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3Ir; else goto c3Is;
  c3Is:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c3Iu; else goto c3It;
  c3Iu:
      HpAlloc = 32;
      goto c3Ir;
  c3Ir:
      R1 = _s3EB::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3It:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s3EB::P64;
      _s3Ek::P64 = P64[_s3EB::P64 + 16];
      _s3El::P64 = P64[_s3EB::P64 + 24];
      I64[Hp - 24] = sat_s3EA_info;
      P64[Hp - 8] = _s3Ek::P64;
      P64[Hp] = _s3El::P64;
      _c3I4::P64 = Hp - 24;
      P64[(old + 40)] = $fShowFoo2_closure;
      P64[(old + 32)] = _c3I4::P64;
      call ++_entry() args: 40, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-01 18:36:31.052505 UTC

sat_s3EB_entry
[c3Iq]
{offset
  c3Iq:
      _s3EB::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3Ir; else goto c3Is;
  c3Is:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c3Iu; else goto c3It;
  c3Iu:
      HpAlloc = 32;
      goto c3Ir;
  c3Ir:
      R1 = _s3EB::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3It:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s3EB::P64;
      _s3Ek::P64 = P64[_s3EB::P64 + 16];
      _s3El::P64 = P64[_s3EB::P64 + 24];
      I64[Hp - 24] = sat_s3EA_info;
      P64[Hp - 8] = _s3Ek::P64;
      P64[Hp] = _s3El::P64;
      _c3I4::P64 = Hp - 24;
      P64[(old + 40)] = $fShowFoo2_closure;
      P64[(old + 32)] = _c3I4::P64;
      call ++_entry() args: 40, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-01 18:36:31.056286 UTC

{offset
  c3Iq:
      _s3EB::P64 = R1;
      if ((Sp + 8) - 40 < SpLim) goto c3Ir; else goto c3Is;
  c3Is:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c3Iu; else goto c3It;
  c3Iu:
      HpAlloc = 32;
      goto c3Ir;
  c3Ir:
      R1 = _s3EB::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3It:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _s3EB::P64;
      _s3Ek::P64 = P64[_s3EB::P64 + 16];
      _s3El::P64 = P64[_s3EB::P64 + 24];
      I64[Hp - 24] = sat_s3EA_info;
      P64[Hp - 8] = _s3Ek::P64;
      P64[Hp] = _s3El::P64;
      _c3I4::P64 = Hp - 24;
      P64[Sp - 32] = $fShowFoo2_closure;
      P64[Sp - 24] = _c3I4::P64;
      Sp = Sp - 32;
      call ++_entry() args: 40, res: 0, upd: 24;
}


==================== Sink assignments ====================
2016-08-01 18:36:31.06007 UTC

{offset
  c3Iq:
      _s3EB::P64 = R1;
      if ((Sp + -32) < SpLim) goto c3Ir; else goto c3Is;
  c3Is:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c3Iu; else goto c3It;
  c3Iu:
      HpAlloc = 32;
      goto c3Ir;
  c3Ir:
      R1 = _s3EB::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3It:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _s3EB::P64;
      _s3Ek::P64 = P64[_s3EB::P64 + 16];
      _s3El::P64 = P64[_s3EB::P64 + 24];
      I64[Hp - 24] = sat_s3EA_info;
      P64[Hp - 8] = _s3Ek::P64;
      P64[Hp] = _s3El::P64;
      P64[Sp - 32] = $fShowFoo2_closure;
      P64[Sp - 24] = Hp - 24;
      Sp = Sp - 32;
      call ++_entry() args: 40, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-01 18:36:31.063217 UTC

[(c3Iq, {$fShowFoo2_closure, sat_s3EA_closure}), (c3Ir, {}),
 (c3Is, {$fShowFoo2_closure, sat_s3EA_closure}),
 (c3It, {$fShowFoo2_closure, sat_s3EA_closure}), (c3Iu, {})]


==================== procpoint map ====================
2016-08-01 18:36:31.064559 UTC

[(c3Iq, <procpt>), (c3Ir, reached by c3Iq),
 (c3Is, reached by c3Iq), (c3It, reached by c3Iq),
 (c3Iu, reached by c3Iq)]


==================== Post splitting ====================
2016-08-01 18:36:31.065654 UTC

sat_s3EB_entry() //  [R1]
        { info_tbl: [(c3Iq,
                      label: sat_s3EB_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Iq:
          _s3EB::P64 = R1;
          if ((Sp + -32) < SpLim) goto c3Ir; else goto c3Is;
      c3Is:
          Hp = Hp + 32;
          if (Hp > HpLim) goto c3Iu; else goto c3It;
      c3Iu:
          HpAlloc = 32;
          goto c3Ir;
      c3Ir:
          R1 = _s3EB::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3It:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s3EB::P64;
          _s3Ek::P64 = P64[_s3EB::P64 + 16];
          _s3El::P64 = P64[_s3EB::P64 + 24];
          I64[Hp - 24] = sat_s3EA_info;
          P64[Hp - 8] = _s3Ek::P64;
          P64[Hp] = _s3El::P64;
          P64[Sp - 32] = $fShowFoo2_closure;
          P64[Sp - 24] = Hp - 24;
          Sp = Sp - 32;
          call ++_entry() args: 40, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:31.069552 UTC

sat_s3EB_entry() //  [R1]
        { info_tbl: [(c3Iq,
                      label: sat_s3EB_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Iq:
          _s3EB::P64 = R1;
          if ((Sp + -32) < SpLim) goto c3Ir; else goto c3Is;
      c3Is:
          Hp = Hp + 32;
          if (Hp > HpLim) goto c3Iu; else goto c3It;
      c3Iu:
          HpAlloc = 32;
          goto c3Ir;
      c3Ir:
          R1 = _s3EB::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3It:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s3EB::P64;
          _s3Ek::P64 = P64[_s3EB::P64 + 16];
          _s3El::P64 = P64[_s3EB::P64 + 24];
          I64[Hp - 24] = sat_s3EA_info;
          P64[Hp - 8] = _s3Ek::P64;
          P64[Hp] = _s3El::P64;
          P64[Sp - 32] = $fShowFoo2_closure;
          P64[Sp - 24] = Hp - 24;
          Sp = Sp - 32;
          call ++_entry() args: 40, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.073305 UTC

sat_s3EB_entry() //  [R1]
        { info_tbl: [(c3Iq,
                      label: sat_s3EB_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Iq:
          _s3EB::P64 = R1;
          if ((Sp + -32) < SpLim) goto c3Ir; else goto c3Is;
      c3Is:
          Hp = Hp + 32;
          if (Hp > HpLim) goto c3Iu; else goto c3It;
      c3Iu:
          HpAlloc = 32;
          goto c3Ir;
      c3Ir:
          R1 = _s3EB::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3It:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s3EB::P64;
          _s3Ek::P64 = P64[_s3EB::P64 + 16];
          _s3El::P64 = P64[_s3EB::P64 + 24];
          I64[Hp - 24] = sat_s3EA_info;
          P64[Hp - 8] = _s3Ek::P64;
          P64[Hp] = _s3El::P64;
          P64[Sp - 32] = $fShowFoo2_closure;
          P64[Sp - 24] = Hp - 24;
          Sp = Sp - 32;
          call ++_entry() args: 40, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.077499 UTC

{offset
  c3Iv:
      _s3Ej::I64 = I64[(old + 32)];
      _s3Ek::P64 = P64[(old + 24)];
      _s3El::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3Iw; else goto c3Ix;
  c3Ix:
      Hp = Hp + 56;
      if (Hp > HpLim) goto c3Iz; else goto c3Iy;
  c3Iz:
      HpAlloc = 56;
      goto c3Iw;
  c3Iw:
      R1 = $w$cshowsPrec_closure;
      I64[(old + 32)] = _s3Ej::I64;
      P64[(old + 24)] = _s3Ek::P64;
      P64[(old + 16)] = _s3El::P64;
      call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
  c3Iy:
      _c3HB::I64 = %MO_S_Ge_W64(_s3Ej::I64, 11);
      _s3Em::I64 = _c3HB::I64;
      if (_s3Em::I64 >= 1) goto c3IF; else goto c3IG;
  c3IF:
      I64[Hp - 48] = sat_s3EB_info;
      P64[Hp - 32] = _s3Ek::P64;
      P64[Hp - 24] = _s3El::P64;
      _c3I0::P64 = Hp - 48;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows9_closure;
      P64[Hp] = _c3I0::P64;
      _c3IC::P64 = Hp - 14;
      R1 = _c3IC::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
  c3IG:
      I64[Hp - 48] = sat_s3Et_info;
      P64[Hp - 32] = _s3Ek::P64;
      P64[Hp - 24] = _s3El::P64;
      _c3HG::P64 = Hp - 48;
      Hp = Hp - 24;
      P64[(old + 24)] = $fShowFoo2_closure;
      P64[(old + 16)] = _c3HG::P64;
      call ++_entry() args: 24, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-01 18:36:31.083229 UTC

{offset
  c3Iv:
      _s3Ej::I64 = I64[(old + 32)];
      _s3Ek::P64 = P64[(old + 24)];
      _s3El::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3Iw; else goto c3Ix;
  c3Ix:
      Hp = Hp + 56;
      if (Hp > HpLim) goto c3Iz; else goto c3Iy;
  c3Iz:
      HpAlloc = 56;
      goto c3Iw;
  c3Iw:
      R1 = $w$cshowsPrec_closure;
      I64[(old + 32)] = _s3Ej::I64;
      P64[(old + 24)] = _s3Ek::P64;
      P64[(old + 16)] = _s3El::P64;
      call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
  c3Iy:
      _c3HB::I64 = %MO_S_Ge_W64(_s3Ej::I64, 11);
      _s3Em::I64 = _c3HB::I64;
      if (_s3Em::I64 >= 1) goto c3IF; else goto c3IG;
  c3IF:
      I64[Hp - 48] = sat_s3EB_info;
      P64[Hp - 32] = _s3Ek::P64;
      P64[Hp - 24] = _s3El::P64;
      _c3I0::P64 = Hp - 48;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows9_closure;
      P64[Hp] = _c3I0::P64;
      _c3IC::P64 = Hp - 14;
      R1 = _c3IC::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
  c3IG:
      I64[Hp - 48] = sat_s3Et_info;
      P64[Hp - 32] = _s3Ek::P64;
      P64[Hp - 24] = _s3El::P64;
      _c3HG::P64 = Hp - 48;
      Hp = Hp - 24;
      P64[(old + 24)] = $fShowFoo2_closure;
      P64[(old + 16)] = _c3HG::P64;
      call ++_entry() args: 24, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-01 18:36:31.08844 UTC

$w$cshowsPrec_entry
[c3Iv]
{offset
  c3Iv:
      _s3Ej::I64 = I64[(old + 32)];
      _s3Ek::P64 = P64[(old + 24)];
      _s3El::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3Iw; else goto c3Ix;
  c3Ix:
      Hp = Hp + 56;
      if (Hp > HpLim) goto c3Iz; else goto c3Iy;
  c3Iz:
      HpAlloc = 56;
      goto c3Iw;
  c3Iw:
      R1 = $w$cshowsPrec_closure;
      I64[(old + 32)] = _s3Ej::I64;
      P64[(old + 24)] = _s3Ek::P64;
      P64[(old + 16)] = _s3El::P64;
      call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
  c3Iy:
      _c3HB::I64 = %MO_S_Ge_W64(_s3Ej::I64, 11);
      _s3Em::I64 = _c3HB::I64;
      if (_s3Em::I64 >= 1) goto c3IF; else goto c3IG;
  c3IF:
      I64[Hp - 48] = sat_s3EB_info;
      P64[Hp - 32] = _s3Ek::P64;
      P64[Hp - 24] = _s3El::P64;
      _c3I0::P64 = Hp - 48;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows9_closure;
      P64[Hp] = _c3I0::P64;
      _c3IC::P64 = Hp - 14;
      R1 = _c3IC::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
  c3IG:
      I64[Hp - 48] = sat_s3Et_info;
      P64[Hp - 32] = _s3Ek::P64;
      P64[Hp - 24] = _s3El::P64;
      _c3HG::P64 = Hp - 48;
      Hp = Hp - 24;
      P64[(old + 24)] = $fShowFoo2_closure;
      P64[(old + 16)] = _c3HG::P64;
      call ++_entry() args: 24, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-01 18:36:31.09474 UTC

{offset
  c3Iv:
      _s3Ej::I64 = I64[Sp];
      _s3Ek::P64 = P64[Sp + 8];
      _s3El::P64 = P64[Sp + 16];
      goto c3Ix;
  c3Ix:
      Hp = Hp + 56;
      if (Hp > HpLim) goto c3Iz; else goto c3Iy;
  c3Iz:
      HpAlloc = 56;
      goto c3Iw;
  c3Iw:
      R1 = $w$cshowsPrec_closure;
      call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
  c3Iy:
      _c3HB::I64 = %MO_S_Ge_W64(_s3Ej::I64, 11);
      _s3Em::I64 = _c3HB::I64;
      if (_s3Em::I64 >= 1) goto c3IF; else goto c3IG;
  c3IF:
      I64[Hp - 48] = sat_s3EB_info;
      P64[Hp - 32] = _s3Ek::P64;
      P64[Hp - 24] = _s3El::P64;
      _c3I0::P64 = Hp - 48;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows9_closure;
      P64[Hp] = _c3I0::P64;
      _c3IC::P64 = Hp - 14;
      R1 = _c3IC::P64;
      Sp = Sp + 24;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
  c3IG:
      I64[Hp - 48] = sat_s3Et_info;
      P64[Hp - 32] = _s3Ek::P64;
      P64[Hp - 24] = _s3El::P64;
      _c3HG::P64 = Hp - 48;
      Hp = Hp - 24;
      P64[Sp + 8] = $fShowFoo2_closure;
      P64[Sp + 16] = _c3HG::P64;
      Sp = Sp + 8;
      call ++_entry() args: 24, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-01 18:36:31.100443 UTC

{offset
  c3Iv:
      goto c3Ix;
  c3Ix:
      Hp = Hp + 56;
      if (Hp > HpLim) goto c3Iz; else goto c3Iy;
  c3Iz:
      HpAlloc = 56;
      goto c3Iw;
  c3Iw:
      R1 = $w$cshowsPrec_closure;
      call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
  c3Iy:
      _s3Ek::P64 = P64[Sp + 8];
      _s3El::P64 = P64[Sp + 16];
      if (%MO_S_Ge_W64(I64[Sp], 11)) goto c3IF; else goto c3IG;
  c3IF:
      I64[Hp - 48] = sat_s3EB_info;
      P64[Hp - 32] = _s3Ek::P64;
      P64[Hp - 24] = _s3El::P64;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows9_closure;
      P64[Hp] = Hp - 48;
      R1 = Hp - 14;
      Sp = Sp + 24;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
  c3IG:
      I64[Hp - 48] = sat_s3Et_info;
      P64[Hp - 32] = _s3Ek::P64;
      P64[Hp - 24] = _s3El::P64;
      _c3HG::P64 = Hp - 48;
      Hp = Hp - 24;
      P64[Sp + 8] = $fShowFoo2_closure;
      P64[Sp + 16] = _c3HG::P64;
      Sp = Sp + 8;
      call ++_entry() args: 24, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-01 18:36:31.104675 UTC

[(c3Iv,
  {$w$cshowsPrec_closure, $fShowFoo2_closure, sat_s3Et_closure,
   sat_s3EB_closure}),
 (c3Iw, {$w$cshowsPrec_closure}),
 (c3Ix,
  {$w$cshowsPrec_closure, $fShowFoo2_closure, sat_s3Et_closure,
   sat_s3EB_closure}),
 (c3Iy, {$fShowFoo2_closure, sat_s3Et_closure, sat_s3EB_closure}),
 (c3Iz, {$w$cshowsPrec_closure}), (c3IF, {sat_s3EB_closure}),
 (c3IG, {$fShowFoo2_closure, sat_s3Et_closure})]


==================== procpoint map ====================
2016-08-01 18:36:31.106805 UTC

[(c3Iv, <procpt>), (c3Iw, reached by c3Iv),
 (c3Ix, reached by c3Iv), (c3Iy, reached by c3Iv),
 (c3Iz, reached by c3Iv), (c3IF, reached by c3Iv),
 (c3IG, reached by c3Iv)]


==================== Post splitting ====================
2016-08-01 18:36:31.108087 UTC

$w$cshowsPrec_entry() //  []
        { info_tbl: [(c3Iv,
                      label: $w$cshowsPrec_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Iv:
          goto c3Ix;
      c3Ix:
          Hp = Hp + 56;
          if (Hp > HpLim) goto c3Iz; else goto c3Iy;
      c3Iz:
          HpAlloc = 56;
          goto c3Iw;
      c3Iw:
          R1 = $w$cshowsPrec_closure;
          call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
      c3Iy:
          _s3Ek::P64 = P64[Sp + 8];
          _s3El::P64 = P64[Sp + 16];
          if (%MO_S_Ge_W64(I64[Sp], 11)) goto c3IF; else goto c3IG;
      c3IF:
          I64[Hp - 48] = sat_s3EB_info;
          P64[Hp - 32] = _s3Ek::P64;
          P64[Hp - 24] = _s3El::P64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = shows9_closure;
          P64[Hp] = Hp - 48;
          R1 = Hp - 14;
          Sp = Sp + 24;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
      c3IG:
          I64[Hp - 48] = sat_s3Et_info;
          P64[Hp - 32] = _s3Ek::P64;
          P64[Hp - 24] = _s3El::P64;
          _c3HG::P64 = Hp - 48;
          Hp = Hp - 24;
          P64[Sp + 8] = $fShowFoo2_closure;
          P64[Sp + 16] = _c3HG::P64;
          Sp = Sp + 8;
          call ++_entry() args: 24, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:31.1133 UTC

$w$cshowsPrec_entry() //  []
        { info_tbl: [(c3Iv,
                      label: $w$cshowsPrec_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Iv:
          goto c3Ix;
      c3Ix:
          Hp = Hp + 56;
          if (Hp > HpLim) goto c3Iz; else goto c3Iy;
      c3Iz:
          HpAlloc = 56;
          goto c3Iw;
      c3Iw:
          R1 = $w$cshowsPrec_closure;
          call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
      c3Iy:
          _s3Ek::P64 = P64[Sp + 8];
          _s3El::P64 = P64[Sp + 16];
          if (%MO_S_Ge_W64(I64[Sp], 11)) goto c3IF; else goto c3IG;
      c3IF:
          I64[Hp - 48] = sat_s3EB_info;
          P64[Hp - 32] = _s3Ek::P64;
          P64[Hp - 24] = _s3El::P64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = shows9_closure;
          P64[Hp] = Hp - 48;
          R1 = Hp - 14;
          Sp = Sp + 24;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
      c3IG:
          I64[Hp - 48] = sat_s3Et_info;
          P64[Hp - 32] = _s3Ek::P64;
          P64[Hp - 24] = _s3El::P64;
          _c3HG::P64 = Hp - 48;
          Hp = Hp - 24;
          P64[Sp + 8] = $fShowFoo2_closure;
          P64[Sp + 16] = _c3HG::P64;
          Sp = Sp + 8;
          call ++_entry() args: 24, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.118146 UTC

$w$cshowsPrec_entry() //  []
        { info_tbl: [(c3Iv,
                      label: $w$cshowsPrec_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Iv:
          Hp = Hp + 56;
          if (Hp > HpLim) goto c3Iz; else goto c3Iy;
      c3Iz:
          HpAlloc = 56;
          R1 = $w$cshowsPrec_closure;
          call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
      c3Iy:
          _s3Ek::P64 = P64[Sp + 8];
          _s3El::P64 = P64[Sp + 16];
          if (%MO_S_Ge_W64(I64[Sp], 11)) goto c3IF; else goto c3IG;
      c3IF:
          I64[Hp - 48] = sat_s3EB_info;
          P64[Hp - 32] = _s3Ek::P64;
          P64[Hp - 24] = _s3El::P64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = shows9_closure;
          P64[Hp] = Hp - 48;
          R1 = Hp - 14;
          Sp = Sp + 24;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
      c3IG:
          I64[Hp - 48] = sat_s3Et_info;
          P64[Hp - 32] = _s3Ek::P64;
          P64[Hp - 24] = _s3El::P64;
          _c3HG::P64 = Hp - 48;
          Hp = Hp - 24;
          P64[Sp + 8] = $fShowFoo2_closure;
          P64[Sp + 16] = _c3HG::P64;
          Sp = Sp + 8;
          call ++_entry() args: 24, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-01 18:36:31.123024 UTC

[section "data" {
     $w$cshowsPrec_closure:
         const $w$cshowsPrec_info;
         const 0;
 },
 sat_s3Et_entry() //  [R1]
         { info_tbl: [(c3HN,
                       label: sat_s3Et_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3HN:
           if ((Sp + -32) < SpLim) goto c3HT; else goto c3HU;
       c3HT:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3HU:
           I64[Sp - 16] = block_c3HK_info;
           _s3El::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 8] = _s3El::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u3IH; else goto c3HL;
       u3IH:
           call block_c3HK_entry(R1) args: 0, res: 0, upd: 0;
       c3HL:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3HK_entry() //  [R1]
         { info_tbl: [(c3HK,
                       label: block_c3HK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3HK:
           _s3El::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c3HQ_info;
           I64[Sp - 16] = 11;
           I64[Sp - 8] = I64[R1 + 7];
           P64[Sp] = _s3El::P64;
           Sp = Sp - 16;
           call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
     }
 },
 block_c3HQ_entry() //  [R1]
         { info_tbl: [(c3HQ,
                       label: block_c3HQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3HQ:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c3HY; else goto c3HX;
       c3HY:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
       c3HX:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp];
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s3EA_entry() //  [R1]
         { info_tbl: [(c3Ib,
                       label: sat_s3EA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Ib:
           if ((Sp + -32) < SpLim) goto c3Ii; else goto c3Ij;
       c3Ii:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3Ij:
           I64[Sp - 16] = block_c3I8_info;
           _s3El::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 8] = _s3El::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u3II; else goto c3I9;
       u3II:
           call block_c3I8_entry(R1) args: 0, res: 0, upd: 0;
       c3I9:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3I8_entry() //  [R1]
         { info_tbl: [(c3I8,
                       label: block_c3I8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3I8:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c3Im; else goto c3Il;
       c3Im:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c3Il:
           _s3Ev::I64 = I64[R1 + 7];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = shows8_closure;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c3If_info;
           I64[Sp - 16] = 11;
           I64[Sp - 8] = _s3Ev::I64;
           P64[Sp] = Hp - 14;
           Sp = Sp - 16;
           call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
     }
 },
 block_c3If_entry() //  [R1]
         { info_tbl: [(c3If,
                       label: block_c3If_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3If:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c3Ip; else goto c3Io;
       c3Ip:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
       c3Io:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp];
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s3EB_entry() //  [R1]
         { info_tbl: [(c3Iq,
                       label: sat_s3EB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Iq:
           _s3EB::P64 = R1;
           if ((Sp + -32) < SpLim) goto c3Ir; else goto c3Is;
       c3Is:
           Hp = Hp + 32;
           if (Hp > HpLim) goto c3Iu; else goto c3It;
       c3Iu:
           HpAlloc = 32;
           goto c3Ir;
       c3Ir:
           R1 = _s3EB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3It:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s3EB::P64;
           _s3Ek::P64 = P64[_s3EB::P64 + 16];
           _s3El::P64 = P64[_s3EB::P64 + 24];
           I64[Hp - 24] = sat_s3EA_info;
           P64[Hp - 8] = _s3Ek::P64;
           P64[Hp] = _s3El::P64;
           P64[Sp - 32] = $fShowFoo2_closure;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call ++_entry() args: 40, res: 0, upd: 24;
     }
 },
 $w$cshowsPrec_entry() //  []
         { info_tbl: [(c3Iv,
                       label: $w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Iv:
           Hp = Hp + 56;
           if (Hp > HpLim) goto c3Iz; else goto c3Iy;
       c3Iz:
           HpAlloc = 56;
           R1 = $w$cshowsPrec_closure;
           call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
       c3Iy:
           _s3Ek::P64 = P64[Sp + 8];
           _s3El::P64 = P64[Sp + 16];
           if (%MO_S_Ge_W64(I64[Sp], 11)) goto c3IF; else goto c3IG;
       c3IF:
           I64[Hp - 48] = sat_s3EB_info;
           P64[Hp - 32] = _s3Ek::P64;
           P64[Hp - 24] = _s3El::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = shows9_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c3IG:
           I64[Hp - 48] = sat_s3Et_info;
           P64[Hp - 32] = _s3Ek::P64;
           P64[Hp - 24] = _s3El::P64;
           _c3HG::P64 = Hp - 48;
           Hp = Hp - 24;
           P64[Sp + 8] = $fShowFoo2_closure;
           P64[Sp + 16] = _c3HG::P64;
           Sp = Sp + 8;
           call ++_entry() args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-01 18:36:31.155153 UTC

[section "data" {
     $w$cshowsPrec_closure:
         const $w$cshowsPrec_info;
         const 0;
 },
 sat_s3Et_entry() //  [R1]
         { info_tbl: [(c3HN,
                       label: sat_s3Et_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3HN:
           if ((Sp + -32) < SpLim) goto c3HT; else goto c3HU;
       c3HT:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3HU:
           I64[Sp - 16] = block_c3HK_info;
           _s3El::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 8] = _s3El::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u3IH; else goto c3HL;
       u3IH:
           call block_c3HK_entry(R1) args: 0, res: 0, upd: 0;
       c3HL:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3HK_entry() //  [R1]
         { info_tbl: [(c3HK,
                       label: block_c3HK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3HK:
           _s3El::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c3HQ_info;
           I64[Sp - 16] = 11;
           I64[Sp - 8] = I64[R1 + 7];
           P64[Sp] = _s3El::P64;
           Sp = Sp - 16;
           call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
     }
 },
 block_c3HQ_entry() //  [R1]
         { info_tbl: [(c3HQ,
                       label: block_c3HQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3HQ:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c3HY; else goto c3HX;
       c3HY:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
       c3HX:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp];
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s3EA_entry() //  [R1]
         { info_tbl: [(c3Ib,
                       label: sat_s3EA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Ib:
           if ((Sp + -32) < SpLim) goto c3Ii; else goto c3Ij;
       c3Ii:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3Ij:
           I64[Sp - 16] = block_c3I8_info;
           _s3El::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 8] = _s3El::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u3II; else goto c3I9;
       u3II:
           call block_c3I8_entry(R1) args: 0, res: 0, upd: 0;
       c3I9:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3I8_entry() //  [R1]
         { info_tbl: [(c3I8,
                       label: block_c3I8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3I8:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c3Im; else goto c3Il;
       c3Im:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c3Il:
           _s3Ev::I64 = I64[R1 + 7];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = shows8_closure;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c3If_info;
           I64[Sp - 16] = 11;
           I64[Sp - 8] = _s3Ev::I64;
           P64[Sp] = Hp - 14;
           Sp = Sp - 16;
           call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
     }
 },
 block_c3If_entry() //  [R1]
         { info_tbl: [(c3If,
                       label: block_c3If_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3If:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c3Ip; else goto c3Io;
       c3Ip:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
       c3Io:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp];
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s3EB_entry() //  [R1]
         { info_tbl: [(c3Iq,
                       label: sat_s3EB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Iq:
           _s3EB::P64 = R1;
           if ((Sp + -32) < SpLim) goto c3Ir; else goto c3Is;
       c3Is:
           Hp = Hp + 32;
           if (Hp > HpLim) goto c3Iu; else goto c3It;
       c3Iu:
           HpAlloc = 32;
           goto c3Ir;
       c3Ir:
           R1 = _s3EB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3It:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s3EB::P64;
           _s3Ek::P64 = P64[_s3EB::P64 + 16];
           _s3El::P64 = P64[_s3EB::P64 + 24];
           I64[Hp - 24] = sat_s3EA_info;
           P64[Hp - 8] = _s3Ek::P64;
           P64[Hp] = _s3El::P64;
           P64[Sp - 32] = $fShowFoo2_closure;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call ++_entry() args: 40, res: 0, upd: 24;
     }
 },
 $w$cshowsPrec_entry() //  []
         { info_tbl: [(c3Iv,
                       label: $w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Iv:
           Hp = Hp + 56;
           if (Hp > HpLim) goto c3Iz; else goto c3Iy;
       c3Iz:
           HpAlloc = 56;
           R1 = $w$cshowsPrec_closure;
           call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
       c3Iy:
           _s3Ek::P64 = P64[Sp + 8];
           _s3El::P64 = P64[Sp + 16];
           if (%MO_S_Ge_W64(I64[Sp], 11)) goto c3IF; else goto c3IG;
       c3IF:
           I64[Hp - 48] = sat_s3EB_info;
           P64[Hp - 32] = _s3Ek::P64;
           P64[Hp - 24] = _s3El::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = shows9_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c3IG:
           I64[Hp - 48] = sat_s3Et_info;
           P64[Hp - 32] = _s3Ek::P64;
           P64[Hp - 24] = _s3El::P64;
           _c3HG::P64 = Hp - 48;
           Hp = Hp - 24;
           P64[Sp + 8] = $fShowFoo2_closure;
           P64[Sp + 16] = _c3HG::P64;
           Sp = Sp + 8;
           call ++_entry() args: 24, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:36:31.37392 UTC

[section "data" {
     $fShowFoo_$cshowsPrec_closure:
         const $fShowFoo_$cshowsPrec_info;
         const 0;
 },
 $fShowFoo_$cshowsPrec_entry() //  []
         { info_tbl: [(c3V0,
                       label: $fShowFoo_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 32 updfr_space: Just 8
         }
     {offset
       c3V0:
           _s3EC::P64 = P64[(old + 32)];
           _s3ED::P64 = P64[(old + 24)];
           _s3EE::P64 = P64[(old + 16)];
           goto c3UV;
       c3UV:
           if ((old + 0) - <highSp> < SpLim) goto c3V4; else goto c3V5;
       c3V4:
           R1 = $fShowFoo_$cshowsPrec_closure;
           P64[(old + 32)] = _s3EC::P64;
           P64[(old + 24)] = _s3ED::P64;
           P64[(old + 16)] = _s3EE::P64;
           call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
       c3V5:
           goto c3UU;
       c3UU:
           I64[(young<c3UX> + 8)] = c3UX;
           R1 = _s3EC::P64;
           if (R1 & 7 != 0) goto c3UX; else goto c3UY;
       c3UY:
           call (I64[I64[R1]])(R1) returns to c3UX, args: 8, res: 8, upd: 8;
       c3UX:
           _s3EF::P64 = R1;
           _s3EG::I64 = I64[_s3EF::P64 + 7];
           I64[(young<c3V3> + 8)] = c3V3;
           R1 = _s3ED::P64;
           if (R1 & 7 != 0) goto c3V3; else goto c3V7;
       c3V7:
           call (I64[I64[R1]])(R1) returns to c3V3, args: 8, res: 8, upd: 8;
       c3V3:
           _s3EH::P64 = R1;
           _s3EI::P64 = P64[_s3EH::P64 + 7];
           I64[(old + 32)] = _s3EG::I64;
           P64[(old + 24)] = _s3EI::P64;
           P64[(old + 16)] = _s3EE::P64;
           call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.380987 UTC

{offset
  c3V0:
      _s3EC::P64 = P64[(old + 32)];
      _s3ED::P64 = P64[(old + 24)];
      _s3EE::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3V4; else goto c3V5;
  c3V4:
      R1 = $fShowFoo_$cshowsPrec_closure;
      P64[(old + 32)] = _s3EC::P64;
      P64[(old + 24)] = _s3ED::P64;
      P64[(old + 16)] = _s3EE::P64;
      call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
  c3V5:
      I64[(young<c3UX> + 8)] = c3UX;
      R1 = _s3EC::P64;
      if (R1 & 7 != 0) goto c3UX; else goto c3UY;
  c3UY:
      call (I64[I64[R1]])(R1) returns to c3UX, args: 8, res: 8, upd: 8;
  c3UX:
      _s3EF::P64 = R1;
      _s3EG::I64 = I64[_s3EF::P64 + 7];
      I64[(young<c3V3> + 8)] = c3V3;
      R1 = _s3ED::P64;
      if (R1 & 7 != 0) goto c3V3; else goto c3V7;
  c3V7:
      call (I64[I64[R1]])(R1) returns to c3V3, args: 8, res: 8, upd: 8;
  c3V3:
      _s3EH::P64 = R1;
      _s3EI::P64 = P64[_s3EH::P64 + 7];
      I64[(old + 32)] = _s3EG::I64;
      P64[(old + 24)] = _s3EI::P64;
      P64[(old + 16)] = _s3EE::P64;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-01 18:36:31.385911 UTC

{offset
  c3V0:
      _s3EC::P64 = P64[(old + 32)];
      _s3ED::P64 = P64[(old + 24)];
      _s3EE::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3V4; else goto c3V5;
  c3V4:
      R1 = $fShowFoo_$cshowsPrec_closure;
      P64[(old + 32)] = _s3EC::P64;
      P64[(old + 24)] = _s3ED::P64;
      P64[(old + 16)] = _s3EE::P64;
      call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
  c3V5:
      I64[(young<c3UX> + 8)] = c3UX;
      R1 = _s3EC::P64;
      if (R1 & 7 != 0) goto c3UX; else goto c3UY;
  c3UY:
      call (I64[I64[R1]])(R1) returns to c3UX, args: 8, res: 8, upd: 8;
  c3UX:
      _s3EF::P64 = R1;
      _s3EG::I64 = I64[_s3EF::P64 + 7];
      I64[(young<c3V3> + 8)] = c3V3;
      R1 = _s3ED::P64;
      if (R1 & 7 != 0) goto c3V3; else goto c3V7;
  c3V7:
      call (I64[I64[R1]])(R1) returns to c3V3, args: 8, res: 8, upd: 8;
  c3V3:
      _s3EH::P64 = R1;
      _s3EI::P64 = P64[_s3EH::P64 + 7];
      I64[(old + 32)] = _s3EG::I64;
      P64[(old + 24)] = _s3EI::P64;
      P64[(old + 16)] = _s3EE::P64;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-01 18:36:31.390396 UTC

$fShowFoo_$cshowsPrec_entry
[c3UX, c3V0, c3V3]
{offset
  c3V0:
      _s3EC::P64 = P64[(old + 32)];
      _s3ED::P64 = P64[(old + 24)];
      _s3EE::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3V4; else goto c3V5;
  c3V4:
      R1 = $fShowFoo_$cshowsPrec_closure;
      P64[(old + 32)] = _s3EC::P64;
      P64[(old + 24)] = _s3ED::P64;
      P64[(old + 16)] = _s3EE::P64;
      call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
  c3V5:
      I64[(young<c3UX> + 8)] = c3UX;
      R1 = _s3EC::P64;
      if (R1 & 7 != 0) goto c3UX; else goto c3UY;
  c3UY:
      call (I64[I64[R1]])(R1) returns to c3UX, args: 8, res: 8, upd: 8;
  c3UX:
      _s3EF::P64 = R1;
      _s3EG::I64 = I64[_s3EF::P64 + 7];
      I64[(young<c3V3> + 8)] = c3V3;
      R1 = _s3ED::P64;
      if (R1 & 7 != 0) goto c3V3; else goto c3V7;
  c3V7:
      call (I64[I64[R1]])(R1) returns to c3V3, args: 8, res: 8, upd: 8;
  c3V3:
      _s3EH::P64 = R1;
      _s3EI::P64 = P64[_s3EH::P64 + 7];
      I64[(old + 32)] = _s3EG::I64;
      P64[(old + 24)] = _s3EI::P64;
      P64[(old + 16)] = _s3EE::P64;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-01 18:36:31.396083 UTC

{offset
  c3V0:
      _s3EC::P64 = P64[Sp];
      _s3ED::P64 = P64[Sp + 8];
      _s3EE::P64 = P64[Sp + 16];
      goto c3V5;
  c3V5:
      I64[Sp] = c3UX;
      R1 = _s3EC::P64;
      if (R1 & 7 != 0) goto c3UX; else goto c3UY;
  c3UY:
      call (I64[I64[R1]])(R1) returns to c3UX, args: 8, res: 8, upd: 8;
  c3UX:
      _s3ED::P64 = P64[Sp + 8];
      _s3EE::P64 = P64[Sp + 16];
      _s3EF::P64 = R1;
      _s3EG::I64 = I64[_s3EF::P64 + 7];
      I64[Sp] = c3V3;
      R1 = _s3ED::P64;
      I64[Sp + 8] = _s3EG::I64;
      if (R1 & 7 != 0) goto c3V3; else goto c3V7;
  c3V7:
      call (I64[I64[R1]])(R1) returns to c3V3, args: 8, res: 8, upd: 8;
  c3V3:
      _s3EE::P64 = P64[Sp + 16];
      _s3EG::I64 = I64[Sp + 8];
      _s3EH::P64 = R1;
      _s3EI::P64 = P64[_s3EH::P64 + 7];
      I64[Sp] = _s3EG::I64;
      P64[Sp + 8] = _s3EI::P64;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-01 18:36:31.400808 UTC

{offset
  c3V0:
      goto c3V5;
  c3V5:
      _s3EC::P64 = P64[Sp];
      I64[Sp] = c3UX;
      R1 = _s3EC::P64;
      if (R1 & 7 != 0) goto c3UX; else goto c3UY;
  c3UY:
      call (I64[I64[R1]])(R1) returns to c3UX, args: 8, res: 8, upd: 8;
  c3UX:
      I64[Sp] = c3V3;
      _s3EG::I64 = I64[R1 + 7];
      R1 = P64[Sp + 8];
      I64[Sp + 8] = _s3EG::I64;
      if (R1 & 7 != 0) goto c3V3; else goto c3V7;
  c3V7:
      call (I64[I64[R1]])(R1) returns to c3V3, args: 8, res: 8, upd: 8;
  c3V3:
      I64[Sp] = I64[Sp + 8];
      P64[Sp + 8] = P64[R1 + 7];
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-01 18:36:31.403759 UTC

[(c3UX, {$w$cshowsPrec_closure}), (c3UY, {$w$cshowsPrec_closure}),
 (c3V0, {$w$cshowsPrec_closure}), (c3V3, {$w$cshowsPrec_closure}),
 (c3V5, {$w$cshowsPrec_closure}), (c3V7, {$w$cshowsPrec_closure})]


==================== procpoint map ====================
2016-08-01 18:36:31.405117 UTC

[(c3UX, <procpt>), (c3UY, reached by c3V0), (c3V0, <procpt>),
 (c3V3, <procpt>), (c3V5, reached by c3V0), (c3V7, reached by c3UX)]


==================== Post splitting ====================
2016-08-01 18:36:31.406302 UTC

$fShowFoo_$cshowsPrec_entry() //  []
        { info_tbl: [(c3V0,
                      label: $fShowFoo_$cshowsPrec_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3V0:
          goto c3V5;
      c3V5:
          _s3EC::P64 = P64[Sp];
          I64[Sp] = block_c3UX_info;
          R1 = _s3EC::P64;
          if (R1 & 7 != 0) goto u3Vd; else goto c3UY;
      u3Vd:
          call block_c3UX_entry(R1) args: 0, res: 0, upd: 0;
      c3UY:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-01 18:36:31.408802 UTC

block_c3UX_entry() //  [R1]
        { info_tbl: [(c3UX,
                      label: block_c3UX_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3UX:
          I64[Sp] = block_c3V3_info;
          _s3EG::I64 = I64[R1 + 7];
          R1 = P64[Sp + 8];
          I64[Sp + 8] = _s3EG::I64;
          if (R1 & 7 != 0) goto u3Vc; else goto c3V7;
      u3Vc:
          call block_c3V3_entry(R1) args: 0, res: 0, upd: 0;
      c3V7:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-01 18:36:31.411187 UTC

block_c3V3_entry() //  [R1]
        { info_tbl: [(c3V3,
                      label: block_c3V3_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3V3:
          I64[Sp] = I64[Sp + 8];
          P64[Sp + 8] = P64[R1 + 7];
          call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:31.413752 UTC

$fShowFoo_$cshowsPrec_entry() //  []
        { info_tbl: [(c3V0,
                      label: $fShowFoo_$cshowsPrec_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3V0:
          goto c3V5;
      c3V5:
          _s3EC::P64 = P64[Sp];
          I64[Sp] = block_c3UX_info;
          R1 = _s3EC::P64;
          if (R1 & 7 != 0) goto u3Vd; else goto c3UY;
      u3Vd:
          call block_c3UX_entry(R1) args: 0, res: 0, upd: 0;
      c3UY:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:31.415971 UTC

block_c3UX_entry() //  [R1]
        { info_tbl: [(c3UX,
                      label: block_c3UX_info
                      rep:StackRep [False, False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3UX:
          I64[Sp] = block_c3V3_info;
          _s3EG::I64 = I64[R1 + 7];
          R1 = P64[Sp + 8];
          I64[Sp + 8] = _s3EG::I64;
          if (R1 & 7 != 0) goto u3Vc; else goto c3V7;
      u3Vc:
          call block_c3V3_entry(R1) args: 0, res: 0, upd: 0;
      c3V7:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:31.418279 UTC

block_c3V3_entry() //  [R1]
        { info_tbl: [(c3V3,
                      label: block_c3V3_info
                      rep:StackRep [True, False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3V3:
          I64[Sp] = I64[Sp + 8];
          P64[Sp + 8] = P64[R1 + 7];
          call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.419913 UTC

$fShowFoo_$cshowsPrec_entry() //  []
        { info_tbl: [(c3V0,
                      label: $fShowFoo_$cshowsPrec_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3V0:
          _s3EC::P64 = P64[Sp];
          I64[Sp] = block_c3UX_info;
          R1 = _s3EC::P64;
          if (R1 & 7 != 0) goto u3Vd; else goto c3UY;
      u3Vd:
          call block_c3UX_entry(R1) args: 0, res: 0, upd: 0;
      c3UY:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.422175 UTC

block_c3UX_entry() //  [R1]
        { info_tbl: [(c3UX,
                      label: block_c3UX_info
                      rep:StackRep [False, False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3UX:
          I64[Sp] = block_c3V3_info;
          _s3EG::I64 = I64[R1 + 7];
          R1 = P64[Sp + 8];
          I64[Sp + 8] = _s3EG::I64;
          if (R1 & 7 != 0) goto u3Vc; else goto c3V7;
      u3Vc:
          call block_c3V3_entry(R1) args: 0, res: 0, upd: 0;
      c3V7:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.424544 UTC

block_c3V3_entry() //  [R1]
        { info_tbl: [(c3V3,
                      label: block_c3V3_info
                      rep:StackRep [True, False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3V3:
          I64[Sp] = I64[Sp + 8];
          P64[Sp + 8] = P64[R1 + 7];
          call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-01 18:36:31.426189 UTC

[section "data" {
     $fShowFoo_$cshowsPrec_closure:
         const $fShowFoo_$cshowsPrec_info;
         const 0;
 },
 $fShowFoo_$cshowsPrec_entry() //  []
         { info_tbl: [(c3V0,
                       label: $fShowFoo_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3V0:
           _s3EC::P64 = P64[Sp];
           I64[Sp] = block_c3UX_info;
           R1 = _s3EC::P64;
           if (R1 & 7 != 0) goto u3Vd; else goto c3UY;
       u3Vd:
           call block_c3UX_entry(R1) args: 0, res: 0, upd: 0;
       c3UY:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3UX_entry() //  [R1]
         { info_tbl: [(c3UX,
                       label: block_c3UX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3UX:
           I64[Sp] = block_c3V3_info;
           _s3EG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s3EG::I64;
           if (R1 & 7 != 0) goto u3Vc; else goto c3V7;
       u3Vc:
           call block_c3V3_entry(R1) args: 0, res: 0, upd: 0;
       c3V7:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3V3_entry() //  [R1]
         { info_tbl: [(c3V3,
                       label: block_c3V3_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3V3:
           I64[Sp] = I64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 7];
           call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-01 18:36:31.431836 UTC

[section "data" {
     $fShowFoo_$cshowsPrec_closure:
         const $fShowFoo_$cshowsPrec_info;
         const 0;
 },
 $fShowFoo_$cshowsPrec_entry() //  []
         { info_tbl: [(c3V0,
                       label: $fShowFoo_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3V0:
           _s3EC::P64 = P64[Sp];
           I64[Sp] = block_c3UX_info;
           R1 = _s3EC::P64;
           if (R1 & 7 != 0) goto u3Vd; else goto c3UY;
       u3Vd:
           call block_c3UX_entry(R1) args: 0, res: 0, upd: 0;
       c3UY:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3UX_entry() //  [R1]
         { info_tbl: [(c3UX,
                       label: block_c3UX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3UX:
           I64[Sp] = block_c3V3_info;
           _s3EG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s3EG::I64;
           if (R1 & 7 != 0) goto u3Vc; else goto c3V7;
       u3Vc:
           call block_c3V3_entry(R1) args: 0, res: 0, upd: 0;
       c3V7:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3V3_entry() //  [R1]
         { info_tbl: [(c3V3,
                       label: block_c3V3_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3V3:
           I64[Sp] = I64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 7];
           call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:36:31.471639 UTC

[section "data" {
     $fShowFoo1_closure:
         const $fShowFoo1_info;
         const 0;
 },
 $fShowFoo1_entry() //  []
         { info_tbl: [(c3X1,
                       label: $fShowFoo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 24 updfr_space: Just 8
         }
     {offset
       c3X1:
           _s3EJ::P64 = P64[(old + 24)];
           _s3EK::P64 = P64[(old + 16)];
           goto c3WW;
       c3WW:
           if ((old + 0) - <highSp> < SpLim) goto c3X2; else goto c3X3;
       c3X2:
           R1 = $fShowFoo1_closure;
           P64[(old + 24)] = _s3EJ::P64;
           P64[(old + 16)] = _s3EK::P64;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
       c3X3:
           goto c3WV;
       c3WV:
           I64[(young<c3WY> + 8)] = c3WY;
           R1 = _s3EJ::P64;
           if (R1 & 7 != 0) goto c3WY; else goto c3WZ;
       c3WZ:
           call (I64[I64[R1]])(R1) returns to c3WY, args: 8, res: 8, upd: 8;
       c3WY:
           _s3EL::P64 = R1;
           _s3EM::P64 = P64[_s3EL::P64 + 7];
           I64[(old + 32)] = 0;
           P64[(old + 24)] = _s3EM::P64;
           P64[(old + 16)] = _s3EK::P64;
           call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.477049 UTC

{offset
  c3X1:
      _s3EJ::P64 = P64[(old + 24)];
      _s3EK::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3X2; else goto c3X3;
  c3X2:
      R1 = $fShowFoo1_closure;
      P64[(old + 24)] = _s3EJ::P64;
      P64[(old + 16)] = _s3EK::P64;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3X3:
      I64[(young<c3WY> + 8)] = c3WY;
      R1 = _s3EJ::P64;
      if (R1 & 7 != 0) goto c3WY; else goto c3WZ;
  c3WZ:
      call (I64[I64[R1]])(R1) returns to c3WY, args: 8, res: 8, upd: 8;
  c3WY:
      _s3EL::P64 = R1;
      _s3EM::P64 = P64[_s3EL::P64 + 7];
      I64[(old + 32)] = 0;
      P64[(old + 24)] = _s3EM::P64;
      P64[(old + 16)] = _s3EK::P64;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-01 18:36:31.480581 UTC

{offset
  c3X1:
      _s3EJ::P64 = P64[(old + 24)];
      _s3EK::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3X2; else goto c3X3;
  c3X2:
      R1 = $fShowFoo1_closure;
      P64[(old + 24)] = _s3EJ::P64;
      P64[(old + 16)] = _s3EK::P64;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3X3:
      I64[(young<c3WY> + 8)] = c3WY;
      R1 = _s3EJ::P64;
      if (R1 & 7 != 0) goto c3WY; else goto c3WZ;
  c3WZ:
      call (I64[I64[R1]])(R1) returns to c3WY, args: 8, res: 8, upd: 8;
  c3WY:
      _s3EL::P64 = R1;
      _s3EM::P64 = P64[_s3EL::P64 + 7];
      I64[(old + 32)] = 0;
      P64[(old + 24)] = _s3EM::P64;
      P64[(old + 16)] = _s3EK::P64;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-01 18:36:31.48487 UTC

$fShowFoo1_entry
[c3WY, c3X1]
{offset
  c3X1:
      _s3EJ::P64 = P64[(old + 24)];
      _s3EK::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3X2; else goto c3X3;
  c3X2:
      R1 = $fShowFoo1_closure;
      P64[(old + 24)] = _s3EJ::P64;
      P64[(old + 16)] = _s3EK::P64;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3X3:
      I64[(young<c3WY> + 8)] = c3WY;
      R1 = _s3EJ::P64;
      if (R1 & 7 != 0) goto c3WY; else goto c3WZ;
  c3WZ:
      call (I64[I64[R1]])(R1) returns to c3WY, args: 8, res: 8, upd: 8;
  c3WY:
      _s3EL::P64 = R1;
      _s3EM::P64 = P64[_s3EL::P64 + 7];
      I64[(old + 32)] = 0;
      P64[(old + 24)] = _s3EM::P64;
      P64[(old + 16)] = _s3EK::P64;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-01 18:36:31.488913 UTC

{offset
  c3X1:
      _s3EJ::P64 = P64[Sp];
      _s3EK::P64 = P64[Sp + 8];
      if ((Sp + 24) - 32 < SpLim) goto c3X2; else goto c3X3;
  c3X2:
      R1 = $fShowFoo1_closure;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3X3:
      I64[Sp] = c3WY;
      R1 = _s3EJ::P64;
      if (R1 & 7 != 0) goto c3WY; else goto c3WZ;
  c3WZ:
      call (I64[I64[R1]])(R1) returns to c3WY, args: 8, res: 8, upd: 8;
  c3WY:
      _s3EK::P64 = P64[Sp + 8];
      _s3EL::P64 = R1;
      _s3EM::P64 = P64[_s3EL::P64 + 7];
      I64[Sp - 8] = 0;
      P64[Sp] = _s3EM::P64;
      Sp = Sp - 8;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-01 18:36:31.49248 UTC

{offset
  c3X1:
      if ((Sp + -8) < SpLim) goto c3X2; else goto c3X3;
  c3X2:
      R1 = $fShowFoo1_closure;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3X3:
      _s3EJ::P64 = P64[Sp];
      I64[Sp] = c3WY;
      R1 = _s3EJ::P64;
      if (R1 & 7 != 0) goto c3WY; else goto c3WZ;
  c3WZ:
      call (I64[I64[R1]])(R1) returns to c3WY, args: 8, res: 8, upd: 8;
  c3WY:
      I64[Sp - 8] = 0;
      P64[Sp] = P64[R1 + 7];
      Sp = Sp - 8;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-01 18:36:31.494849 UTC

[(c3WY, {$w$cshowsPrec_closure}), (c3WZ, {$w$cshowsPrec_closure}),
 (c3X1, {$fShowFoo1_closure, $w$cshowsPrec_closure}),
 (c3X2, {$fShowFoo1_closure}), (c3X3, {$w$cshowsPrec_closure})]


==================== procpoint map ====================
2016-08-01 18:36:31.496108 UTC

[(c3WY, <procpt>), (c3WZ, reached by c3X1), (c3X1, <procpt>),
 (c3X2, reached by c3X1), (c3X3, reached by c3X1)]


==================== Post splitting ====================
2016-08-01 18:36:31.497205 UTC

$fShowFoo1_entry() //  []
        { info_tbl: [(c3X1,
                      label: $fShowFoo1_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3X1:
          if ((Sp + -8) < SpLim) goto c3X2; else goto c3X3;
      c3X2:
          R1 = $fShowFoo1_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
      c3X3:
          _s3EJ::P64 = P64[Sp];
          I64[Sp] = block_c3WY_info;
          R1 = _s3EJ::P64;
          if (R1 & 7 != 0) goto u3X7; else goto c3WZ;
      u3X7:
          call block_c3WY_entry(R1) args: 0, res: 0, upd: 0;
      c3WZ:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-01 18:36:31.500072 UTC

block_c3WY_entry() //  [R1]
        { info_tbl: [(c3WY,
                      label: block_c3WY_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3WY:
          I64[Sp - 8] = 0;
          P64[Sp] = P64[R1 + 7];
          Sp = Sp - 8;
          call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:31.501773 UTC

$fShowFoo1_entry() //  []
        { info_tbl: [(c3X1,
                      label: $fShowFoo1_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3X1:
          if ((Sp + -8) < SpLim) goto c3X2; else goto c3X3;
      c3X2:
          R1 = $fShowFoo1_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
      c3X3:
          _s3EJ::P64 = P64[Sp];
          I64[Sp] = block_c3WY_info;
          R1 = _s3EJ::P64;
          if (R1 & 7 != 0) goto u3X7; else goto c3WZ;
      u3X7:
          call block_c3WY_entry(R1) args: 0, res: 0, upd: 0;
      c3WZ:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:31.504386 UTC

block_c3WY_entry() //  [R1]
        { info_tbl: [(c3WY,
                      label: block_c3WY_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3WY:
          I64[Sp - 8] = 0;
          P64[Sp] = P64[R1 + 7];
          Sp = Sp - 8;
          call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.506023 UTC

$fShowFoo1_entry() //  []
        { info_tbl: [(c3X1,
                      label: $fShowFoo1_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3X1:
          if ((Sp + -8) < SpLim) goto c3X2; else goto c3X3;
      c3X2:
          R1 = $fShowFoo1_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
      c3X3:
          _s3EJ::P64 = P64[Sp];
          I64[Sp] = block_c3WY_info;
          R1 = _s3EJ::P64;
          if (R1 & 7 != 0) goto u3X7; else goto c3WZ;
      u3X7:
          call block_c3WY_entry(R1) args: 0, res: 0, upd: 0;
      c3WZ:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.508711 UTC

block_c3WY_entry() //  [R1]
        { info_tbl: [(c3WY,
                      label: block_c3WY_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3WY:
          I64[Sp - 8] = 0;
          P64[Sp] = P64[R1 + 7];
          Sp = Sp - 8;
          call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-01 18:36:31.510376 UTC

[section "data" {
     $fShowFoo1_closure:
         const $fShowFoo1_info;
         const 0;
 },
 $fShowFoo1_entry() //  []
         { info_tbl: [(c3X1,
                       label: $fShowFoo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3X1:
           if ((Sp + -8) < SpLim) goto c3X2; else goto c3X3;
       c3X2:
           R1 = $fShowFoo1_closure;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
       c3X3:
           _s3EJ::P64 = P64[Sp];
           I64[Sp] = block_c3WY_info;
           R1 = _s3EJ::P64;
           if (R1 & 7 != 0) goto u3X7; else goto c3WZ;
       u3X7:
           call block_c3WY_entry(R1) args: 0, res: 0, upd: 0;
       c3WZ:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3WY_entry() //  [R1]
         { info_tbl: [(c3WY,
                       label: block_c3WY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3WY:
           I64[Sp - 8] = 0;
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 8;
           call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-01 18:36:31.514686 UTC

[section "data" {
     $fShowFoo1_closure:
         const $fShowFoo1_info;
         const 0;
 },
 $fShowFoo1_entry() //  []
         { info_tbl: [(c3X1,
                       label: $fShowFoo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3X1:
           if ((Sp + -8) < SpLim) goto c3X2; else goto c3X3;
       c3X2:
           R1 = $fShowFoo1_closure;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
       c3X3:
           _s3EJ::P64 = P64[Sp];
           I64[Sp] = block_c3WY_info;
           R1 = _s3EJ::P64;
           if (R1 & 7 != 0) goto u3X7; else goto c3WZ;
       u3X7:
           call block_c3WY_entry(R1) args: 0, res: 0, upd: 0;
       c3WZ:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3WY_entry() //  [R1]
         { info_tbl: [(c3WY,
                       label: block_c3WY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3WY:
           I64[Sp - 8] = 0;
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 8;
           call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:36:31.544447 UTC

[section "data" {
     $fShowFoo_$cshowList_closure:
         const $fShowFoo_$cshowList_info;
         const 0;
 },
 $fShowFoo_$cshowList_entry() //  []
         { info_tbl: [(c3Ys,
                       label: $fShowFoo_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 24 updfr_space: Just 8
         }
     {offset
       c3Ys:
           _B2::P64 = P64[(old + 24)];
           _B1::P64 = P64[(old + 16)];
           goto c3Yq;
       c3Yq:
           if ((old + 0) - <highSp> < SpLim) goto c3Yt; else goto c3Yu;
       c3Yt:
           R1 = $fShowFoo_$cshowList_closure;
           P64[(old + 24)] = _B2::P64;
           P64[(old + 16)] = _B1::P64;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
       c3Yu:
           goto c3Yp;
       c3Yp:
           P64[(old + 32)] = $fShowFoo1_closure+2;
           P64[(old + 24)] = _B2::P64;
           P64[(old + 16)] = _B1::P64;
           call showList___entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.548572 UTC

{offset
  c3Ys:
      _B2::P64 = P64[(old + 24)];
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3Yt; else goto c3Yu;
  c3Yt:
      R1 = $fShowFoo_$cshowList_closure;
      P64[(old + 24)] = _B2::P64;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3Yu:
      P64[(old + 32)] = $fShowFoo1_closure+2;
      P64[(old + 24)] = _B2::P64;
      P64[(old + 16)] = _B1::P64;
      call showList___entry() args: 32, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-01 18:36:31.551092 UTC

{offset
  c3Ys:
      _B2::P64 = P64[(old + 24)];
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3Yt; else goto c3Yu;
  c3Yt:
      R1 = $fShowFoo_$cshowList_closure;
      P64[(old + 24)] = _B2::P64;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3Yu:
      P64[(old + 32)] = $fShowFoo1_closure+2;
      P64[(old + 24)] = _B2::P64;
      P64[(old + 16)] = _B1::P64;
      call showList___entry() args: 32, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-01 18:36:31.554399 UTC

$fShowFoo_$cshowList_entry
[c3Ys]
{offset
  c3Ys:
      _B2::P64 = P64[(old + 24)];
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3Yt; else goto c3Yu;
  c3Yt:
      R1 = $fShowFoo_$cshowList_closure;
      P64[(old + 24)] = _B2::P64;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3Yu:
      P64[(old + 32)] = $fShowFoo1_closure+2;
      P64[(old + 24)] = _B2::P64;
      P64[(old + 16)] = _B1::P64;
      call showList___entry() args: 32, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-01 18:36:31.557246 UTC

{offset
  c3Ys:
      _B2::P64 = P64[Sp];
      _B1::P64 = P64[Sp + 8];
      if ((Sp + 24) - 32 < SpLim) goto c3Yt; else goto c3Yu;
  c3Yt:
      R1 = $fShowFoo_$cshowList_closure;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3Yu:
      P64[Sp - 8] = $fShowFoo1_closure+2;
      Sp = Sp - 8;
      call showList___entry() args: 32, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-01 18:36:31.559296 UTC

{offset
  c3Ys:
      if ((Sp + -8) < SpLim) goto c3Yt; else goto c3Yu;
  c3Yt:
      R1 = $fShowFoo_$cshowList_closure;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3Yu:
      P64[Sp - 8] = $fShowFoo1_closure+2;
      Sp = Sp - 8;
      call showList___entry() args: 32, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-01 18:36:31.560789 UTC

[(c3Ys, {$fShowFoo_$cshowList_closure, $fShowFoo1_closure}),
 (c3Yt, {$fShowFoo_$cshowList_closure}),
 (c3Yu, {$fShowFoo1_closure})]


==================== procpoint map ====================
2016-08-01 18:36:31.561877 UTC

[(c3Ys, <procpt>), (c3Yt, reached by c3Ys),
 (c3Yu, reached by c3Ys)]


==================== Post splitting ====================
2016-08-01 18:36:31.562783 UTC

$fShowFoo_$cshowList_entry() //  []
        { info_tbl: [(c3Ys,
                      label: $fShowFoo_$cshowList_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Ys:
          if ((Sp + -8) < SpLim) goto c3Yt; else goto c3Yu;
      c3Yt:
          R1 = $fShowFoo_$cshowList_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
      c3Yu:
          P64[Sp - 8] = $fShowFoo1_closure+2;
          Sp = Sp - 8;
          call showList___entry() args: 32, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:31.564974 UTC

$fShowFoo_$cshowList_entry() //  []
        { info_tbl: [(c3Ys,
                      label: $fShowFoo_$cshowList_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Ys:
          if ((Sp + -8) < SpLim) goto c3Yt; else goto c3Yu;
      c3Yt:
          R1 = $fShowFoo_$cshowList_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
      c3Yu:
          P64[Sp - 8] = $fShowFoo1_closure+2;
          Sp = Sp - 8;
          call showList___entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.567021 UTC

$fShowFoo_$cshowList_entry() //  []
        { info_tbl: [(c3Ys,
                      label: $fShowFoo_$cshowList_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Ys:
          if ((Sp + -8) < SpLim) goto c3Yt; else goto c3Yu;
      c3Yt:
          R1 = $fShowFoo_$cshowList_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
      c3Yu:
          P64[Sp - 8] = $fShowFoo1_closure+2;
          Sp = Sp - 8;
          call showList___entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-01 18:36:31.569153 UTC

[section "data" {
     $fShowFoo_$cshowList_closure:
         const $fShowFoo_$cshowList_info;
         const 0;
 },
 $fShowFoo_$cshowList_entry() //  []
         { info_tbl: [(c3Ys,
                       label: $fShowFoo_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Ys:
           if ((Sp + -8) < SpLim) goto c3Yt; else goto c3Yu;
       c3Yt:
           R1 = $fShowFoo_$cshowList_closure;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
       c3Yu:
           P64[Sp - 8] = $fShowFoo1_closure+2;
           Sp = Sp - 8;
           call showList___entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-01 18:36:31.581634 UTC

[section "data" {
     $fShowFoo_$cshowList_closure:
         const $fShowFoo_$cshowList_info;
         const 0;
 },
 $fShowFoo_$cshowList_entry() //  []
         { info_tbl: [(c3Ys,
                       label: $fShowFoo_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Ys:
           if ((Sp + -8) < SpLim) goto c3Yt; else goto c3Yu;
       c3Yt:
           R1 = $fShowFoo_$cshowList_closure;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
       c3Yu:
           P64[Sp - 8] = $fShowFoo1_closure+2;
           Sp = Sp - 8;
           call showList___entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:36:31.597342 UTC

[section "data" {
     $fShowFoo_$cshow_closure:
         const $fShowFoo_$cshow_info;
         const 0;
 },
 $fShowFoo_$cshow_entry() //  []
         { info_tbl: [(c3Zc,
                       label: $fShowFoo_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 16 updfr_space: Just 8
         }
     {offset
       c3Zc:
           _s3EN::P64 = P64[(old + 16)];
           goto c3Z7;
       c3Z7:
           if ((old + 0) - <highSp> < SpLim) goto c3Zd; else goto c3Ze;
       c3Zd:
           R1 = $fShowFoo_$cshow_closure;
           P64[(old + 16)] = _s3EN::P64;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c3Ze:
           goto c3Z6;
       c3Z6:
           I64[(young<c3Z9> + 8)] = c3Z9;
           R1 = _s3EN::P64;
           if (R1 & 7 != 0) goto c3Z9; else goto c3Za;
       c3Za:
           call (I64[I64[R1]])(R1) returns to c3Z9, args: 8, res: 8, upd: 8;
       c3Z9:
           _s3EO::P64 = R1;
           _s3EP::P64 = P64[_s3EO::P64 + 7];
           I64[(old + 32)] = 0;
           P64[(old + 24)] = _s3EP::P64;
           P64[(old + 16)] = []_closure+1;
           call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.602473 UTC

{offset
  c3Zc:
      _s3EN::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3Zd; else goto c3Ze;
  c3Zd:
      R1 = $fShowFoo_$cshow_closure;
      P64[(old + 16)] = _s3EN::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c3Ze:
      I64[(young<c3Z9> + 8)] = c3Z9;
      R1 = _s3EN::P64;
      if (R1 & 7 != 0) goto c3Z9; else goto c3Za;
  c3Za:
      call (I64[I64[R1]])(R1) returns to c3Z9, args: 8, res: 8, upd: 8;
  c3Z9:
      _s3EO::P64 = R1;
      _s3EP::P64 = P64[_s3EO::P64 + 7];
      I64[(old + 32)] = 0;
      P64[(old + 24)] = _s3EP::P64;
      P64[(old + 16)] = []_closure+1;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-01 18:36:31.605706 UTC

{offset
  c3Zc:
      _s3EN::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3Zd; else goto c3Ze;
  c3Zd:
      R1 = $fShowFoo_$cshow_closure;
      P64[(old + 16)] = _s3EN::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c3Ze:
      I64[(young<c3Z9> + 8)] = c3Z9;
      R1 = _s3EN::P64;
      if (R1 & 7 != 0) goto c3Z9; else goto c3Za;
  c3Za:
      call (I64[I64[R1]])(R1) returns to c3Z9, args: 8, res: 8, upd: 8;
  c3Z9:
      _s3EO::P64 = R1;
      _s3EP::P64 = P64[_s3EO::P64 + 7];
      I64[(old + 32)] = 0;
      P64[(old + 24)] = _s3EP::P64;
      P64[(old + 16)] = []_closure+1;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-01 18:36:31.60867 UTC

$fShowFoo_$cshow_entry
[c3Z9, c3Zc]
{offset
  c3Zc:
      _s3EN::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3Zd; else goto c3Ze;
  c3Zd:
      R1 = $fShowFoo_$cshow_closure;
      P64[(old + 16)] = _s3EN::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c3Ze:
      I64[(young<c3Z9> + 8)] = c3Z9;
      R1 = _s3EN::P64;
      if (R1 & 7 != 0) goto c3Z9; else goto c3Za;
  c3Za:
      call (I64[I64[R1]])(R1) returns to c3Z9, args: 8, res: 8, upd: 8;
  c3Z9:
      _s3EO::P64 = R1;
      _s3EP::P64 = P64[_s3EO::P64 + 7];
      I64[(old + 32)] = 0;
      P64[(old + 24)] = _s3EP::P64;
      P64[(old + 16)] = []_closure+1;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-01 18:36:31.612468 UTC

{offset
  c3Zc:
      _s3EN::P64 = P64[Sp];
      if ((Sp + 16) - 32 < SpLim) goto c3Zd; else goto c3Ze;
  c3Zd:
      R1 = $fShowFoo_$cshow_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c3Ze:
      I64[Sp] = c3Z9;
      R1 = _s3EN::P64;
      if (R1 & 7 != 0) goto c3Z9; else goto c3Za;
  c3Za:
      call (I64[I64[R1]])(R1) returns to c3Z9, args: 8, res: 8, upd: 8;
  c3Z9:
      _s3EO::P64 = R1;
      _s3EP::P64 = P64[_s3EO::P64 + 7];
      I64[Sp - 16] = 0;
      P64[Sp - 8] = _s3EP::P64;
      P64[Sp] = []_closure+1;
      Sp = Sp - 16;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-01 18:36:31.615778 UTC

{offset
  c3Zc:
      if ((Sp + -16) < SpLim) goto c3Zd; else goto c3Ze;
  c3Zd:
      R1 = $fShowFoo_$cshow_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c3Ze:
      _s3EN::P64 = P64[Sp];
      I64[Sp] = c3Z9;
      R1 = _s3EN::P64;
      if (R1 & 7 != 0) goto c3Z9; else goto c3Za;
  c3Za:
      call (I64[I64[R1]])(R1) returns to c3Z9, args: 8, res: 8, upd: 8;
  c3Z9:
      I64[Sp - 16] = 0;
      P64[Sp - 8] = P64[R1 + 7];
      P64[Sp] = []_closure+1;
      Sp = Sp - 16;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-01 18:36:31.618284 UTC

[(c3Z9, {$w$cshowsPrec_closure}), (c3Za, {$w$cshowsPrec_closure}),
 (c3Zc, {$w$cshowsPrec_closure, $fShowFoo_$cshow_closure}),
 (c3Zd, {$fShowFoo_$cshow_closure}),
 (c3Ze, {$w$cshowsPrec_closure})]


==================== procpoint map ====================
2016-08-01 18:36:31.619569 UTC

[(c3Z9, <procpt>), (c3Za, reached by c3Zc), (c3Zc, <procpt>),
 (c3Zd, reached by c3Zc), (c3Ze, reached by c3Zc)]


==================== Post splitting ====================
2016-08-01 18:36:31.62066 UTC

$fShowFoo_$cshow_entry() //  []
        { info_tbl: [(c3Zc,
                      label: $fShowFoo_$cshow_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Zc:
          if ((Sp + -16) < SpLim) goto c3Zd; else goto c3Ze;
      c3Zd:
          R1 = $fShowFoo_$cshow_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c3Ze:
          _s3EN::P64 = P64[Sp];
          I64[Sp] = block_c3Z9_info;
          R1 = _s3EN::P64;
          if (R1 & 7 != 0) goto u3Zi; else goto c3Za;
      u3Zi:
          call block_c3Z9_entry(R1) args: 0, res: 0, upd: 0;
      c3Za:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-01 18:36:31.624515 UTC

block_c3Z9_entry() //  [R1]
        { info_tbl: [(c3Z9,
                      label: block_c3Z9_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Z9:
          I64[Sp - 16] = 0;
          P64[Sp - 8] = P64[R1 + 7];
          P64[Sp] = []_closure+1;
          Sp = Sp - 16;
          call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:31.626333 UTC

$fShowFoo_$cshow_entry() //  []
        { info_tbl: [(c3Zc,
                      label: $fShowFoo_$cshow_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Zc:
          if ((Sp + -16) < SpLim) goto c3Zd; else goto c3Ze;
      c3Zd:
          R1 = $fShowFoo_$cshow_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c3Ze:
          _s3EN::P64 = P64[Sp];
          I64[Sp] = block_c3Z9_info;
          R1 = _s3EN::P64;
          if (R1 & 7 != 0) goto u3Zi; else goto c3Za;
      u3Zi:
          call block_c3Z9_entry(R1) args: 0, res: 0, upd: 0;
      c3Za:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:31.628936 UTC

block_c3Z9_entry() //  [R1]
        { info_tbl: [(c3Z9,
                      label: block_c3Z9_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Z9:
          I64[Sp - 16] = 0;
          P64[Sp - 8] = P64[R1 + 7];
          P64[Sp] = []_closure+1;
          Sp = Sp - 16;
          call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.630697 UTC

$fShowFoo_$cshow_entry() //  []
        { info_tbl: [(c3Zc,
                      label: $fShowFoo_$cshow_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Zc:
          if ((Sp + -16) < SpLim) goto c3Zd; else goto c3Ze;
      c3Zd:
          R1 = $fShowFoo_$cshow_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c3Ze:
          _s3EN::P64 = P64[Sp];
          I64[Sp] = block_c3Z9_info;
          R1 = _s3EN::P64;
          if (R1 & 7 != 0) goto u3Zi; else goto c3Za;
      u3Zi:
          call block_c3Z9_entry(R1) args: 0, res: 0, upd: 0;
      c3Za:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.633502 UTC

block_c3Z9_entry() //  [R1]
        { info_tbl: [(c3Z9,
                      label: block_c3Z9_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Z9:
          I64[Sp - 16] = 0;
          P64[Sp - 8] = P64[R1 + 7];
          P64[Sp] = []_closure+1;
          Sp = Sp - 16;
          call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-01 18:36:31.635288 UTC

[section "data" {
     $fShowFoo_$cshow_closure:
         const $fShowFoo_$cshow_info;
         const 0;
 },
 $fShowFoo_$cshow_entry() //  []
         { info_tbl: [(c3Zc,
                       label: $fShowFoo_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Zc:
           if ((Sp + -16) < SpLim) goto c3Zd; else goto c3Ze;
       c3Zd:
           R1 = $fShowFoo_$cshow_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c3Ze:
           _s3EN::P64 = P64[Sp];
           I64[Sp] = block_c3Z9_info;
           R1 = _s3EN::P64;
           if (R1 & 7 != 0) goto u3Zi; else goto c3Za;
       u3Zi:
           call block_c3Z9_entry(R1) args: 0, res: 0, upd: 0;
       c3Za:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3Z9_entry() //  [R1]
         { info_tbl: [(c3Z9,
                       label: block_c3Z9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Z9:
           I64[Sp - 16] = 0;
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp] = []_closure+1;
           Sp = Sp - 16;
           call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-01 18:36:31.639631 UTC

[section "data" {
     $fShowFoo_$cshow_closure:
         const $fShowFoo_$cshow_info;
         const 0;
 },
 $fShowFoo_$cshow_entry() //  []
         { info_tbl: [(c3Zc,
                       label: $fShowFoo_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Zc:
           if ((Sp + -16) < SpLim) goto c3Zd; else goto c3Ze;
       c3Zd:
           R1 = $fShowFoo_$cshow_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c3Ze:
           _s3EN::P64 = P64[Sp];
           I64[Sp] = block_c3Z9_info;
           R1 = _s3EN::P64;
           if (R1 & 7 != 0) goto u3Zi; else goto c3Za;
       u3Zi:
           call block_c3Z9_entry(R1) args: 0, res: 0, upd: 0;
       c3Za:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3Z9_entry() //  [R1]
         { info_tbl: [(c3Z9,
                       label: block_c3Z9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Z9:
           I64[Sp - 16] = 0;
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp] = []_closure+1;
           Sp = Sp - 16;
           call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:36:31.678266 UTC

[section "data" {
     $fShowFoo_closure:
         const D:Show_static_info;
         const $fShowFoo_$cshowsPrec_closure+3;
         const $fShowFoo_$cshow_closure+1;
         const $fShowFoo_$cshowList_closure+2;
         const 0;
 }]


==================== Post CPS Cmm ====================
2016-08-01 18:36:31.679415 UTC

[section "data" {
     $fShowFoo_closure:
         const D:Show_static_info;
         const $fShowFoo_$cshowsPrec_closure+3;
         const $fShowFoo_$cshow_closure+1;
         const $fShowFoo_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2016-08-01 18:36:31.680483 UTC

[section "data" {
     $fShowFoo_closure:
         const D:Show_static_info;
         const $fShowFoo_$cshowsPrec_closure+3;
         const $fShowFoo_$cshow_closure+1;
         const $fShowFoo_$cshowList_closure+2;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:36:31.68417 UTC

[section "data" {
     mkfoo_closure:
         const mkfoo_info;
 },
 mkfoo_entry() //  []
         { info_tbl: [(c40M,
                       label: mkfoo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 16 updfr_space: Just 8
         }
     {offset
       c40M:
           _B1::P64 = P64[(old + 16)];
           goto c40J;
       c40J:
           if ((old + 0) - <highSp> < SpLim) goto c40N; else goto c40O;
       c40O:
           goto c40I;
       c40I:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c40Q; else goto c40P;
       c40Q:
           HpAlloc = 16;
           goto c40N;
       c40N:
           R1 = mkfoo_closure;
           P64[(old + 16)] = _B1::P64;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c40P:
           I64[Hp - 8] = Foo_con_info;
           P64[Hp] = _B1::P64;
           _c40L::P64 = Hp - 7;
           R1 = _c40L::P64;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.688591 UTC

{offset
  c40M:
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c40N; else goto c40O;
  c40O:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c40Q; else goto c40P;
  c40Q:
      HpAlloc = 16;
      goto c40N;
  c40N:
      R1 = mkfoo_closure;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c40P:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c40L::P64 = Hp - 7;
      R1 = _c40L::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-01 18:36:31.691415 UTC

{offset
  c40M:
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c40N; else goto c40O;
  c40O:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c40Q; else goto c40P;
  c40Q:
      HpAlloc = 16;
      goto c40N;
  c40N:
      R1 = mkfoo_closure;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c40P:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c40L::P64 = Hp - 7;
      R1 = _c40L::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-01 18:36:31.693895 UTC

mkfoo_entry
[c40M]
{offset
  c40M:
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c40N; else goto c40O;
  c40O:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c40Q; else goto c40P;
  c40Q:
      HpAlloc = 16;
      goto c40N;
  c40N:
      R1 = mkfoo_closure;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c40P:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c40L::P64 = Hp - 7;
      R1 = _c40L::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-01 18:36:31.697065 UTC

{offset
  c40M:
      _B1::P64 = P64[Sp];
      goto c40O;
  c40O:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c40Q; else goto c40P;
  c40Q:
      HpAlloc = 16;
      goto c40N;
  c40N:
      R1 = mkfoo_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c40P:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c40L::P64 = Hp - 7;
      R1 = _c40L::P64;
      Sp = Sp + 8;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-01 18:36:31.700779 UTC

{offset
  c40M:
      goto c40O;
  c40O:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c40Q; else goto c40P;
  c40Q:
      HpAlloc = 16;
      goto c40N;
  c40N:
      R1 = mkfoo_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c40P:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = P64[Sp];
      R1 = Hp - 7;
      Sp = Sp + 8;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-01 18:36:31.702843 UTC

[(c40M, {}), (c40N, {}), (c40O, {}), (c40P, {}), (c40Q, {})]


==================== procpoint map ====================
2016-08-01 18:36:31.703813 UTC

[(c40M, <procpt>), (c40N, reached by c40M),
 (c40O, reached by c40M), (c40P, reached by c40M),
 (c40Q, reached by c40M)]


==================== Post splitting ====================
2016-08-01 18:36:31.704905 UTC

mkfoo_entry() //  []
        { info_tbl: [(c40M,
                      label: mkfoo_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c40M:
          goto c40O;
      c40O:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c40Q; else goto c40P;
      c40Q:
          HpAlloc = 16;
          goto c40N;
      c40N:
          R1 = mkfoo_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c40P:
          I64[Hp - 8] = Foo_con_info;
          P64[Hp] = P64[Sp];
          R1 = Hp - 7;
          Sp = Sp + 8;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:31.707681 UTC

mkfoo_entry() //  []
        { info_tbl: [(c40M,
                      label: mkfoo_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c40M:
          goto c40O;
      c40O:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c40Q; else goto c40P;
      c40Q:
          HpAlloc = 16;
          goto c40N;
      c40N:
          R1 = mkfoo_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c40P:
          I64[Hp - 8] = Foo_con_info;
          P64[Hp] = P64[Sp];
          R1 = Hp - 7;
          Sp = Sp + 8;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.71022 UTC

mkfoo_entry() //  []
        { info_tbl: [(c40M,
                      label: mkfoo_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c40M:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c40Q; else goto c40P;
      c40Q:
          HpAlloc = 16;
          R1 = mkfoo_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c40P:
          I64[Hp - 8] = Foo_con_info;
          P64[Hp] = P64[Sp];
          R1 = Hp - 7;
          Sp = Sp + 8;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-01 18:36:31.722705 UTC

[section "data" {
     mkfoo_closure:
         const mkfoo_info;
 },
 mkfoo_entry() //  []
         { info_tbl: [(c40M,
                       label: mkfoo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c40M:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c40Q; else goto c40P;
       c40Q:
           HpAlloc = 16;
           R1 = mkfoo_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c40P:
           I64[Hp - 8] = Foo_con_info;
           P64[Hp] = P64[Sp];
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-01 18:36:31.725411 UTC

[section "data" {
     mkfoo_closure:
         const mkfoo_info;
 },
 mkfoo_entry() //  []
         { info_tbl: [(c40M,
                       label: mkfoo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c40M:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c40Q; else goto c40P;
       c40Q:
           HpAlloc = 16;
           R1 = mkfoo_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c40P:
           I64[Hp - 8] = Foo_con_info;
           P64[Hp] = P64[Sp];
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:36:31.747695 UTC

[section "data" {
     main2_closure:
         const I#_static_info;
         const 4;
 }]


==================== Post CPS Cmm ====================
2016-08-01 18:36:31.748622 UTC

[section "data" {
     main2_closure:
         const I#_static_info;
         const 4;
 }]


==================== Output Cmm ====================
2016-08-01 18:36:31.749469 UTC

[section "data" {
     main2_closure:
         const I#_static_info;
         const 4;
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:36:31.752041 UTC

[section "data" {
     main4_closure:
         const I#_static_info;
         const 3;
 }]


==================== Post CPS Cmm ====================
2016-08-01 18:36:31.75295 UTC

[section "data" {
     main4_closure:
         const I#_static_info;
         const 3;
 }]


==================== Output Cmm ====================
2016-08-01 18:36:31.753797 UTC

[section "data" {
     main4_closure:
         const I#_static_info;
         const 3;
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:36:31.756279 UTC

[section "data" {
     main3_closure:
         const Foo_static_info;
         const main4_closure+1;
         const 1;
 }]


==================== Post CPS Cmm ====================
2016-08-01 18:36:31.757243 UTC

[section "data" {
     main3_closure:
         const Foo_static_info;
         const main4_closure+1;
         const 1;
 }]


==================== Output Cmm ====================
2016-08-01 18:36:31.758163 UTC

[section "data" {
     main3_closure:
         const Foo_static_info;
         const main4_closure+1;
         const 1;
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:36:31.761936 UTC

[section "data" {
     main8_closure:
         const main8_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     c427_str:
         I8[] [104,105]
 },
 main8_entry() //  [R1]
         { info_tbl: [(c428,
                       label: main8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c428:
           _r3DY::P64 = R1;
           goto c422;
       c422:
           if ((old + 0) - <highSp> < SpLim) goto c429; else goto c42a;
       c429:
           R1 = _r3DY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c42a:
           (_c424::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3DY::P64);
           if (_c424::I64 == 0) goto c426; else goto c425;
       c426:
           call (I64[I64[_r3DY::P64]])() args: 8, res: 0, upd: 8;
       c425:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _c424::I64;
           I64[(old + 32)] = c427_str;
           call unpackCString#_entry() args: 32, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.766623 UTC

{offset
  c428:
      _r3DY::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c429; else goto c42a;
  c429:
      R1 = _r3DY::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c42a:
      (_c424::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3DY::P64);
      if (_c424::I64 == 0) goto c426; else goto c425;
  c426:
      call (I64[I64[_r3DY::P64]])() args: 8, res: 0, upd: 8;
  c425:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c424::I64;
      I64[(old + 32)] = c427_str;
      call unpackCString#_entry() args: 32, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2016-08-01 18:36:31.769409 UTC

{offset
  c428:
      _r3DY::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c429; else goto c42a;
  c429:
      R1 = _r3DY::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c42a:
      (_c424::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3DY::P64);
      if (_c424::I64 == 0) goto c426; else goto c425;
  c426:
      call (I64[I64[_r3DY::P64]])() args: 8, res: 0, upd: 8;
  c425:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c424::I64;
      I64[(old + 32)] = c427_str;
      call unpackCString#_entry() args: 32, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-01 18:36:31.772006 UTC

main8_entry
[c428]
{offset
  c428:
      _r3DY::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c429; else goto c42a;
  c429:
      R1 = _r3DY::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c42a:
      (_c424::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3DY::P64);
      if (_c424::I64 == 0) goto c426; else goto c425;
  c426:
      call (I64[I64[_r3DY::P64]])() args: 8, res: 0, upd: 8;
  c425:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c424::I64;
      I64[(old + 32)] = c427_str;
      call unpackCString#_entry() args: 32, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-01 18:36:31.775118 UTC

{offset
  c428:
      _r3DY::P64 = R1;
      if ((Sp + 8) - 32 < SpLim) goto c429; else goto c42a;
  c429:
      R1 = _r3DY::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c42a:
      (_c424::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3DY::P64);
      if (_c424::I64 == 0) goto c426; else goto c425;
  c426:
      call (I64[I64[_r3DY::P64]])() args: 8, res: 0, upd: 8;
  c425:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _c424::I64;
      I64[Sp - 24] = c427_str;
      Sp = Sp - 24;
      call unpackCString#_entry() args: 32, res: 0, upd: 24;
}


==================== Sink assignments ====================
2016-08-01 18:36:31.778227 UTC

{offset
  c428:
      if ((Sp + -24) < SpLim) goto c429; else goto c42a;
  c429:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c42a:
      (_c424::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
      if (_c424::I64 == 0) goto c426; else goto c425;
  c426:
      call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
  c425:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _c424::I64;
      I64[Sp - 24] = c427_str;
      Sp = Sp - 24;
      call unpackCString#_entry() args: 32, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-01 18:36:31.780649 UTC

[(c425, {}), (c426, {}), (c428, {}), (c429, {}), (c42a, {})]


==================== procpoint map ====================
2016-08-01 18:36:31.781694 UTC

[(c425, reached by c428), (c426, reached by c428),
 (c428, <procpt>), (c429, reached by c428), (c42a, reached by c428)]


==================== Post splitting ====================
2016-08-01 18:36:31.782754 UTC

main8_entry() //  [R1]
        { info_tbl: [(c428,
                      label: main8_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c428:
          if ((Sp + -24) < SpLim) goto c429; else goto c42a;
      c429:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c42a:
          (_c424::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
          if (_c424::I64 == 0) goto c426; else goto c425;
      c426:
          call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
      c425:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c424::I64;
          I64[Sp - 24] = c427_str;
          Sp = Sp - 24;
          call unpackCString#_entry() args: 32, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:31.785901 UTC

main8_entry() //  [R1]
        { info_tbl: [(c428,
                      label: main8_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c428:
          if ((Sp + -24) < SpLim) goto c429; else goto c42a;
      c429:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c42a:
          (_c424::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
          if (_c424::I64 == 0) goto c426; else goto c425;
      c426:
          call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
      c425:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c424::I64;
          I64[Sp - 24] = c427_str;
          Sp = Sp - 24;
          call unpackCString#_entry() args: 32, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.78886 UTC

main8_entry() //  [R1]
        { info_tbl: [(c428,
                      label: main8_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c428:
          if ((Sp + -24) < SpLim) goto c429; else goto c42a;
      c429:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c42a:
          (_c424::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
          if (_c424::I64 == 0) goto c426; else goto c425;
      c426:
          call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
      c425:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c424::I64;
          I64[Sp - 24] = c427_str;
          Sp = Sp - 24;
          call unpackCString#_entry() args: 32, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2016-08-01 18:36:31.791943 UTC

[section "data" {
     main8_closure:
         const main8_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     c427_str:
         I8[] [104,105]
 },
 main8_entry() //  [R1]
         { info_tbl: [(c428,
                       label: main8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c428:
           if ((Sp + -24) < SpLim) goto c429; else goto c42a;
       c429:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c42a:
           (_c424::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c424::I64 == 0) goto c426; else goto c425;
       c426:
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c425:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c424::I64;
           I64[Sp - 24] = c427_str;
           Sp = Sp - 24;
           call unpackCString#_entry() args: 32, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2016-08-01 18:36:31.79565 UTC

[section "data" {
     main8_closure:
         const main8_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     c427_str:
         I8[] [104,105]
 },
 main8_entry() //  [R1]
         { info_tbl: [(c428,
                       label: main8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c428:
           if ((Sp + -24) < SpLim) goto c429; else goto c42a;
       c429:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c42a:
           (_c424::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c424::I64 == 0) goto c426; else goto c425;
       c426:
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c425:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c424::I64;
           I64[Sp - 24] = c427_str;
           Sp = Sp - 24;
           call unpackCString#_entry() args: 32, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:36:31.821506 UTC

[section "data" {
     main7_closure:
         const :_static_info;
         const shows6_closure;
         const []_closure+1;
         const 1;
 }]


==================== Post CPS Cmm ====================
2016-08-01 18:36:31.822612 UTC

[section "data" {
     main7_closure:
         const :_static_info;
         const shows6_closure;
         const []_closure+1;
         const 1;
 }]


==================== Output Cmm ====================
2016-08-01 18:36:31.823589 UTC

[section "data" {
     main7_closure:
         const :_static_info;
         const shows6_closure;
         const []_closure+1;
         const 1;
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:36:31.827742 UTC

[section "data" {
     main6_closure:
         const main6_info;
         const 0;
         const 0;
         const 0;
 },
 main6_entry() //  [R1]
         { info_tbl: [(c43t,
                       label: main6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c43t:
           _r3DW::P64 = R1;
           goto c43o;
       c43o:
           if ((old + 0) - <highSp> < SpLim) goto c43u; else goto c43v;
       c43u:
           R1 = _r3DW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c43v:
           (_c43q::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3DW::P64);
           if (_c43q::I64 == 0) goto c43s; else goto c43r;
       c43s:
           call (I64[I64[_r3DW::P64]])() args: 8, res: 0, upd: 8;
       c43r:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _c43q::I64;
           P64[(old + 40)] = main8_closure;
           P64[(old + 32)] = main7_closure+2;
           call showLitString_entry() args: 40, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.832594 UTC

{offset
  c43t:
      _r3DW::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c43u; else goto c43v;
  c43u:
      R1 = _r3DW::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c43v:
      (_c43q::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3DW::P64);
      if (_c43q::I64 == 0) goto c43s; else goto c43r;
  c43s:
      call (I64[I64[_r3DW::P64]])() args: 8, res: 0, upd: 8;
  c43r:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c43q::I64;
      P64[(old + 40)] = main8_closure;
      P64[(old + 32)] = main7_closure+2;
      call showLitString_entry() args: 40, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2016-08-01 18:36:31.83554 UTC

{offset
  c43t:
      _r3DW::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c43u; else goto c43v;
  c43u:
      R1 = _r3DW::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c43v:
      (_c43q::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3DW::P64);
      if (_c43q::I64 == 0) goto c43s; else goto c43r;
  c43s:
      call (I64[I64[_r3DW::P64]])() args: 8, res: 0, upd: 8;
  c43r:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c43q::I64;
      P64[(old + 40)] = main8_closure;
      P64[(old + 32)] = main7_closure+2;
      call showLitString_entry() args: 40, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-01 18:36:31.838257 UTC

main6_entry
[c43t]
{offset
  c43t:
      _r3DW::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c43u; else goto c43v;
  c43u:
      R1 = _r3DW::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c43v:
      (_c43q::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3DW::P64);
      if (_c43q::I64 == 0) goto c43s; else goto c43r;
  c43s:
      call (I64[I64[_r3DW::P64]])() args: 8, res: 0, upd: 8;
  c43r:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c43q::I64;
      P64[(old + 40)] = main8_closure;
      P64[(old + 32)] = main7_closure+2;
      call showLitString_entry() args: 40, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-01 18:36:31.841587 UTC

{offset
  c43t:
      _r3DW::P64 = R1;
      if ((Sp + 8) - 40 < SpLim) goto c43u; else goto c43v;
  c43u:
      R1 = _r3DW::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c43v:
      (_c43q::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3DW::P64);
      if (_c43q::I64 == 0) goto c43s; else goto c43r;
  c43s:
      call (I64[I64[_r3DW::P64]])() args: 8, res: 0, upd: 8;
  c43r:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _c43q::I64;
      P64[Sp - 32] = main8_closure;
      P64[Sp - 24] = main7_closure+2;
      Sp = Sp - 32;
      call showLitString_entry() args: 40, res: 0, upd: 24;
}


==================== Sink assignments ====================
2016-08-01 18:36:31.844878 UTC

{offset
  c43t:
      if ((Sp + -32) < SpLim) goto c43u; else goto c43v;
  c43u:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c43v:
      (_c43q::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
      if (_c43q::I64 == 0) goto c43s; else goto c43r;
  c43s:
      call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
  c43r:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _c43q::I64;
      P64[Sp - 32] = main8_closure;
      P64[Sp - 24] = main7_closure+2;
      Sp = Sp - 32;
      call showLitString_entry() args: 40, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-01 18:36:31.847463 UTC

[(c43r, {showLitString_closure, main8_closure}), (c43s, {}),
 (c43t, {showLitString_closure, main8_closure}), (c43u, {}),
 (c43v, {showLitString_closure, main8_closure})]


==================== procpoint map ====================
2016-08-01 18:36:31.848725 UTC

[(c43r, reached by c43t), (c43s, reached by c43t),
 (c43t, <procpt>), (c43u, reached by c43t), (c43v, reached by c43t)]


==================== Post splitting ====================
2016-08-01 18:36:31.849797 UTC

main6_entry() //  [R1]
        { info_tbl: [(c43t,
                      label: main6_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c43t:
          if ((Sp + -32) < SpLim) goto c43u; else goto c43v;
      c43u:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c43v:
          (_c43q::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
          if (_c43q::I64 == 0) goto c43s; else goto c43r;
      c43s:
          call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
      c43r:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c43q::I64;
          P64[Sp - 32] = main8_closure;
          P64[Sp - 24] = main7_closure+2;
          Sp = Sp - 32;
          call showLitString_entry() args: 40, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:31.853214 UTC

main6_entry() //  [R1]
        { info_tbl: [(c43t,
                      label: main6_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c43t:
          if ((Sp + -32) < SpLim) goto c43u; else goto c43v;
      c43u:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c43v:
          (_c43q::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
          if (_c43q::I64 == 0) goto c43s; else goto c43r;
      c43s:
          call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
      c43r:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c43q::I64;
          P64[Sp - 32] = main8_closure;
          P64[Sp - 24] = main7_closure+2;
          Sp = Sp - 32;
          call showLitString_entry() args: 40, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.856353 UTC

main6_entry() //  [R1]
        { info_tbl: [(c43t,
                      label: main6_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c43t:
          if ((Sp + -32) < SpLim) goto c43u; else goto c43v;
      c43u:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c43v:
          (_c43q::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
          if (_c43q::I64 == 0) goto c43s; else goto c43r;
      c43s:
          call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
      c43r:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c43q::I64;
          P64[Sp - 32] = main8_closure;
          P64[Sp - 24] = main7_closure+2;
          Sp = Sp - 32;
          call showLitString_entry() args: 40, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2016-08-01 18:36:31.85956 UTC

[section "data" {
     main6_closure:
         const main6_info;
         const 0;
         const 0;
         const 0;
 },
 main6_entry() //  [R1]
         { info_tbl: [(c43t,
                       label: main6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43t:
           if ((Sp + -32) < SpLim) goto c43u; else goto c43v;
       c43u:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c43v:
           (_c43q::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c43q::I64 == 0) goto c43s; else goto c43r;
       c43s:
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c43r:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c43q::I64;
           P64[Sp - 32] = main8_closure;
           P64[Sp - 24] = main7_closure+2;
           Sp = Sp - 32;
           call showLitString_entry() args: 40, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2016-08-01 18:36:31.863476 UTC

[section "data" {
     main6_closure:
         const main6_info;
         const 0;
         const 0;
         const 0;
 },
 main6_entry() //  [R1]
         { info_tbl: [(c43t,
                       label: main6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43t:
           if ((Sp + -32) < SpLim) goto c43u; else goto c43v;
       c43u:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c43v:
           (_c43q::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c43q::I64 == 0) goto c43s; else goto c43r;
       c43s:
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c43r:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c43q::I64;
           P64[Sp - 32] = main8_closure;
           P64[Sp - 24] = main7_closure+2;
           Sp = Sp - 32;
           call showLitString_entry() args: 40, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:36:31.890444 UTC

[section "data" {
     main5_closure:
         const :_static_info;
         const shows6_closure;
         const main6_closure;
         const 0;
 }]


==================== Post CPS Cmm ====================
2016-08-01 18:36:31.891559 UTC

[section "data" {
     main5_closure:
         const :_static_info;
         const shows6_closure;
         const main6_closure;
         const 0;
 }]


==================== Output Cmm ====================
2016-08-01 18:36:31.892539 UTC

[section "data" {
     main5_closure:
         const :_static_info;
         const shows6_closure;
         const main6_closure;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:36:31.895518 UTC

[section "data" {
     main1_closure:
         const main1_info;
         const 0;
 },
 sat_s3F2_entry() //  [R1]
         { info_tbl: [(c45k,
                       label: sat_s3F2_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c45k:
           _s3F2::P64 = R1;
           goto c45e;
       c45e:
           if ((old + 0) - <highSp> < SpLim) goto c45l; else goto c45m;
       c45l:
           R1 = _s3F2::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c45m:
           goto c45d;
       c45d:
           _s3EW::P64 = P64[_s3F2::P64 + 7];
           _s3EY::P64 = P64[_s3F2::P64 + 15];
           P64[_s3EW::P64 + 8] = _s3EY::P64;
           _c45g::I64 = dirty_MUT_VAR;
           _c45h::I64 = BaseReg;
           _c45i::P64 = _s3EW::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] (_c45g::I64)(_c45h::I64, _c45i::P64);
           R1 = ()_closure+1;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s3F3_entry() //  [R1]
         { info_tbl: [(c45n,
                       label: sat_s3F3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c45n:
           _s3F3::P64 = R1;
           goto c455;
       c455:
           if ((old + 0) - <highSp> < SpLim) goto c45o; else goto c45p;
       c45o:
           R1 = _s3F3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45p:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _s3F3::P64;
           _s3EW::P64 = P64[_s3F3::P64 + 16];
           I64[(young<c457> + 8)] = c457;
           P64[(young<c457> + 16)] = main2_closure+1;
           call mkfoo_entry() returns to c457, args: 16, res: 8, upd: 24;
       c457:
           _s3EY::P64 = R1;
           Hp = Hp + 24;
           if (Hp > HpLim) goto c45s; else goto c45r;
       c45s:
           HpAlloc = 24;
           goto c45q;
       c45q:
           R1 = _s3EY::P64;
           call stg_gc_unpt_r1(R1) returns to c457, args: 8, res: 8, upd: 24;
       c45r:
           _s3EZ::P64 = P64[_s3EY::P64 + 7];
           I64[Hp - 16] = sat_s3F2_info;
           P64[Hp - 8] = _s3EW::P64;
           P64[Hp] = _s3EY::P64;
           _c45b::P64 = Hp - 15;
           R1 = _c45b::P64;
           call (I64[P64[(old + 24)]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3F4_entry() //  [R1]
         { info_tbl: [(c45t,
                       label: sat_s3F4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c45t:
           _s3F4::P64 = R1;
           goto c451;
       c451:
           if ((old + 0) - <highSp> < SpLim) goto c45u; else goto c45v;
       c45v:
           goto c450;
       c450:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c45x; else goto c45w;
       c45x:
           HpAlloc = 24;
           goto c45u;
       c45u:
           R1 = _s3F4::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c45w:
           _s3EW::P64 = P64[_s3F4::P64 + 7];
           I64[Hp - 16] = sat_s3F3_info;
           P64[Hp] = _s3EW::P64;
           _c453::P64 = Hp - 16;
           R1 = _c453::P64;
           P64[(old + 16)] = childHandler1_closure+2;
           call stg_catch#(R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_s3Fb_entry() //  [R1]
         { info_tbl: [(c45E,
                       label: sat_s3Fb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c45E:
           _s3Fb::P64 = R1;
           goto c45C;
       c45C:
           if ((old + 0) - <highSp> < SpLim) goto c45F; else goto c45G;
       c45F:
           R1 = _s3Fb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45G:
           _s3Fa::P64 = P64[_s3Fb::P64 + 16];
           P64[(old + 16)] = _s3Fa::P64;
           call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
     }
 },
 main1_entry() //  []
         { info_tbl: [(c45H,
                       label: main1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c45H:
           goto c44S;
       c44S:
           if ((old + 0) - <highSp> < SpLim) goto c45I; else goto c45J;
       c45I:
           R1 = main1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c45J:
           goto c44R;
       c44R:
           I64[(young<c44U> + 8)] = c44U;
           P64[(young<c44U> + 32)] = stdout_closure;
           P64[(young<c44U> + 24)] = main5_closure+2;
           P64[(young<c44U> + 16)] = True_closure+2;
           call hPutStr2_entry() returns to c44U, args: 32, res: 8, upd: 8;
       c44U:
           _s3ET::P64 = R1;
           I64[(young<c44W> + 8)] = c44W;
           R1 = main3_closure+1;
           call stg_newMutVar#(R1) returns to c44W, args: 8, res: 8, upd: 8;
       c44W:
           _s3EW::P64 = R1;
           Hp = Hp + 16;
           if (Hp > HpLim) goto c45N; else goto c45M;
       c45N:
           HpAlloc = 16;
           goto c45L;
       c45L:
           R1 = _s3EW::P64;
           call stg_gc_unpt_r1(R1) returns to c44W, args: 8, res: 8, upd: 8;
       c45M:
           I64[Hp - 8] = sat_s3F4_info;
           P64[Hp] = _s3EW::P64;
           _c44Y::P64 = Hp - 7;
           I64[(young<c45y> + 8)] = c45y;
           R1 = _c44Y::P64;
           call stg_fork#(R1) returns to c45y, args: 8, res: 8, upd: 8;
       c45y:
           _s3F7::P64 = R1;
           Hp = Hp + 24;
           if (Hp > HpLim) goto c45Q; else goto c45P;
       c45Q:
           HpAlloc = 24;
           goto c45O;
       c45O:
           R1 = _s3F7::P64;
           call stg_gc_unpt_r1(R1) returns to c45y, args: 8, res: 8, upd: 8;
       c45P:
           _s3Fa::P64 = P64[_s3EW::P64 + 8];
           _s3Fa::P64 = _s3Fa::P64;
           I64[Hp - 16] = sat_s3Fb_info;
           P64[Hp] = _s3Fa::P64;
           _c45A::P64 = Hp - 16;
           P64[(old + 32)] = stdout_closure;
           P64[(old + 24)] = _c45A::P64;
           P64[(old + 16)] = True_closure+2;
           call hPutStr2_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.919403 UTC

{offset
  c45k:
      _s3F2::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c45l; else goto c45m;
  c45l:
      R1 = _s3F2::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c45m:
      _s3EW::P64 = P64[_s3F2::P64 + 7];
      _s3EY::P64 = P64[_s3F2::P64 + 15];
      P64[_s3EW::P64 + 8] = _s3EY::P64;
      _c45g::I64 = dirty_MUT_VAR;
      _c45h::I64 = BaseReg;
      _c45i::P64 = _s3EW::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_c45g::I64)(_c45h::I64, _c45i::P64);
      R1 = ()_closure+1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-01 18:36:31.922435 UTC

{offset
  c45k:
      _s3F2::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c45l; else goto c45m;
  c45l:
      R1 = _s3F2::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c45m:
      _s3EW::P64 = P64[_s3F2::P64 + 7];
      _s3EY::P64 = P64[_s3F2::P64 + 15];
      P64[_s3EW::P64 + 8] = _s3EY::P64;
      _c45g::I64 = dirty_MUT_VAR;
      _c45h::I64 = BaseReg;
      _c45i::P64 = _s3EW::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_c45g::I64)(_c45h::I64, _c45i::P64);
      R1 = ()_closure+1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-01 18:36:31.925142 UTC

sat_s3F2_entry
[c45k]
{offset
  c45k:
      _s3F2::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c45l; else goto c45m;
  c45l:
      R1 = _s3F2::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c45m:
      _s3EW::P64 = P64[_s3F2::P64 + 7];
      _s3EY::P64 = P64[_s3F2::P64 + 15];
      P64[_s3EW::P64 + 8] = _s3EY::P64;
      _c45g::I64 = dirty_MUT_VAR;
      _c45h::I64 = BaseReg;
      _c45i::P64 = _s3EW::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_c45g::I64)(_c45h::I64, _c45i::P64);
      R1 = ()_closure+1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-01 18:36:31.9283 UTC

{offset
  c45k:
      _s3F2::P64 = R1;
      goto c45m;
  c45m:
      _s3EW::P64 = P64[_s3F2::P64 + 7];
      _s3EY::P64 = P64[_s3F2::P64 + 15];
      P64[_s3EW::P64 + 8] = _s3EY::P64;
      _c45g::I64 = dirty_MUT_VAR;
      _c45h::I64 = BaseReg;
      _c45i::P64 = _s3EW::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_c45g::I64)(_c45h::I64, _c45i::P64);
      R1 = ()_closure+1;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-01 18:36:31.930899 UTC

{offset
  c45k:
      goto c45m;
  c45m:
      _s3EW::P64 = P64[R1 + 7];
      P64[_s3EW::P64 + 8] = P64[R1 + 15];
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s3EW::P64);
      R1 = ()_closure+1;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-01 18:36:31.932612 UTC

[(c45k, {}), (c45m, {})]


==================== procpoint map ====================
2016-08-01 18:36:31.9334 UTC

[(c45k, <procpt>), (c45m, reached by c45k)]


==================== Post splitting ====================
2016-08-01 18:36:31.934211 UTC

sat_s3F2_entry() //  [R1]
        { info_tbl: [(c45k,
                      label: sat_s3F2_info
                      rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c45k:
          goto c45m;
      c45m:
          _s3EW::P64 = P64[R1 + 7];
          P64[_s3EW::P64 + 8] = P64[R1 + 15];
          call "ccall" arg hints:  [PtrHint,
                                    PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s3EW::P64);
          R1 = ()_closure+1;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:31.936603 UTC

sat_s3F2_entry() //  [R1]
        { info_tbl: [(c45k,
                      label: sat_s3F2_info
                      rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c45k:
          goto c45m;
      c45m:
          _s3EW::P64 = P64[R1 + 7];
          P64[_s3EW::P64 + 8] = P64[R1 + 15];
          call "ccall" arg hints:  [PtrHint,
                                    PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s3EW::P64);
          R1 = ()_closure+1;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.938865 UTC

sat_s3F2_entry() //  [R1]
        { info_tbl: [(c45k,
                      label: sat_s3F2_info
                      rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c45k:
          _s3EW::P64 = P64[R1 + 7];
          P64[_s3EW::P64 + 8] = P64[R1 + 15];
          call "ccall" arg hints:  [PtrHint,
                                    PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s3EW::P64);
          R1 = ()_closure+1;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.941556 UTC

{offset
  c45n:
      _s3F3::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c45o; else goto c45p;
  c45o:
      R1 = _s3F3::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c45p:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s3F3::P64;
      _s3EW::P64 = P64[_s3F3::P64 + 16];
      I64[(young<c457> + 8)] = c457;
      P64[(young<c457> + 16)] = main2_closure+1;
      call mkfoo_entry() returns to c457, args: 16, res: 8, upd: 24;
  c457:
      _s3EY::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c45s; else goto c45r;
  c45s:
      HpAlloc = 24;
      R1 = _s3EY::P64;
      call stg_gc_unpt_r1(R1) returns to c457, args: 8, res: 8, upd: 24;
  c45r:
      _s3EZ::P64 = P64[_s3EY::P64 + 7];
      I64[Hp - 16] = sat_s3F2_info;
      P64[Hp - 8] = _s3EW::P64;
      P64[Hp] = _s3EY::P64;
      _c45b::P64 = Hp - 15;
      R1 = _c45b::P64;
      call (I64[P64[(old + 24)]])(R1) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2016-08-01 18:36:31.945835 UTC

{offset
  c45n:
      _s3F3::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c45o; else goto c45p;
  c45o:
      R1 = _s3F3::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c45p:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s3F3::P64;
      _s3EW::P64 = P64[_s3F3::P64 + 16];
      I64[(young<c457> + 8)] = c457;
      P64[(young<c457> + 16)] = main2_closure+1;
      call mkfoo_entry() returns to c457, args: 16, res: 8, upd: 24;
  c457:
      _s3EY::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c45s; else goto c45r;
  c45s:
      HpAlloc = 24;
      R1 = _s3EY::P64;
      call stg_gc_unpt_r1(R1) returns to c457, args: 8, res: 8, upd: 24;
  c45r:
      _s3EZ::P64 = P64[_s3EY::P64 + 7];
      I64[Hp - 16] = sat_s3F2_info;
      P64[Hp - 8] = _s3EW::P64;
      P64[Hp] = _s3EY::P64;
      _c45b::P64 = Hp - 15;
      R1 = _c45b::P64;
      call (I64[P64[(old + 24)]])(R1) args: 24, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-01 18:36:31.949708 UTC

sat_s3F3_entry
[c457, c45n]
{offset
  c45n:
      _s3F3::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c45o; else goto c45p;
  c45o:
      R1 = _s3F3::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c45p:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s3F3::P64;
      _s3EW::P64 = P64[_s3F3::P64 + 16];
      I64[(young<c457> + 8)] = c457;
      P64[(young<c457> + 16)] = main2_closure+1;
      call mkfoo_entry() returns to c457, args: 16, res: 8, upd: 24;
  c457:
      _s3EY::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c45s; else goto c45r;
  c45s:
      HpAlloc = 24;
      R1 = _s3EY::P64;
      call stg_gc_unpt_r1(R1) returns to c457, args: 8, res: 8, upd: 24;
  c45r:
      _s3EZ::P64 = P64[_s3EY::P64 + 7];
      I64[Hp - 16] = sat_s3F2_info;
      P64[Hp - 8] = _s3EW::P64;
      P64[Hp] = _s3EY::P64;
      _c45b::P64 = Hp - 15;
      R1 = _c45b::P64;
      call (I64[P64[(old + 24)]])(R1) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-01 18:36:31.954611 UTC

{offset
  c45n:
      _s3F3::P64 = R1;
      if ((Sp + 8) - 48 < SpLim) goto c45o; else goto c45p;
  c45o:
      R1 = _s3F3::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c45p:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _s3F3::P64;
      _s3EW::P64 = P64[_s3F3::P64 + 16];
      I64[Sp - 32] = c457;
      P64[Sp - 40] = main2_closure+1;
      P64[Sp - 24] = _s3EW::P64;
      Sp = Sp - 40;
      call mkfoo_entry() returns to c457, args: 16, res: 8, upd: 24;
  c457:
      _s3EW::P64 = P64[Sp + 8];
      _s3EY::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c45s; else goto c45r;
  c45s:
      HpAlloc = 24;
      R1 = _s3EY::P64;
      call stg_gc_unpt_r1(R1) returns to c457, args: 8, res: 8, upd: 24;
  c45r:
      _s3EZ::P64 = P64[_s3EY::P64 + 7];
      I64[Hp - 16] = sat_s3F2_info;
      P64[Hp - 8] = _s3EW::P64;
      P64[Hp] = _s3EY::P64;
      _c45b::P64 = Hp - 15;
      R1 = _c45b::P64;
      Sp = Sp + 16;
      call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2016-08-01 18:36:31.959708 UTC

{offset
  c45n:
      if ((Sp + -40) < SpLim) goto c45o; else goto c45p;
  c45o:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c45p:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = R1;
      I64[Sp - 32] = c457;
      P64[Sp - 40] = main2_closure+1;
      P64[Sp - 24] = P64[R1 + 16];
      Sp = Sp - 40;
      call mkfoo_entry() returns to c457, args: 16, res: 8, upd: 24;
  c457:
      Hp = Hp + 24;
      if (Hp > HpLim) goto c45s; else goto c45r;
  c45s:
      HpAlloc = 24;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to c457, args: 8, res: 8, upd: 24;
  c45r:
      I64[Hp - 16] = sat_s3F2_info;
      P64[Hp - 8] = P64[Sp + 8];
      P64[Hp] = R1;
      R1 = Hp - 15;
      Sp = Sp + 16;
      call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-01 18:36:31.96318 UTC

[(c457, {sat_s3F2_closure}), (c45n, {sat_s3F2_closure}),
 (c45o, {}), (c45p, {sat_s3F2_closure}), (c45r, {sat_s3F2_closure}),
 (c45s, {sat_s3F2_closure})]


==================== procpoint map ====================
2016-08-01 18:36:31.964546 UTC

[(c457, <procpt>), (c45n, <procpt>), (c45o, reached by c45n),
 (c45p, reached by c45n), (c45r, reached by c457),
 (c45s, reached by c457)]


==================== Post splitting ====================
2016-08-01 18:36:31.965734 UTC

sat_s3F3_entry() //  [R1]
        { info_tbl: [(c45n,
                      label: sat_s3F3_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c45n:
          if ((Sp + -40) < SpLim) goto c45o; else goto c45p;
      c45o:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c45p:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = R1;
          I64[Sp - 32] = block_c457_info;
          P64[Sp - 40] = main2_closure+1;
          P64[Sp - 24] = P64[R1 + 16];
          Sp = Sp - 40;
          call mkfoo_entry() args: 16, res: 8, upd: 24;
    }
}


==================== Post splitting ====================
2016-08-01 18:36:31.968677 UTC

block_c457_entry() //  [R1]
        { info_tbl: [(c457,
                      label: block_c457_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c457:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c45s; else goto c45r;
      c45s:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
      c45r:
          I64[Hp - 16] = sat_s3F2_info;
          P64[Hp - 8] = P64[Sp + 8];
          P64[Hp] = R1;
          R1 = Hp - 15;
          Sp = Sp + 16;
          call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:31.971252 UTC

sat_s3F3_entry() //  [R1]
        { info_tbl: [(c45n,
                      label: sat_s3F3_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c45n:
          if ((Sp + -40) < SpLim) goto c45o; else goto c45p;
      c45o:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c45p:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = R1;
          I64[Sp - 32] = block_c457_info;
          P64[Sp - 40] = main2_closure+1;
          P64[Sp - 24] = P64[R1 + 16];
          Sp = Sp - 40;
          call mkfoo_entry() args: 16, res: 8, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:31.975007 UTC

block_c457_entry() //  [R1]
        { info_tbl: [(c457,
                      label: block_c457_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c457:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c45s; else goto c45r;
      c45s:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
      c45r:
          I64[Hp - 16] = sat_s3F2_info;
          P64[Hp - 8] = P64[Sp + 8];
          P64[Hp] = R1;
          R1 = Hp - 15;
          Sp = Sp + 16;
          call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.977491 UTC

sat_s3F3_entry() //  [R1]
        { info_tbl: [(c45n,
                      label: sat_s3F3_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c45n:
          if ((Sp + -40) < SpLim) goto c45o; else goto c45p;
      c45o:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c45p:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = R1;
          I64[Sp - 32] = block_c457_info;
          P64[Sp - 40] = main2_closure+1;
          P64[Sp - 24] = P64[R1 + 16];
          Sp = Sp - 40;
          call mkfoo_entry() args: 16, res: 8, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.980124 UTC

block_c457_entry() //  [R1]
        { info_tbl: [(c457,
                      label: block_c457_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c457:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c45s; else goto c45r;
      c45s:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
      c45r:
          I64[Hp - 16] = sat_s3F2_info;
          P64[Hp - 8] = P64[Sp + 8];
          P64[Hp] = R1;
          R1 = Hp - 15;
          Sp = Sp + 16;
          call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:31.982991 UTC

{offset
  c45t:
      _s3F4::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c45u; else goto c45v;
  c45v:
      Hp = Hp + 24;
      if (Hp > HpLim) goto c45x; else goto c45w;
  c45x:
      HpAlloc = 24;
      goto c45u;
  c45u:
      R1 = _s3F4::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c45w:
      _s3EW::P64 = P64[_s3F4::P64 + 7];
      I64[Hp - 16] = sat_s3F3_info;
      P64[Hp] = _s3EW::P64;
      _c453::P64 = Hp - 16;
      R1 = _c453::P64;
      P64[(old + 16)] = childHandler1_closure+2;
      call stg_catch#(R1) args: 16, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-01 18:36:31.985825 UTC

{offset
  c45t:
      _s3F4::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c45u; else goto c45v;
  c45v:
      Hp = Hp + 24;
      if (Hp > HpLim) goto c45x; else goto c45w;
  c45x:
      HpAlloc = 24;
      goto c45u;
  c45u:
      R1 = _s3F4::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c45w:
      _s3EW::P64 = P64[_s3F4::P64 + 7];
      I64[Hp - 16] = sat_s3F3_info;
      P64[Hp] = _s3EW::P64;
      _c453::P64 = Hp - 16;
      R1 = _c453::P64;
      P64[(old + 16)] = childHandler1_closure+2;
      call stg_catch#(R1) args: 16, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-01 18:36:31.988372 UTC

sat_s3F4_entry
[c45t]
{offset
  c45t:
      _s3F4::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c45u; else goto c45v;
  c45v:
      Hp = Hp + 24;
      if (Hp > HpLim) goto c45x; else goto c45w;
  c45x:
      HpAlloc = 24;
      goto c45u;
  c45u:
      R1 = _s3F4::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c45w:
      _s3EW::P64 = P64[_s3F4::P64 + 7];
      I64[Hp - 16] = sat_s3F3_info;
      P64[Hp] = _s3EW::P64;
      _c453::P64 = Hp - 16;
      R1 = _c453::P64;
      P64[(old + 16)] = childHandler1_closure+2;
      call stg_catch#(R1) args: 16, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-01 18:36:31.99165 UTC

{offset
  c45t:
      _s3F4::P64 = R1;
      if ((Sp + 8) - 16 < SpLim) goto c45u; else goto c45v;
  c45v:
      Hp = Hp + 24;
      if (Hp > HpLim) goto c45x; else goto c45w;
  c45x:
      HpAlloc = 24;
      goto c45u;
  c45u:
      R1 = _s3F4::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c45w:
      _s3EW::P64 = P64[_s3F4::P64 + 7];
      I64[Hp - 16] = sat_s3F3_info;
      P64[Hp] = _s3EW::P64;
      _c453::P64 = Hp - 16;
      R1 = _c453::P64;
      P64[Sp - 8] = childHandler1_closure+2;
      Sp = Sp - 8;
      call stg_catch#(R1) args: 16, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-01 18:36:31.994773 UTC

{offset
  c45t:
      _s3F4::P64 = R1;
      if ((Sp + -8) < SpLim) goto c45u; else goto c45v;
  c45v:
      Hp = Hp + 24;
      if (Hp > HpLim) goto c45x; else goto c45w;
  c45x:
      HpAlloc = 24;
      goto c45u;
  c45u:
      R1 = _s3F4::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c45w:
      _s3EW::P64 = P64[_s3F4::P64 + 7];
      I64[Hp - 16] = sat_s3F3_info;
      P64[Hp] = _s3EW::P64;
      R1 = Hp - 16;
      P64[Sp - 8] = childHandler1_closure+2;
      Sp = Sp - 8;
      call stg_catch#(R1) args: 16, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-01 18:36:31.997249 UTC

[(c45t, {childHandler1_closure, sat_s3F3_closure}), (c45u, {}),
 (c45v, {childHandler1_closure, sat_s3F3_closure}),
 (c45w, {childHandler1_closure, sat_s3F3_closure}), (c45x, {})]


==================== procpoint map ====================
2016-08-01 18:36:31.998552 UTC

[(c45t, <procpt>), (c45u, reached by c45t),
 (c45v, reached by c45t), (c45w, reached by c45t),
 (c45x, reached by c45t)]


==================== Post splitting ====================
2016-08-01 18:36:31.999645 UTC

sat_s3F4_entry() //  [R1]
        { info_tbl: [(c45t,
                      label: sat_s3F4_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c45t:
          _s3F4::P64 = R1;
          if ((Sp + -8) < SpLim) goto c45u; else goto c45v;
      c45v:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c45x; else goto c45w;
      c45x:
          HpAlloc = 24;
          goto c45u;
      c45u:
          R1 = _s3F4::P64;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c45w:
          _s3EW::P64 = P64[_s3F4::P64 + 7];
          I64[Hp - 16] = sat_s3F3_info;
          P64[Hp] = _s3EW::P64;
          R1 = Hp - 16;
          P64[Sp - 8] = childHandler1_closure+2;
          Sp = Sp - 8;
          call stg_catch#(R1) args: 16, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:32.003085 UTC

sat_s3F4_entry() //  [R1]
        { info_tbl: [(c45t,
                      label: sat_s3F4_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c45t:
          _s3F4::P64 = R1;
          if ((Sp + -8) < SpLim) goto c45u; else goto c45v;
      c45v:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c45x; else goto c45w;
      c45x:
          HpAlloc = 24;
          goto c45u;
      c45u:
          R1 = _s3F4::P64;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c45w:
          _s3EW::P64 = P64[_s3F4::P64 + 7];
          I64[Hp - 16] = sat_s3F3_info;
          P64[Hp] = _s3EW::P64;
          R1 = Hp - 16;
          P64[Sp - 8] = childHandler1_closure+2;
          Sp = Sp - 8;
          call stg_catch#(R1) args: 16, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:32.006259 UTC

sat_s3F4_entry() //  [R1]
        { info_tbl: [(c45t,
                      label: sat_s3F4_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c45t:
          _s3F4::P64 = R1;
          if ((Sp + -8) < SpLim) goto c45u; else goto c45v;
      c45v:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c45x; else goto c45w;
      c45x:
          HpAlloc = 24;
          goto c45u;
      c45u:
          R1 = _s3F4::P64;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c45w:
          _s3EW::P64 = P64[_s3F4::P64 + 7];
          I64[Hp - 16] = sat_s3F3_info;
          P64[Hp] = _s3EW::P64;
          R1 = Hp - 16;
          P64[Sp - 8] = childHandler1_closure+2;
          Sp = Sp - 8;
          call stg_catch#(R1) args: 16, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:32.009661 UTC

{offset
  c45E:
      _s3Fb::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c45F; else goto c45G;
  c45F:
      R1 = _s3Fb::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c45G:
      _s3Fa::P64 = P64[_s3Fb::P64 + 16];
      P64[(old + 16)] = _s3Fa::P64;
      call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-01 18:36:32.011606 UTC

{offset
  c45E:
      _s3Fb::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c45F; else goto c45G;
  c45F:
      R1 = _s3Fb::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c45G:
      _s3Fa::P64 = P64[_s3Fb::P64 + 16];
      P64[(old + 16)] = _s3Fa::P64;
      call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-01 18:36:32.013295 UTC

sat_s3Fb_entry
[c45E]
{offset
  c45E:
      _s3Fb::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c45F; else goto c45G;
  c45F:
      R1 = _s3Fb::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c45G:
      _s3Fa::P64 = P64[_s3Fb::P64 + 16];
      P64[(old + 16)] = _s3Fa::P64;
      call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-01 18:36:32.015429 UTC

{offset
  c45E:
      _s3Fb::P64 = R1;
      if ((Sp + 8) - 16 < SpLim) goto c45F; else goto c45G;
  c45F:
      R1 = _s3Fb::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c45G:
      _s3Fa::P64 = P64[_s3Fb::P64 + 16];
      P64[Sp - 8] = _s3Fa::P64;
      Sp = Sp - 8;
      call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-01 18:36:32.017554 UTC

{offset
  c45E:
      if ((Sp + -8) < SpLim) goto c45F; else goto c45G;
  c45F:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c45G:
      P64[Sp - 8] = P64[R1 + 16];
      Sp = Sp - 8;
      call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-01 18:36:32.019066 UTC

[(c45E, {$fShowFoo_$cshow_closure}), (c45F, {}),
 (c45G, {$fShowFoo_$cshow_closure})]


==================== procpoint map ====================
2016-08-01 18:36:32.020003 UTC

[(c45E, <procpt>), (c45F, reached by c45E),
 (c45G, reached by c45E)]


==================== Post splitting ====================
2016-08-01 18:36:32.020905 UTC

sat_s3Fb_entry() //  [R1]
        { info_tbl: [(c45E,
                      label: sat_s3Fb_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c45E:
          if ((Sp + -8) < SpLim) goto c45F; else goto c45G;
      c45F:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c45G:
          P64[Sp - 8] = P64[R1 + 16];
          Sp = Sp - 8;
          call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:32.023964 UTC

sat_s3Fb_entry() //  [R1]
        { info_tbl: [(c45E,
                      label: sat_s3Fb_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c45E:
          if ((Sp + -8) < SpLim) goto c45F; else goto c45G;
      c45F:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c45G:
          P64[Sp - 8] = P64[R1 + 16];
          Sp = Sp - 8;
          call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:32.026041 UTC

sat_s3Fb_entry() //  [R1]
        { info_tbl: [(c45E,
                      label: sat_s3Fb_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c45E:
          if ((Sp + -8) < SpLim) goto c45F; else goto c45G;
      c45F:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c45G:
          P64[Sp - 8] = P64[R1 + 16];
          Sp = Sp - 8;
          call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:32.028598 UTC

{offset
  c45H:
      if ((old + 0) - <highSp> < SpLim) goto c45I; else goto c45J;
  c45I:
      R1 = main1_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c45J:
      I64[(young<c44U> + 8)] = c44U;
      P64[(young<c44U> + 32)] = stdout_closure;
      P64[(young<c44U> + 24)] = main5_closure+2;
      P64[(young<c44U> + 16)] = True_closure+2;
      call hPutStr2_entry() returns to c44U, args: 32, res: 8, upd: 8;
  c44U:
      _s3ET::P64 = R1;
      I64[(young<c44W> + 8)] = c44W;
      R1 = main3_closure+1;
      call stg_newMutVar#(R1) returns to c44W, args: 8, res: 8, upd: 8;
  c44W:
      _s3EW::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto c45N; else goto c45M;
  c45N:
      HpAlloc = 16;
      R1 = _s3EW::P64;
      call stg_gc_unpt_r1(R1) returns to c44W, args: 8, res: 8, upd: 8;
  c45M:
      I64[Hp - 8] = sat_s3F4_info;
      P64[Hp] = _s3EW::P64;
      _c44Y::P64 = Hp - 7;
      I64[(young<c45y> + 8)] = c45y;
      R1 = _c44Y::P64;
      call stg_fork#(R1) returns to c45y, args: 8, res: 8, upd: 8;
  c45y:
      _s3F7::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c45Q; else goto c45P;
  c45Q:
      HpAlloc = 24;
      R1 = _s3F7::P64;
      call stg_gc_unpt_r1(R1) returns to c45y, args: 8, res: 8, upd: 8;
  c45P:
      _s3Fa::P64 = P64[_s3EW::P64 + 8];
      _s3Fa::P64 = _s3Fa::P64;
      I64[Hp - 16] = sat_s3Fb_info;
      P64[Hp] = _s3Fa::P64;
      _c45A::P64 = Hp - 16;
      P64[(old + 32)] = stdout_closure;
      P64[(old + 24)] = _c45A::P64;
      P64[(old + 16)] = True_closure+2;
      call hPutStr2_entry() args: 32, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-01 18:36:32.035073 UTC

{offset
  c45H:
      if ((old + 0) - <highSp> < SpLim) goto c45I; else goto c45J;
  c45I:
      R1 = main1_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c45J:
      I64[(young<c44U> + 8)] = c44U;
      P64[(young<c44U> + 32)] = stdout_closure;
      P64[(young<c44U> + 24)] = main5_closure+2;
      P64[(young<c44U> + 16)] = True_closure+2;
      call hPutStr2_entry() returns to c44U, args: 32, res: 8, upd: 8;
  c44U:
      _s3ET::P64 = R1;
      I64[(young<c44W> + 8)] = c44W;
      R1 = main3_closure+1;
      call stg_newMutVar#(R1) returns to c44W, args: 8, res: 8, upd: 8;
  c44W:
      _s3EW::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto c45N; else goto c45M;
  c45N:
      HpAlloc = 16;
      R1 = _s3EW::P64;
      call stg_gc_unpt_r1(R1) returns to c44W, args: 8, res: 8, upd: 8;
  c45M:
      I64[Hp - 8] = sat_s3F4_info;
      P64[Hp] = _s3EW::P64;
      _c44Y::P64 = Hp - 7;
      I64[(young<c45y> + 8)] = c45y;
      R1 = _c44Y::P64;
      call stg_fork#(R1) returns to c45y, args: 8, res: 8, upd: 8;
  c45y:
      _s3F7::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c45Q; else goto c45P;
  c45Q:
      HpAlloc = 24;
      R1 = _s3F7::P64;
      call stg_gc_unpt_r1(R1) returns to c45y, args: 8, res: 8, upd: 8;
  c45P:
      _s3Fa::P64 = P64[_s3EW::P64 + 8];
      _s3Fa::P64 = _s3Fa::P64;
      I64[Hp - 16] = sat_s3Fb_info;
      P64[Hp] = _s3Fa::P64;
      _c45A::P64 = Hp - 16;
      P64[(old + 32)] = stdout_closure;
      P64[(old + 24)] = _c45A::P64;
      P64[(old + 16)] = True_closure+2;
      call hPutStr2_entry() args: 32, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-01 18:36:32.040908 UTC

main1_entry
[c44U, c44W, c45y, c45H]
{offset
  c45H:
      if ((old + 0) - <highSp> < SpLim) goto c45I; else goto c45J;
  c45I:
      R1 = main1_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c45J:
      I64[(young<c44U> + 8)] = c44U;
      P64[(young<c44U> + 32)] = stdout_closure;
      P64[(young<c44U> + 24)] = main5_closure+2;
      P64[(young<c44U> + 16)] = True_closure+2;
      call hPutStr2_entry() returns to c44U, args: 32, res: 8, upd: 8;
  c44U:
      _s3ET::P64 = R1;
      I64[(young<c44W> + 8)] = c44W;
      R1 = main3_closure+1;
      call stg_newMutVar#(R1) returns to c44W, args: 8, res: 8, upd: 8;
  c44W:
      _s3EW::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto c45N; else goto c45M;
  c45N:
      HpAlloc = 16;
      R1 = _s3EW::P64;
      call stg_gc_unpt_r1(R1) returns to c44W, args: 8, res: 8, upd: 8;
  c45M:
      I64[Hp - 8] = sat_s3F4_info;
      P64[Hp] = _s3EW::P64;
      _c44Y::P64 = Hp - 7;
      I64[(young<c45y> + 8)] = c45y;
      R1 = _c44Y::P64;
      call stg_fork#(R1) returns to c45y, args: 8, res: 8, upd: 8;
  c45y:
      _s3F7::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c45Q; else goto c45P;
  c45Q:
      HpAlloc = 24;
      R1 = _s3F7::P64;
      call stg_gc_unpt_r1(R1) returns to c45y, args: 8, res: 8, upd: 8;
  c45P:
      _s3Fa::P64 = P64[_s3EW::P64 + 8];
      _s3Fa::P64 = _s3Fa::P64;
      I64[Hp - 16] = sat_s3Fb_info;
      P64[Hp] = _s3Fa::P64;
      _c45A::P64 = Hp - 16;
      P64[(old + 32)] = stdout_closure;
      P64[(old + 24)] = _c45A::P64;
      P64[(old + 16)] = True_closure+2;
      call hPutStr2_entry() args: 32, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-01 18:36:32.048027 UTC

{offset
  c45H:
      if ((Sp + 8) - 40 < SpLim) goto c45I; else goto c45J;
  c45I:
      R1 = main1_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c45J:
      I64[Sp - 8] = c44U;
      P64[Sp - 32] = stdout_closure;
      P64[Sp - 24] = main5_closure+2;
      P64[Sp - 16] = True_closure+2;
      Sp = Sp - 32;
      call hPutStr2_entry() returns to c44U, args: 32, res: 8, upd: 8;
  c44U:
      _s3ET::P64 = R1;
      I64[Sp] = c44W;
      R1 = main3_closure+1;
      call stg_newMutVar#(R1) returns to c44W, args: 8, res: 8, upd: 8;
  c44W:
      _s3EW::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto c45N; else goto c45M;
  c45N:
      HpAlloc = 16;
      R1 = _s3EW::P64;
      call stg_gc_unpt_r1(R1) returns to c44W, args: 8, res: 8, upd: 8;
  c45M:
      I64[Hp - 8] = sat_s3F4_info;
      P64[Hp] = _s3EW::P64;
      _c44Y::P64 = Hp - 7;
      I64[Sp - 8] = c45y;
      R1 = _c44Y::P64;
      P64[Sp] = _s3EW::P64;
      Sp = Sp - 8;
      call stg_fork#(R1) returns to c45y, args: 8, res: 8, upd: 8;
  c45y:
      _s3EW::P64 = P64[Sp + 8];
      _s3F7::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c45Q; else goto c45P;
  c45Q:
      HpAlloc = 24;
      R1 = _s3F7::P64;
      call stg_gc_unpt_r1(R1) returns to c45y, args: 8, res: 8, upd: 8;
  c45P:
      _s3Fa::P64 = P64[_s3EW::P64 + 8];
      _s3Fa::P64 = _s3Fa::P64;
      I64[Hp - 16] = sat_s3Fb_info;
      P64[Hp] = _s3Fa::P64;
      _c45A::P64 = Hp - 16;
      P64[Sp - 8] = stdout_closure;
      P64[Sp] = _c45A::P64;
      P64[Sp + 8] = True_closure+2;
      Sp = Sp - 8;
      call hPutStr2_entry() args: 32, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-01 18:36:32.055311 UTC

{offset
  c45H:
      if ((Sp + -32) < SpLim) goto c45I; else goto c45J;
  c45I:
      R1 = main1_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c45J:
      I64[Sp - 8] = c44U;
      P64[Sp - 32] = stdout_closure;
      P64[Sp - 24] = main5_closure+2;
      P64[Sp - 16] = True_closure+2;
      Sp = Sp - 32;
      call hPutStr2_entry() returns to c44U, args: 32, res: 8, upd: 8;
  c44U:
      I64[Sp] = c44W;
      R1 = main3_closure+1;
      call stg_newMutVar#(R1) returns to c44W, args: 8, res: 8, upd: 8;
  c44W:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c45N; else goto c45M;
  c45N:
      HpAlloc = 16;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to c44W, args: 8, res: 8, upd: 8;
  c45M:
      I64[Hp - 8] = sat_s3F4_info;
      P64[Hp] = R1;
      I64[Sp - 8] = c45y;
      _s3EW::P64 = R1;
      R1 = Hp - 7;
      P64[Sp] = _s3EW::P64;
      Sp = Sp - 8;
      call stg_fork#(R1) returns to c45y, args: 8, res: 8, upd: 8;
  c45y:
      Hp = Hp + 24;
      if (Hp > HpLim) goto c45Q; else goto c45P;
  c45Q:
      HpAlloc = 24;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to c45y, args: 8, res: 8, upd: 8;
  c45P:
      I64[Hp - 16] = sat_s3Fb_info;
      P64[Hp] = P64[P64[Sp + 8] + 8];
      P64[Sp - 8] = stdout_closure;
      P64[Sp] = Hp - 16;
      P64[Sp + 8] = True_closure+2;
      Sp = Sp - 8;
      call hPutStr2_entry() args: 32, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-01 18:36:32.060568 UTC

[(c44U,
  {hPutStr2_closure, stdout_closure, sat_s3F4_closure,
   sat_s3Fb_closure}),
 (c44W,
  {hPutStr2_closure, stdout_closure, sat_s3F4_closure,
   sat_s3Fb_closure}),
 (c45y, {hPutStr2_closure, stdout_closure, sat_s3Fb_closure}),
 (c45H,
  {hPutStr2_closure, stdout_closure, main1_closure, main5_closure,
   sat_s3F4_closure, sat_s3Fb_closure}),
 (c45I, {main1_closure}),
 (c45J,
  {hPutStr2_closure, stdout_closure, main5_closure, sat_s3F4_closure,
   sat_s3Fb_closure}),
 (c45M,
  {hPutStr2_closure, stdout_closure, sat_s3F4_closure,
   sat_s3Fb_closure}),
 (c45N,
  {hPutStr2_closure, stdout_closure, sat_s3F4_closure,
   sat_s3Fb_closure}),
 (c45P, {hPutStr2_closure, stdout_closure, sat_s3Fb_closure}),
 (c45Q, {hPutStr2_closure, stdout_closure, sat_s3Fb_closure})]


==================== procpoint map ====================
2016-08-01 18:36:32.064306 UTC

[(c44U, <procpt>), (c44W, <procpt>), (c45y, <procpt>),
 (c45H, <procpt>), (c45I, reached by c45H), (c45J, reached by c45H),
 (c45M, reached by c44W), (c45N, reached by c44W),
 (c45P, reached by c45y), (c45Q, reached by c45y)]


==================== Post splitting ====================
2016-08-01 18:36:32.065817 UTC

main1_entry() //  []
        { info_tbl: [(c45H,
                      label: main1_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c45H:
          if ((Sp + -32) < SpLim) goto c45I; else goto c45J;
      c45I:
          R1 = main1_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c45J:
          I64[Sp - 8] = block_c44U_info;
          P64[Sp - 32] = stdout_closure;
          P64[Sp - 24] = main5_closure+2;
          P64[Sp - 16] = True_closure+2;
          Sp = Sp - 32;
          call hPutStr2_entry() args: 32, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-01 18:36:32.068725 UTC

block_c44U_entry() //  []
        { info_tbl: [(c44U,
                      label: block_c44U_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44U:
          I64[Sp] = block_c44W_info;
          R1 = main3_closure+1;
          call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-01 18:36:32.070226 UTC

block_c44W_entry() //  [R1]
        { info_tbl: [(c44W,
                      label: block_c44W_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44W:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c45N; else goto c45M;
      c45N:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c45M:
          I64[Hp - 8] = sat_s3F4_info;
          P64[Hp] = R1;
          I64[Sp - 8] = block_c45y_info;
          _s3EW::P64 = R1;
          R1 = Hp - 7;
          P64[Sp] = _s3EW::P64;
          Sp = Sp - 8;
          call stg_fork#(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-01 18:36:32.072958 UTC

block_c45y_entry() //  [R1]
        { info_tbl: [(c45y,
                      label: block_c45y_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c45y:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c45Q; else goto c45P;
      c45Q:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c45P:
          I64[Hp - 16] = sat_s3Fb_info;
          P64[Hp] = P64[P64[Sp + 8] + 8];
          P64[Sp - 8] = stdout_closure;
          P64[Sp] = Hp - 16;
          P64[Sp + 8] = True_closure+2;
          Sp = Sp - 8;
          call hPutStr2_entry() args: 32, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:32.075673 UTC

main1_entry() //  []
        { info_tbl: [(c45H,
                      label: main1_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c45H:
          if ((Sp + -32) < SpLim) goto c45I; else goto c45J;
      c45I:
          R1 = main1_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c45J:
          I64[Sp - 8] = block_c44U_info;
          P64[Sp - 32] = stdout_closure;
          P64[Sp - 24] = main5_closure+2;
          P64[Sp - 16] = True_closure+2;
          Sp = Sp - 32;
          call hPutStr2_entry() args: 32, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:32.078144 UTC

block_c44U_entry() //  []
        { info_tbl: [(c44U,
                      label: block_c44U_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44U:
          I64[Sp] = block_c44W_info;
          R1 = main3_closure+1;
          call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:32.079632 UTC

block_c44W_entry() //  [R1]
        { info_tbl: [(c44W,
                      label: block_c44W_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44W:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c45N; else goto c45M;
      c45N:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c45M:
          I64[Hp - 8] = sat_s3F4_info;
          P64[Hp] = R1;
          I64[Sp - 8] = block_c45y_info;
          _s3EW::P64 = R1;
          R1 = Hp - 7;
          P64[Sp] = _s3EW::P64;
          Sp = Sp - 8;
          call stg_fork#(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:32.082336 UTC

block_c45y_entry() //  [R1]
        { info_tbl: [(c45y,
                      label: block_c45y_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c45y:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c45Q; else goto c45P;
      c45Q:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c45P:
          I64[Hp - 16] = sat_s3Fb_info;
          P64[Hp] = P64[P64[Sp + 8] + 8];
          P64[Sp - 8] = stdout_closure;
          P64[Sp] = Hp - 16;
          P64[Sp + 8] = True_closure+2;
          Sp = Sp - 8;
          call hPutStr2_entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:32.085048 UTC

main1_entry() //  []
        { info_tbl: [(c45H,
                      label: main1_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c45H:
          if ((Sp + -32) < SpLim) goto c45I; else goto c45J;
      c45I:
          R1 = main1_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c45J:
          I64[Sp - 8] = block_c44U_info;
          P64[Sp - 32] = stdout_closure;
          P64[Sp - 24] = main5_closure+2;
          P64[Sp - 16] = True_closure+2;
          Sp = Sp - 32;
          call hPutStr2_entry() args: 32, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:32.087573 UTC

block_c44U_entry() //  []
        { info_tbl: [(c44U,
                      label: block_c44U_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44U:
          I64[Sp] = block_c44W_info;
          R1 = main3_closure+1;
          call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:32.089076 UTC

block_c44W_entry() //  [R1]
        { info_tbl: [(c44W,
                      label: block_c44W_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44W:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c45N; else goto c45M;
      c45N:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c45M:
          I64[Hp - 8] = sat_s3F4_info;
          P64[Hp] = R1;
          I64[Sp - 8] = block_c45y_info;
          _s3EW::P64 = R1;
          R1 = Hp - 7;
          P64[Sp] = _s3EW::P64;
          Sp = Sp - 8;
          call stg_fork#(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:32.091833 UTC

block_c45y_entry() //  [R1]
        { info_tbl: [(c45y,
                      label: block_c45y_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c45y:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c45Q; else goto c45P;
      c45Q:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c45P:
          I64[Hp - 16] = sat_s3Fb_info;
          P64[Hp] = P64[P64[Sp + 8] + 8];
          P64[Sp - 8] = stdout_closure;
          P64[Sp] = Hp - 16;
          P64[Sp + 8] = True_closure+2;
          Sp = Sp - 8;
          call hPutStr2_entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-01 18:36:32.094587 UTC

[section "data" {
     main1_closure:
         const main1_info;
         const 0;
 },
 sat_s3F2_entry() //  [R1]
         { info_tbl: [(c45k,
                       label: sat_s3F2_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45k:
           _s3EW::P64 = P64[R1 + 7];
           P64[_s3EW::P64 + 8] = P64[R1 + 15];
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s3EW::P64);
           R1 = ()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s3F3_entry() //  [R1]
         { info_tbl: [(c45n,
                       label: sat_s3F3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45n:
           if ((Sp + -40) < SpLim) goto c45o; else goto c45p;
       c45o:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45p:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c457_info;
           P64[Sp - 40] = main2_closure+1;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 40;
           call mkfoo_entry() args: 16, res: 8, upd: 24;
     }
 },
 block_c457_entry() //  [R1]
         { info_tbl: [(c457,
                       label: block_c457_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c457:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c45s; else goto c45r;
       c45s:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c45r:
           I64[Hp - 16] = sat_s3F2_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3F4_entry() //  [R1]
         { info_tbl: [(c45t,
                       label: sat_s3F4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45t:
           _s3F4::P64 = R1;
           if ((Sp + -8) < SpLim) goto c45u; else goto c45v;
       c45v:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c45x; else goto c45w;
       c45x:
           HpAlloc = 24;
           goto c45u;
       c45u:
           R1 = _s3F4::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c45w:
           _s3EW::P64 = P64[_s3F4::P64 + 7];
           I64[Hp - 16] = sat_s3F3_info;
           P64[Hp] = _s3EW::P64;
           R1 = Hp - 16;
           P64[Sp - 8] = childHandler1_closure+2;
           Sp = Sp - 8;
           call stg_catch#(R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_s3Fb_entry() //  [R1]
         { info_tbl: [(c45E,
                       label: sat_s3Fb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45E:
           if ((Sp + -8) < SpLim) goto c45F; else goto c45G;
       c45F:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45G:
           P64[Sp - 8] = P64[R1 + 16];
           Sp = Sp - 8;
           call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
     }
 },
 main1_entry() //  []
         { info_tbl: [(c45H,
                       label: main1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45H:
           if ((Sp + -32) < SpLim) goto c45I; else goto c45J;
       c45I:
           R1 = main1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c45J:
           I64[Sp - 8] = block_c44U_info;
           P64[Sp - 32] = stdout_closure;
           P64[Sp - 24] = main5_closure+2;
           P64[Sp - 16] = True_closure+2;
           Sp = Sp - 32;
           call hPutStr2_entry() args: 32, res: 8, upd: 8;
     }
 },
 block_c44U_entry() //  []
         { info_tbl: [(c44U,
                       label: block_c44U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44U:
           I64[Sp] = block_c44W_info;
           R1 = main3_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c44W_entry() //  [R1]
         { info_tbl: [(c44W,
                       label: block_c44W_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44W:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c45N; else goto c45M;
       c45N:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c45M:
           I64[Hp - 8] = sat_s3F4_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c45y_info;
           _s3EW::P64 = R1;
           R1 = Hp - 7;
           P64[Sp] = _s3EW::P64;
           Sp = Sp - 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c45y_entry() //  [R1]
         { info_tbl: [(c45y,
                       label: block_c45y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45y:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c45Q; else goto c45P;
       c45Q:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c45P:
           I64[Hp - 16] = sat_s3Fb_info;
           P64[Hp] = P64[P64[Sp + 8] + 8];
           P64[Sp - 8] = stdout_closure;
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = True_closure+2;
           Sp = Sp - 8;
           call hPutStr2_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-01 18:36:32.113948 UTC

[section "data" {
     main1_closure:
         const main1_info;
         const 0;
 },
 sat_s3F2_entry() //  [R1]
         { info_tbl: [(c45k,
                       label: sat_s3F2_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45k:
           _s3EW::P64 = P64[R1 + 7];
           P64[_s3EW::P64 + 8] = P64[R1 + 15];
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s3EW::P64);
           R1 = ()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s3F3_entry() //  [R1]
         { info_tbl: [(c45n,
                       label: sat_s3F3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45n:
           if ((Sp + -40) < SpLim) goto c45o; else goto c45p;
       c45o:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45p:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c457_info;
           P64[Sp - 40] = main2_closure+1;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 40;
           call mkfoo_entry() args: 16, res: 8, upd: 24;
     }
 },
 block_c457_entry() //  [R1]
         { info_tbl: [(c457,
                       label: block_c457_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c457:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c45s; else goto c45r;
       c45s:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c45r:
           I64[Hp - 16] = sat_s3F2_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s3F4_entry() //  [R1]
         { info_tbl: [(c45t,
                       label: sat_s3F4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45t:
           _s3F4::P64 = R1;
           if ((Sp + -8) < SpLim) goto c45u; else goto c45v;
       c45v:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c45x; else goto c45w;
       c45x:
           HpAlloc = 24;
           goto c45u;
       c45u:
           R1 = _s3F4::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c45w:
           _s3EW::P64 = P64[_s3F4::P64 + 7];
           I64[Hp - 16] = sat_s3F3_info;
           P64[Hp] = _s3EW::P64;
           R1 = Hp - 16;
           P64[Sp - 8] = childHandler1_closure+2;
           Sp = Sp - 8;
           call stg_catch#(R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_s3Fb_entry() //  [R1]
         { info_tbl: [(c45E,
                       label: sat_s3Fb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45E:
           if ((Sp + -8) < SpLim) goto c45F; else goto c45G;
       c45F:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45G:
           P64[Sp - 8] = P64[R1 + 16];
           Sp = Sp - 8;
           call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
     }
 },
 main1_entry() //  []
         { info_tbl: [(c45H,
                       label: main1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45H:
           if ((Sp + -32) < SpLim) goto c45I; else goto c45J;
       c45I:
           R1 = main1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c45J:
           I64[Sp - 8] = block_c44U_info;
           P64[Sp - 32] = stdout_closure;
           P64[Sp - 24] = main5_closure+2;
           P64[Sp - 16] = True_closure+2;
           Sp = Sp - 32;
           call hPutStr2_entry() args: 32, res: 8, upd: 8;
     }
 },
 block_c44U_entry() //  []
         { info_tbl: [(c44U,
                       label: block_c44U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44U:
           I64[Sp] = block_c44W_info;
           R1 = main3_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c44W_entry() //  [R1]
         { info_tbl: [(c44W,
                       label: block_c44W_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44W:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c45N; else goto c45M;
       c45N:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c45M:
           I64[Hp - 8] = sat_s3F4_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c45y_info;
           _s3EW::P64 = R1;
           R1 = Hp - 7;
           P64[Sp] = _s3EW::P64;
           Sp = Sp - 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c45y_entry() //  [R1]
         { info_tbl: [(c45y,
                       label: block_c45y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45y:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c45Q; else goto c45P;
       c45Q:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c45P:
           I64[Hp - 16] = sat_s3Fb_info;
           P64[Hp] = P64[P64[Sp + 8] + 8];
           P64[Sp - 8] = stdout_closure;
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = True_closure+2;
           Sp = Sp - 8;
           call hPutStr2_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:36:32.281229 UTC

[section "data" {
     main_closure:
         const main_info;
         const 0;
 },
 main_entry() //  []
         { info_tbl: [(c4eT,
                       label: main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4eT:
           goto c4eR;
       c4eR:
           if ((old + 0) - <highSp> < SpLim) goto c4eU; else goto c4eV;
       c4eU:
           R1 = main_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4eV:
           goto c4eQ;
       c4eQ:
           call main1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-01 18:36:32.284273 UTC

{offset
  c4eT:
      if ((old + 0) - <highSp> < SpLim) goto c4eU; else goto c4eV;
  c4eU:
      R1 = main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4eV:
      call main1_entry() args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-01 18:36:32.285743 UTC

{offset
  c4eT:
      if ((old + 0) - <highSp> < SpLim) goto c4eU; else goto c4eV;
  c4eU:
      R1 = main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4eV:
      call main1_entry() args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-01 18:36:32.287032 UTC

main_entry
[c4eT]
{offset
  c4eT:
      if ((old + 0) - <highSp> < SpLim) goto c4eU; else goto c4eV;
  c4eU:
      R1 = main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4eV:
      call main1_entry() args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-01 18:36:32.288701 UTC

{offset
  c4eT:
      goto c4eV;
  c4eV:
      call main1_entry() args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-01 18:36:32.289691 UTC

{offset
  c4eT:
      goto c4eV;
  c4eV:
      call main1_entry() args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-01 18:36:32.290571 UTC

[(c4eT, {main1_closure}), (c4eV, {main1_closure})]


==================== procpoint map ====================
2016-08-01 18:36:32.291491 UTC

[(c4eT, <procpt>), (c4eV, reached by c4eT)]


==================== Post splitting ====================
2016-08-01 18:36:32.292304 UTC

main_entry() //  []
        { info_tbl: [(c4eT,
                      label: main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4eT:
          goto c4eV;
      c4eV:
          call main1_entry() args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:32.293806 UTC

main_entry() //  []
        { info_tbl: [(c4eT,
                      label: main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4eT:
          goto c4eV;
      c4eV:
          call main1_entry() args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:32.29615 UTC

main_entry() //  []
        { info_tbl: [(c4eT,
                      label: main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4eT:
          call main1_entry() args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-01 18:36:32.297559 UTC

[section "data" {
     main_closure:
         const main_info;
         const 0;
 },
 main_entry() //  []
         { info_tbl: [(c4eT,
                       label: main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4eT:
           call main1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-01 18:36:32.299309 UTC

[section "data" {
     main_closure:
         const main_info;
         const 0;
 },
 main_entry() //  []
         { info_tbl: [(c4eT,
                       label: main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4eT:
           call main1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:36:32.30652 UTC

[section "data" {
     main9_closure:
         const main9_info;
         const 0;
 },
 main9_entry() //  []
         { info_tbl: [(c4f1,
                       label: main9_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4f1:
           goto c4eZ;
       c4eZ:
           if ((old + 0) - <highSp> < SpLim) goto c4f2; else goto c4f3;
       c4f2:
           R1 = main9_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4f3:
           goto c4eY;
       c4eY:
           P64[(old + 16)] = main1_closure+1;
           call runMainIO1_entry() args: 16, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-01 18:36:32.309553 UTC

{offset
  c4f1:
      if ((old + 0) - <highSp> < SpLim) goto c4f2; else goto c4f3;
  c4f2:
      R1 = main9_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4f3:
      P64[(old + 16)] = main1_closure+1;
      call runMainIO1_entry() args: 16, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-01 18:36:32.3112 UTC

{offset
  c4f1:
      if ((old + 0) - <highSp> < SpLim) goto c4f2; else goto c4f3;
  c4f2:
      R1 = main9_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4f3:
      P64[(old + 16)] = main1_closure+1;
      call runMainIO1_entry() args: 16, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-01 18:36:32.312632 UTC

main9_entry
[c4f1]
{offset
  c4f1:
      if ((old + 0) - <highSp> < SpLim) goto c4f2; else goto c4f3;
  c4f2:
      R1 = main9_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4f3:
      P64[(old + 16)] = main1_closure+1;
      call runMainIO1_entry() args: 16, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-01 18:36:32.314466 UTC

{offset
  c4f1:
      if ((Sp + 8) - 16 < SpLim) goto c4f2; else goto c4f3;
  c4f2:
      R1 = main9_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4f3:
      P64[Sp - 8] = main1_closure+1;
      Sp = Sp - 8;
      call runMainIO1_entry() args: 16, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-01 18:36:32.316194 UTC

{offset
  c4f1:
      if ((Sp + -8) < SpLim) goto c4f2; else goto c4f3;
  c4f2:
      R1 = main9_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4f3:
      P64[Sp - 8] = main1_closure+1;
      Sp = Sp - 8;
      call runMainIO1_entry() args: 16, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-01 18:36:32.317684 UTC

[(c4f1, {runMainIO1_closure, main1_closure, main9_closure}),
 (c4f2, {main9_closure}),
 (c4f3, {runMainIO1_closure, main1_closure})]


==================== procpoint map ====================
2016-08-01 18:36:32.318814 UTC

[(c4f1, <procpt>), (c4f2, reached by c4f1),
 (c4f3, reached by c4f1)]


==================== Post splitting ====================
2016-08-01 18:36:32.31972 UTC

main9_entry() //  []
        { info_tbl: [(c4f1,
                      label: main9_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4f1:
          if ((Sp + -8) < SpLim) goto c4f2; else goto c4f3;
      c4f2:
          R1 = main9_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c4f3:
          P64[Sp - 8] = main1_closure+1;
          Sp = Sp - 8;
          call runMainIO1_entry() args: 16, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:32.321962 UTC

main9_entry() //  []
        { info_tbl: [(c4f1,
                      label: main9_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4f1:
          if ((Sp + -8) < SpLim) goto c4f2; else goto c4f3;
      c4f2:
          R1 = main9_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c4f3:
          P64[Sp - 8] = main1_closure+1;
          Sp = Sp - 8;
          call runMainIO1_entry() args: 16, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:32.324035 UTC

main9_entry() //  []
        { info_tbl: [(c4f1,
                      label: main9_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4f1:
          if ((Sp + -8) < SpLim) goto c4f2; else goto c4f3;
      c4f2:
          R1 = main9_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c4f3:
          P64[Sp - 8] = main1_closure+1;
          Sp = Sp - 8;
          call runMainIO1_entry() args: 16, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-01 18:36:32.326133 UTC

[section "data" {
     main9_closure:
         const main9_info;
         const 0;
 },
 main9_entry() //  []
         { info_tbl: [(c4f1,
                       label: main9_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4f1:
           if ((Sp + -8) < SpLim) goto c4f2; else goto c4f3;
       c4f2:
           R1 = main9_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4f3:
           P64[Sp - 8] = main1_closure+1;
           Sp = Sp - 8;
           call runMainIO1_entry() args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-01 18:36:32.328655 UTC

[section "data" {
     main9_closure:
         const main9_info;
         const 0;
 },
 main9_entry() //  []
         { info_tbl: [(c4f1,
                       label: main9_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4f1:
           if ((Sp + -8) < SpLim) goto c4f2; else goto c4f3;
       c4f2:
           R1 = main9_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4f3:
           P64[Sp - 8] = main1_closure+1;
           Sp = Sp - 8;
           call runMainIO1_entry() args: 16, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:36:32.345246 UTC

[section "data" {
     main_closure:
         const main_info;
         const 0;
 },
 main_entry() //  []
         { info_tbl: [(c4fI,
                       label: main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4fI:
           goto c4fG;
       c4fG:
           if ((old + 0) - <highSp> < SpLim) goto c4fJ; else goto c4fK;
       c4fJ:
           R1 = main_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4fK:
           goto c4fF;
       c4fF:
           call main9_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-01 18:36:32.348072 UTC

{offset
  c4fI:
      if ((old + 0) - <highSp> < SpLim) goto c4fJ; else goto c4fK;
  c4fJ:
      R1 = main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4fK:
      call main9_entry() args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-01 18:36:32.349516 UTC

{offset
  c4fI:
      if ((old + 0) - <highSp> < SpLim) goto c4fJ; else goto c4fK;
  c4fJ:
      R1 = main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4fK:
      call main9_entry() args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-01 18:36:32.350788 UTC

main_entry
[c4fI]
{offset
  c4fI:
      if ((old + 0) - <highSp> < SpLim) goto c4fJ; else goto c4fK;
  c4fJ:
      R1 = main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4fK:
      call main9_entry() args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-01 18:36:32.35255 UTC

{offset
  c4fI:
      goto c4fK;
  c4fK:
      call main9_entry() args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-01 18:36:32.353526 UTC

{offset
  c4fI:
      goto c4fK;
  c4fK:
      call main9_entry() args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-01 18:36:32.354398 UTC

[(c4fI, {main9_closure}), (c4fK, {main9_closure})]


==================== procpoint map ====================
2016-08-01 18:36:32.355223 UTC

[(c4fI, <procpt>), (c4fK, reached by c4fI)]


==================== Post splitting ====================
2016-08-01 18:36:32.356024 UTC

main_entry() //  []
        { info_tbl: [(c4fI,
                      label: main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4fI:
          goto c4fK;
      c4fK:
          call main9_entry() args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:32.357492 UTC

main_entry() //  []
        { info_tbl: [(c4fI,
                      label: main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4fI:
          goto c4fK;
      c4fK:
          call main9_entry() args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:32.358874 UTC

main_entry() //  []
        { info_tbl: [(c4fI,
                      label: main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4fI:
          call main9_entry() args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-01 18:36:32.360234 UTC

[section "data" {
     main_closure:
         const main_info;
         const 0;
 },
 main_entry() //  []
         { info_tbl: [(c4fI,
                       label: main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4fI:
           call main9_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-01 18:36:32.361999 UTC

[section "data" {
     main_closure:
         const main_info;
         const 0;
 },
 main_entry() //  []
         { info_tbl: [(c4fI,
                       label: main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4fI:
           call main9_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:36:32.368979 UTC

[section "data" {
     Foo_closure:
         const Foo_info;
 },
 Foo_entry() //  []
         { info_tbl: [(c4fR,
                       label: Foo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 16 updfr_space: Just 8
         }
     {offset
       c4fR:
           _B1::P64 = P64[(old + 16)];
           goto c4fO;
       c4fO:
           if ((old + 0) - <highSp> < SpLim) goto c4fS; else goto c4fT;
       c4fT:
           goto c4fN;
       c4fN:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c4fV; else goto c4fU;
       c4fV:
           HpAlloc = 16;
           goto c4fS;
       c4fS:
           R1 = Foo_closure;
           P64[(old + 16)] = _B1::P64;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c4fU:
           I64[Hp - 8] = Foo_con_info;
           P64[Hp] = _B1::P64;
           _c4fQ::P64 = Hp - 7;
           R1 = _c4fQ::P64;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-01 18:36:32.373277 UTC

{offset
  c4fR:
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c4fS; else goto c4fT;
  c4fT:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c4fV; else goto c4fU;
  c4fV:
      HpAlloc = 16;
      goto c4fS;
  c4fS:
      R1 = Foo_closure;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c4fU:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c4fQ::P64 = Hp - 7;
      R1 = _c4fQ::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-01 18:36:32.375967 UTC

{offset
  c4fR:
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c4fS; else goto c4fT;
  c4fT:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c4fV; else goto c4fU;
  c4fV:
      HpAlloc = 16;
      goto c4fS;
  c4fS:
      R1 = Foo_closure;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c4fU:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c4fQ::P64 = Hp - 7;
      R1 = _c4fQ::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-01 18:36:32.378393 UTC

Foo_entry
[c4fR]
{offset
  c4fR:
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c4fS; else goto c4fT;
  c4fT:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c4fV; else goto c4fU;
  c4fV:
      HpAlloc = 16;
      goto c4fS;
  c4fS:
      R1 = Foo_closure;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c4fU:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c4fQ::P64 = Hp - 7;
      R1 = _c4fQ::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-01 18:36:32.381515 UTC

{offset
  c4fR:
      _B1::P64 = P64[Sp];
      goto c4fT;
  c4fT:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c4fV; else goto c4fU;
  c4fV:
      HpAlloc = 16;
      goto c4fS;
  c4fS:
      R1 = Foo_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c4fU:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c4fQ::P64 = Hp - 7;
      R1 = _c4fQ::P64;
      Sp = Sp + 8;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-01 18:36:32.38502 UTC

{offset
  c4fR:
      goto c4fT;
  c4fT:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c4fV; else goto c4fU;
  c4fV:
      HpAlloc = 16;
      goto c4fS;
  c4fS:
      R1 = Foo_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c4fU:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = P64[Sp];
      R1 = Hp - 7;
      Sp = Sp + 8;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-01 18:36:32.38696 UTC

[(c4fR, {}), (c4fS, {}), (c4fT, {}), (c4fU, {}), (c4fV, {})]


==================== procpoint map ====================
2016-08-01 18:36:32.387918 UTC

[(c4fR, <procpt>), (c4fS, reached by c4fR),
 (c4fT, reached by c4fR), (c4fU, reached by c4fR),
 (c4fV, reached by c4fR)]


==================== Post splitting ====================
2016-08-01 18:36:32.388986 UTC

Foo_entry() //  []
        { info_tbl: [(c4fR,
                      label: Foo_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4fR:
          goto c4fT;
      c4fT:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c4fV; else goto c4fU;
      c4fV:
          HpAlloc = 16;
          goto c4fS;
      c4fS:
          R1 = Foo_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c4fU:
          I64[Hp - 8] = Foo_con_info;
          P64[Hp] = P64[Sp];
          R1 = Hp - 7;
          Sp = Sp + 8;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:32.391844 UTC

Foo_entry() //  []
        { info_tbl: [(c4fR,
                      label: Foo_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4fR:
          goto c4fT;
      c4fT:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c4fV; else goto c4fU;
      c4fV:
          HpAlloc = 16;
          goto c4fS;
      c4fS:
          R1 = Foo_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c4fU:
          I64[Hp - 8] = Foo_con_info;
          P64[Hp] = P64[Sp];
          R1 = Hp - 7;
          Sp = Sp + 8;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:32.394352 UTC

Foo_entry() //  []
        { info_tbl: [(c4fR,
                      label: Foo_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4fR:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c4fV; else goto c4fU;
      c4fV:
          HpAlloc = 16;
          R1 = Foo_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c4fU:
          I64[Hp - 8] = Foo_con_info;
          P64[Hp] = P64[Sp];
          R1 = Hp - 7;
          Sp = Sp + 8;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-01 18:36:32.396786 UTC

[section "data" {
     Foo_closure:
         const Foo_info;
 },
 Foo_entry() //  []
         { info_tbl: [(c4fR,
                       label: Foo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4fR:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c4fV; else goto c4fU;
       c4fV:
           HpAlloc = 16;
           R1 = Foo_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c4fU:
           I64[Hp - 8] = Foo_con_info;
           P64[Hp] = P64[Sp];
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-01 18:36:32.399414 UTC

[section "data" {
     Foo_closure:
         const Foo_info;
 },
 Foo_entry() //  []
         { info_tbl: [(c4fR,
                       label: Foo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4fR:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c4fV; else goto c4fU;
       c4fV:
           HpAlloc = 16;
           R1 = Foo_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c4fU:
           I64[Hp - 8] = Foo_con_info;
           P64[Hp] = P64[Sp];
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-01 18:36:32.421173 UTC

[Foo_con_entry() //  []
         { info_tbl: [(c4h6,
                       label: Foo_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4h6:
           R1 = R1 + 1;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foo_static_entry() //  []
         { info_tbl: [(c4h7,
                       label: Foo_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4h7:
           R1 = R1 + 1;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-01 18:36:32.424662 UTC

{offset
  c4h6:
      R1 = R1 + 1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-01 18:36:32.425775 UTC

{offset
  c4h6:
      R1 = R1 + 1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-01 18:36:32.426767 UTC

Foo_con_entry
[c4h6]
{offset
  c4h6:
      R1 = R1 + 1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-01 18:36:32.428015 UTC

{offset
  c4h6:
      R1 = R1 + 1;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-01 18:36:32.429084 UTC

{offset
  c4h6:
      R1 = R1 + 1;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-01 18:36:32.43004 UTC

[(c4h6, {})]


==================== procpoint map ====================
2016-08-01 18:36:32.430731 UTC

[(c4h6, <procpt>)]


==================== Post splitting ====================
2016-08-01 18:36:32.431504 UTC

Foo_con_entry() //  [R1]
        { info_tbl: [(c4h6,
                      label: Foo_con_info
                      rep:HeapRep 1 ptrs {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4h6:
          R1 = R1 + 1;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:32.433215 UTC

Foo_con_entry() //  [R1]
        { info_tbl: [(c4h6,
                      label: Foo_con_info
                      rep:HeapRep 1 ptrs {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4h6:
          R1 = R1 + 1;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:32.435664 UTC

Foo_con_entry() //  [R1]
        { info_tbl: [(c4h6,
                      label: Foo_con_info
                      rep:HeapRep 1 ptrs {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4h6:
          R1 = R1 + 1;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:32.437421 UTC

{offset
  c4h7:
      R1 = R1 + 1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-01 18:36:32.438508 UTC

{offset
  c4h7:
      R1 = R1 + 1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-01 18:36:32.439491 UTC

Foo_static_entry
[c4h7]
{offset
  c4h7:
      R1 = R1 + 1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-01 18:36:32.440711 UTC

{offset
  c4h7:
      R1 = R1 + 1;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-01 18:36:32.441842 UTC

{offset
  c4h7:
      R1 = R1 + 1;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-01 18:36:32.442785 UTC

[(c4h7, {})]


==================== procpoint map ====================
2016-08-01 18:36:32.443463 UTC

[(c4h7, <procpt>)]


==================== Post splitting ====================
2016-08-01 18:36:32.444151 UTC

Foo_static_entry() //  [R1]
        { info_tbl: [(c4h7,
                      label: Foo_static_info
                      rep:HeapRep static {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4h7:
          R1 = R1 + 1;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-01 18:36:32.445803 UTC

Foo_static_entry() //  [R1]
        { info_tbl: [(c4h7,
                      label: Foo_static_info
                      rep:HeapRep static {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4h7:
          R1 = R1 + 1;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-01 18:36:32.447379 UTC

Foo_static_entry() //  [R1]
        { info_tbl: [(c4h7,
                      label: Foo_static_info
                      rep:HeapRep static {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4h7:
          R1 = R1 + 1;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-01 18:36:32.448975 UTC

[Foo_con_entry() //  [R1]
         { info_tbl: [(c4h6,
                       label: Foo_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4h6:
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foo_static_entry() //  [R1]
         { info_tbl: [(c4h7,
                       label: Foo_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4h7:
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-01 18:36:32.452097 UTC

[Foo_con_entry() //  [R1]
         { info_tbl: [(c4h6,
                       label: Foo_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4h6:
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foo_static_entry() //  [R1]
         { info_tbl: [(c4h7,
                       label: Foo_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4h7:
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-01 18:36:32.471341 UTC

[section "relreadonly" {
     S3IJ_srt:
         const $fShowFoo2_closure;
         const $w$cshowsPrec_closure;
         const $fShowFoo1_closure;
         const $fShowFoo_$cshowList_closure;
         const $fShowFoo_$cshow_closure;
         const showLitString_closure;
         const main8_closure;
         const childHandler1_closure;
         const hPutStr2_closure;
         const stdout_closure;
         const main1_closure;
         const main5_closure;
         const runMainIO1_closure;
         const main9_closure;
 }]

