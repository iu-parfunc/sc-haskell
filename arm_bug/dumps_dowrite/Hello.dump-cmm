
==================== Cmm produced by new codegen ====================
2016-08-04 14:10:08.249641 UTC

[section "data" { __stginit_main@main:Main:
 }]


==================== Post CPS Cmm ====================
2016-08-04 14:10:08.25297 UTC

[section "data" { __stginit_main@main:Main:
 }]


==================== Output Cmm ====================
2016-08-04 14:10:08.253744 UTC

[section "data" { __stginit_main@main:Main:
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:10:08.258881 UTC

[section "data" {
     $fShowFoo2_closure:
         const $fShowFoo2_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     c3Hb_str:
         I8[] [70,111,111,32]
 },
 $fShowFoo2_entry() //  [R1]
         { info_tbl: [(c3Hc,
                       label: $fShowFoo2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c3Hc:
           _r3EA::P64 = R1;
           goto c3H6;
       c3H6:
           if ((old + 0) - <highSp> < SpLim) goto c3Hd; else goto c3He;
       c3Hd:
           R1 = _r3EA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3He:
           (_c3H8::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3EA::P64);
           if (_c3H8::I64 == 0) goto c3Ha; else goto c3H9;
       c3Ha:
           call (I64[I64[_r3EA::P64]])() args: 8, res: 0, upd: 8;
       c3H9:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _c3H8::I64;
           I64[(old + 32)] = c3Hb_str;
           call unpackCString#_entry() args: 32, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:10:08.277331 UTC

{offset
  c3Hc:
      _r3EA::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3Hd; else goto c3He;
  c3Hd:
      R1 = _r3EA::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3He:
      (_c3H8::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3EA::P64);
      if (_c3H8::I64 == 0) goto c3Ha; else goto c3H9;
  c3Ha:
      call (I64[I64[_r3EA::P64]])() args: 8, res: 0, upd: 8;
  c3H9:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c3H8::I64;
      I64[(old + 32)] = c3Hb_str;
      call unpackCString#_entry() args: 32, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2016-08-04 14:10:08.280251 UTC

{offset
  c3Hc:
      _r3EA::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3Hd; else goto c3He;
  c3Hd:
      R1 = _r3EA::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3He:
      (_c3H8::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3EA::P64);
      if (_c3H8::I64 == 0) goto c3Ha; else goto c3H9;
  c3Ha:
      call (I64[I64[_r3EA::P64]])() args: 8, res: 0, upd: 8;
  c3H9:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c3H8::I64;
      I64[(old + 32)] = c3Hb_str;
      call unpackCString#_entry() args: 32, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-04 14:10:08.285199 UTC

$fShowFoo2_entry
[c3Hc]
{offset
  c3Hc:
      _r3EA::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3Hd; else goto c3He;
  c3Hd:
      R1 = _r3EA::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3He:
      (_c3H8::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3EA::P64);
      if (_c3H8::I64 == 0) goto c3Ha; else goto c3H9;
  c3Ha:
      call (I64[I64[_r3EA::P64]])() args: 8, res: 0, upd: 8;
  c3H9:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c3H8::I64;
      I64[(old + 32)] = c3Hb_str;
      call unpackCString#_entry() args: 32, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-04 14:10:08.289923 UTC

{offset
  c3Hc:
      _r3EA::P64 = R1;
      if ((Sp + 8) - 32 < SpLim) goto c3Hd; else goto c3He;
  c3Hd:
      R1 = _r3EA::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3He:
      (_c3H8::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3EA::P64);
      if (_c3H8::I64 == 0) goto c3Ha; else goto c3H9;
  c3Ha:
      call (I64[I64[_r3EA::P64]])() args: 8, res: 0, upd: 8;
  c3H9:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _c3H8::I64;
      I64[Sp - 24] = c3Hb_str;
      Sp = Sp - 24;
      call unpackCString#_entry() args: 32, res: 0, upd: 24;
}


==================== Sink assignments ====================
2016-08-04 14:10:08.293659 UTC

{offset
  c3Hc:
      if ((Sp + -24) < SpLim) goto c3Hd; else goto c3He;
  c3Hd:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3He:
      (_c3H8::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
      if (_c3H8::I64 == 0) goto c3Ha; else goto c3H9;
  c3Ha:
      call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
  c3H9:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _c3H8::I64;
      I64[Sp - 24] = c3Hb_str;
      Sp = Sp - 24;
      call unpackCString#_entry() args: 32, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-04 14:10:08.296133 UTC

[(c3H9, {}), (c3Ha, {}), (c3Hc, {}), (c3Hd, {}), (c3He, {})]


==================== procpoint map ====================
2016-08-04 14:10:08.297175 UTC

[(c3H9, reached by c3Hc), (c3Ha, reached by c3Hc),
 (c3Hc, <procpt>), (c3Hd, reached by c3Hc), (c3He, reached by c3Hc)]


==================== Post splitting ====================
2016-08-04 14:10:08.298293 UTC

$fShowFoo2_entry() //  [R1]
        { info_tbl: [(c3Hc,
                      label: $fShowFoo2_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Hc:
          if ((Sp + -24) < SpLim) goto c3Hd; else goto c3He;
      c3Hd:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3He:
          (_c3H8::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
          if (_c3H8::I64 == 0) goto c3Ha; else goto c3H9;
      c3Ha:
          call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
      c3H9:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c3H8::I64;
          I64[Sp - 24] = c3Hb_str;
          Sp = Sp - 24;
          call unpackCString#_entry() args: 32, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:08.301689 UTC

$fShowFoo2_entry() //  [R1]
        { info_tbl: [(c3Hc,
                      label: $fShowFoo2_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Hc:
          if ((Sp + -24) < SpLim) goto c3Hd; else goto c3He;
      c3Hd:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3He:
          (_c3H8::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
          if (_c3H8::I64 == 0) goto c3Ha; else goto c3H9;
      c3Ha:
          call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
      c3H9:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c3H8::I64;
          I64[Sp - 24] = c3Hb_str;
          Sp = Sp - 24;
          call unpackCString#_entry() args: 32, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:08.304681 UTC

$fShowFoo2_entry() //  [R1]
        { info_tbl: [(c3Hc,
                      label: $fShowFoo2_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Hc:
          if ((Sp + -24) < SpLim) goto c3Hd; else goto c3He;
      c3Hd:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3He:
          (_c3H8::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
          if (_c3H8::I64 == 0) goto c3Ha; else goto c3H9;
      c3Ha:
          call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
      c3H9:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c3H8::I64;
          I64[Sp - 24] = c3Hb_str;
          Sp = Sp - 24;
          call unpackCString#_entry() args: 32, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:10:08.307768 UTC

[section "data" {
     $fShowFoo2_closure:
         const $fShowFoo2_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     c3Hb_str:
         I8[] [70,111,111,32]
 },
 $fShowFoo2_entry() //  [R1]
         { info_tbl: [(c3Hc,
                       label: $fShowFoo2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Hc:
           if ((Sp + -24) < SpLim) goto c3Hd; else goto c3He;
       c3Hd:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3He:
           (_c3H8::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c3H8::I64 == 0) goto c3Ha; else goto c3H9;
       c3Ha:
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c3H9:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c3H8::I64;
           I64[Sp - 24] = c3Hb_str;
           Sp = Sp - 24;
           call unpackCString#_entry() args: 32, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:10:08.31168 UTC

[section "data" {
     $fShowFoo2_closure:
         const $fShowFoo2_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     c3Hb_str:
         I8[] [70,111,111,32]
 },
 $fShowFoo2_entry() //  [R1]
         { info_tbl: [(c3Hc,
                       label: $fShowFoo2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Hc:
           if ((Sp + -24) < SpLim) goto c3Hd; else goto c3He;
       c3Hd:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3He:
           (_c3H8::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c3H8::I64 == 0) goto c3Ha; else goto c3H9;
       c3Ha:
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c3H9:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c3H8::I64;
           I64[Sp - 24] = c3Hb_str;
           Sp = Sp - 24;
           call unpackCString#_entry() args: 32, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:10:08.340476 UTC

[section "data" {
     $w$cshowsPrec_closure:
         const $w$cshowsPrec_info;
         const 0;
 },
 sat_s3Fj_entry() //  [R1]
         { info_tbl: [(c3IH,
                       label: sat_s3Fj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c3IH:
           _s3Fj::P64 = R1;
           goto c3IC;
       c3IC:
           if ((old + 0) - <highSp> < SpLim) goto c3IN; else goto c3IO;
       c3IN:
           R1 = _s3Fj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3IO:
           _s3Fa::P64 = P64[_s3Fj::P64 + 16];
           _s3Fb::P64 = P64[_s3Fj::P64 + 24];
           I64[(young<c3IE> + 8)] = c3IE;
           R1 = _s3Fa::P64;
           if (R1 & 7 != 0) goto c3IE; else goto c3IF;
       c3IF:
           call (I64[I64[R1]])(R1) returns to c3IE, args: 8, res: 8, upd: 8;
       c3IE:
           _s3Fe::P64 = R1;
           _s3Ff::I64 = I64[_s3Fe::P64 + 7];
           I64[(young<c3IK> + 8)] = c3IK;
           I64[(young<c3IK> + 32)] = 11;
           I64[(young<c3IK> + 24)] = _s3Ff::I64;
           P64[(young<c3IK> + 16)] = _s3Fb::P64;
           call $wshowSignedInt_entry() returns to c3IK, args: 32, res: 16, upd: 8;
       c3IK:
           _s3Fh::P64 = R1;
           _s3Fi::P64 = P64[(young<c3IK> + 16)];
           Hp = Hp + 24;
           if (Hp > HpLim) goto c3IS; else goto c3IR;
       c3IS:
           HpAlloc = 24;
           goto c3IQ;
       c3IQ:
           R1 = _s3Fh::P64;
           P64[(young<c3IK> + 16)] = _s3Fi::P64;
           call stg_gc_pp(R1) returns to c3IK, args: 16, res: 16, upd: 8;
       c3IR:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _s3Fh::P64;
           P64[Hp] = _s3Fi::P64;
           _c3IM::P64 = Hp - 14;
           R1 = _c3IM::P64;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s3Fq_entry() //  [R1]
         { info_tbl: [(c3J5,
                       label: sat_s3Fq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c3J5:
           _s3Fq::P64 = R1;
           goto c3J0;
       c3J0:
           if ((old + 0) - <highSp> < SpLim) goto c3Jc; else goto c3Jd;
       c3Jc:
           R1 = _s3Fq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3Jd:
           _s3Fa::P64 = P64[_s3Fq::P64 + 16];
           _s3Fb::P64 = P64[_s3Fq::P64 + 24];
           I64[(young<c3J2> + 8)] = c3J2;
           R1 = _s3Fa::P64;
           if (R1 & 7 != 0) goto c3J2; else goto c3J3;
       c3J3:
           call (I64[I64[R1]])(R1) returns to c3J2, args: 8, res: 8, upd: 8;
       c3J2:
           _s3Fk::P64 = R1;
           Hp = Hp + 24;
           if (Hp > HpLim) goto c3Jg; else goto c3Jf;
       c3Jg:
           HpAlloc = 24;
           goto c3Je;
       c3Je:
           R1 = _s3Fk::P64;
           call stg_gc_unpt_r1(R1) returns to c3J2, args: 8, res: 8, upd: 8;
       c3Jf:
           _s3Fl::I64 = I64[_s3Fk::P64 + 7];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = shows8_closure;
           P64[Hp] = _s3Fb::P64;
           _c3J8::P64 = Hp - 14;
           I64[(young<c3J9> + 8)] = c3J9;
           I64[(young<c3J9> + 32)] = 11;
           I64[(young<c3J9> + 24)] = _s3Fl::I64;
           P64[(young<c3J9> + 16)] = _c3J8::P64;
           call $wshowSignedInt_entry() returns to c3J9, args: 32, res: 16, upd: 8;
       c3J9:
           _s3Fo::P64 = R1;
           _s3Fp::P64 = P64[(young<c3J9> + 16)];
           Hp = Hp + 24;
           if (Hp > HpLim) goto c3Jj; else goto c3Ji;
       c3Jj:
           HpAlloc = 24;
           goto c3Jh;
       c3Jh:
           R1 = _s3Fo::P64;
           P64[(young<c3J9> + 16)] = _s3Fp::P64;
           call stg_gc_pp(R1) returns to c3J9, args: 16, res: 16, upd: 8;
       c3Ji:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _s3Fo::P64;
           P64[Hp] = _s3Fp::P64;
           _c3Jb::P64 = Hp - 14;
           R1 = _c3Jb::P64;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s3Fr_entry() //  [R1]
         { info_tbl: [(c3Jk,
                       label: sat_s3Fr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c3Jk:
           _s3Fr::P64 = R1;
           goto c3IW;
       c3IW:
           if ((old + 0) - <highSp> < SpLim) goto c3Jl; else goto c3Jm;
       c3Jm:
           Hp = Hp + 32;
           if (Hp > HpLim) goto c3Jo; else goto c3Jn;
       c3Jo:
           HpAlloc = 32;
           goto c3Jl;
       c3Jl:
           R1 = _s3Fr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3Jn:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _s3Fr::P64;
           _s3Fa::P64 = P64[_s3Fr::P64 + 16];
           _s3Fb::P64 = P64[_s3Fr::P64 + 24];
           I64[Hp - 24] = sat_s3Fq_info;
           P64[Hp - 8] = _s3Fa::P64;
           P64[Hp] = _s3Fb::P64;
           _c3IY::P64 = Hp - 24;
           P64[(old + 40)] = $fShowFoo2_closure;
           P64[(old + 32)] = _c3IY::P64;
           call ++_entry() args: 40, res: 0, upd: 24;
     }
 },
 $w$cshowsPrec_entry() //  []
         { info_tbl: [(c3Jp,
                       label: $w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 32 updfr_space: Just 8
         }
     {offset
       c3Jp:
           _s3F9::I64 = I64[(old + 32)];
           _s3Fa::P64 = P64[(old + 24)];
           _s3Fb::P64 = P64[(old + 16)];
           goto c3It;
       c3It:
           if ((old + 0) - <highSp> < SpLim) goto c3Jq; else goto c3Jr;
       c3Jr:
           goto c3Is;
       c3Is:
           Hp = Hp + 56;
           if (Hp > HpLim) goto c3Jt; else goto c3Js;
       c3Jt:
           HpAlloc = 56;
           goto c3Jq;
       c3Jq:
           R1 = $w$cshowsPrec_closure;
           I64[(old + 32)] = _s3F9::I64;
           P64[(old + 24)] = _s3Fa::P64;
           P64[(old + 16)] = _s3Fb::P64;
           call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
       c3Js:
           _c3Iv::I64 = %MO_S_Ge_W64(_s3F9::I64, 11);
           _s3Fc::I64 = _c3Iv::I64;
           if (_s3Fc::I64 >= 1) goto c3Jz; else goto c3JA;
       c3Jz:
           goto c3Jx;
       c3Jx:
           I64[Hp - 48] = sat_s3Fr_info;
           P64[Hp - 32] = _s3Fa::P64;
           P64[Hp - 24] = _s3Fb::P64;
           _c3IU::P64 = Hp - 48;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = shows9_closure;
           P64[Hp] = _c3IU::P64;
           _c3Jw::P64 = Hp - 14;
           R1 = _c3Jw::P64;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
       c3JA:
           goto c3Jv;
       c3Jv:
           I64[Hp - 48] = sat_s3Fj_info;
           P64[Hp - 32] = _s3Fa::P64;
           P64[Hp - 24] = _s3Fb::P64;
           _c3IA::P64 = Hp - 48;
           Hp = Hp - 24;
           P64[(old + 24)] = $fShowFoo2_closure;
           P64[(old + 16)] = _c3IA::P64;
           call ++_entry() args: 24, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:10:08.373357 UTC

{offset
  c3IH:
      _s3Fj::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3IN; else goto c3IO;
  c3IN:
      R1 = _s3Fj::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3IO:
      _s3Fa::P64 = P64[_s3Fj::P64 + 16];
      _s3Fb::P64 = P64[_s3Fj::P64 + 24];
      I64[(young<c3IE> + 8)] = c3IE;
      R1 = _s3Fa::P64;
      if (R1 & 7 != 0) goto c3IE; else goto c3IF;
  c3IF:
      call (I64[I64[R1]])(R1) returns to c3IE, args: 8, res: 8, upd: 8;
  c3IE:
      _s3Fe::P64 = R1;
      _s3Ff::I64 = I64[_s3Fe::P64 + 7];
      I64[(young<c3IK> + 8)] = c3IK;
      I64[(young<c3IK> + 32)] = 11;
      I64[(young<c3IK> + 24)] = _s3Ff::I64;
      P64[(young<c3IK> + 16)] = _s3Fb::P64;
      call $wshowSignedInt_entry() returns to c3IK, args: 32, res: 16, upd: 8;
  c3IK:
      _s3Fh::P64 = R1;
      _s3Fi::P64 = P64[(young<c3IK> + 16)];
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3IS; else goto c3IR;
  c3IS:
      HpAlloc = 24;
      R1 = _s3Fh::P64;
      P64[(young<c3IK> + 16)] = _s3Fi::P64;
      call stg_gc_pp(R1) returns to c3IK, args: 16, res: 16, upd: 8;
  c3IR:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _s3Fh::P64;
      P64[Hp] = _s3Fi::P64;
      _c3IM::P64 = Hp - 14;
      R1 = _c3IM::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:10:08.378991 UTC

{offset
  c3IH:
      _s3Fj::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3IN; else goto c3IO;
  c3IN:
      R1 = _s3Fj::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3IO:
      _s3Fa::P64 = P64[_s3Fj::P64 + 16];
      _s3Fb::P64 = P64[_s3Fj::P64 + 24];
      I64[(young<c3IE> + 8)] = c3IE;
      R1 = _s3Fa::P64;
      if (R1 & 7 != 0) goto c3IE; else goto c3IF;
  c3IF:
      call (I64[I64[R1]])(R1) returns to c3IE, args: 8, res: 8, upd: 8;
  c3IE:
      _s3Fe::P64 = R1;
      _s3Ff::I64 = I64[_s3Fe::P64 + 7];
      I64[(young<c3IK> + 8)] = c3IK;
      I64[(young<c3IK> + 32)] = 11;
      I64[(young<c3IK> + 24)] = _s3Ff::I64;
      P64[(young<c3IK> + 16)] = _s3Fb::P64;
      call $wshowSignedInt_entry() returns to c3IK, args: 32, res: 16, upd: 8;
  c3IK:
      _s3Fh::P64 = R1;
      _s3Fi::P64 = P64[(young<c3IK> + 16)];
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3IS; else goto c3IR;
  c3IS:
      HpAlloc = 24;
      R1 = _s3Fh::P64;
      P64[(young<c3IK> + 16)] = _s3Fi::P64;
      call stg_gc_pp(R1) returns to c3IK, args: 16, res: 16, upd: 8;
  c3IR:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _s3Fh::P64;
      P64[Hp] = _s3Fi::P64;
      _c3IM::P64 = Hp - 14;
      R1 = _c3IM::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:10:08.384173 UTC

sat_s3Fj_entry
[c3IE, c3IH, c3IK]
{offset
  c3IH:
      _s3Fj::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3IN; else goto c3IO;
  c3IN:
      R1 = _s3Fj::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3IO:
      _s3Fa::P64 = P64[_s3Fj::P64 + 16];
      _s3Fb::P64 = P64[_s3Fj::P64 + 24];
      I64[(young<c3IE> + 8)] = c3IE;
      R1 = _s3Fa::P64;
      if (R1 & 7 != 0) goto c3IE; else goto c3IF;
  c3IF:
      call (I64[I64[R1]])(R1) returns to c3IE, args: 8, res: 8, upd: 8;
  c3IE:
      _s3Fe::P64 = R1;
      _s3Ff::I64 = I64[_s3Fe::P64 + 7];
      I64[(young<c3IK> + 8)] = c3IK;
      I64[(young<c3IK> + 32)] = 11;
      I64[(young<c3IK> + 24)] = _s3Ff::I64;
      P64[(young<c3IK> + 16)] = _s3Fb::P64;
      call $wshowSignedInt_entry() returns to c3IK, args: 32, res: 16, upd: 8;
  c3IK:
      _s3Fh::P64 = R1;
      _s3Fi::P64 = P64[(young<c3IK> + 16)];
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3IS; else goto c3IR;
  c3IS:
      HpAlloc = 24;
      R1 = _s3Fh::P64;
      P64[(young<c3IK> + 16)] = _s3Fi::P64;
      call stg_gc_pp(R1) returns to c3IK, args: 16, res: 16, upd: 8;
  c3IR:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _s3Fh::P64;
      P64[Hp] = _s3Fi::P64;
      _c3IM::P64 = Hp - 14;
      R1 = _c3IM::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:10:08.390666 UTC

{offset
  c3IH:
      _s3Fj::P64 = R1;
      if ((Sp + 8) - 40 < SpLim) goto c3IN; else goto c3IO;
  c3IN:
      R1 = _s3Fj::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3IO:
      _s3Fa::P64 = P64[_s3Fj::P64 + 16];
      _s3Fb::P64 = P64[_s3Fj::P64 + 24];
      I64[Sp - 16] = c3IE;
      R1 = _s3Fa::P64;
      P64[Sp - 8] = _s3Fb::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto c3IE; else goto c3IF;
  c3IF:
      call (I64[I64[R1]])(R1) returns to c3IE, args: 8, res: 8, upd: 8;
  c3IE:
      _s3Fb::P64 = P64[Sp + 8];
      _s3Fe::P64 = R1;
      _s3Ff::I64 = I64[_s3Fe::P64 + 7];
      I64[Sp + 8] = c3IK;
      I64[Sp - 16] = 11;
      I64[Sp - 8] = _s3Ff::I64;
      P64[Sp] = _s3Fb::P64;
      Sp = Sp - 16;
      call $wshowSignedInt_entry() returns to c3IK, args: 32, res: 16, upd: 8;
  c3IK:
      _s3Fh::P64 = R1;
      _s3Fi::P64 = P64[Sp];
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3IS; else goto c3IR;
  c3IS:
      HpAlloc = 24;
      R1 = _s3Fh::P64;
      call stg_gc_pp(R1) returns to c3IK, args: 16, res: 16, upd: 8;
  c3IR:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _s3Fh::P64;
      P64[Hp] = _s3Fi::P64;
      _c3IM::P64 = Hp - 14;
      R1 = _c3IM::P64;
      Sp = Sp + 16;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:10:08.397036 UTC

{offset
  c3IH:
      if ((Sp + -32) < SpLim) goto c3IN; else goto c3IO;
  c3IN:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3IO:
      I64[Sp - 16] = c3IE;
      _s3Fb::P64 = P64[R1 + 24];
      R1 = P64[R1 + 16];
      P64[Sp - 8] = _s3Fb::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto c3IE; else goto c3IF;
  c3IF:
      call (I64[I64[R1]])(R1) returns to c3IE, args: 8, res: 8, upd: 8;
  c3IE:
      _s3Fb::P64 = P64[Sp + 8];
      I64[Sp + 8] = c3IK;
      I64[Sp - 16] = 11;
      I64[Sp - 8] = I64[R1 + 7];
      P64[Sp] = _s3Fb::P64;
      Sp = Sp - 16;
      call $wshowSignedInt_entry() returns to c3IK, args: 32, res: 16, upd: 8;
  c3IK:
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3IS; else goto c3IR;
  c3IS:
      HpAlloc = 24;
      R1 = R1;
      call stg_gc_pp(R1) returns to c3IK, args: 16, res: 16, upd: 8;
  c3IR:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = R1;
      P64[Hp] = P64[Sp];
      R1 = Hp - 14;
      Sp = Sp + 16;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:10:08.401554 UTC

[(c3IE, {}), (c3IF, {}), (c3IH, {}), (c3IK, {}), (c3IN, {}),
 (c3IO, {}), (c3IR, {}), (c3IS, {})]


==================== procpoint map ====================
2016-08-04 14:10:08.402805 UTC

[(c3IE, <procpt>), (c3IF, reached by c3IH), (c3IH, <procpt>),
 (c3IK, <procpt>), (c3IN, reached by c3IH), (c3IO, reached by c3IH),
 (c3IR, reached by c3IK), (c3IS, reached by c3IK)]


==================== Post splitting ====================
2016-08-04 14:10:08.404155 UTC

sat_s3Fj_entry() //  [R1]
        { info_tbl: [(c3IH,
                      label: sat_s3Fj_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3IH:
          if ((Sp + -32) < SpLim) goto c3IN; else goto c3IO;
      c3IN:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3IO:
          I64[Sp - 16] = block_c3IE_info;
          _s3Fb::P64 = P64[R1 + 24];
          R1 = P64[R1 + 16];
          P64[Sp - 8] = _s3Fb::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto u3JB; else goto c3IF;
      u3JB:
          call block_c3IE_entry(R1) args: 0, res: 0, upd: 0;
      c3IF:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-04 14:10:08.407534 UTC

block_c3IE_entry() //  [R1]
        { info_tbl: [(c3IE,
                      label: block_c3IE_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3IE:
          _s3Fb::P64 = P64[Sp + 8];
          I64[Sp + 8] = block_c3IK_info;
          I64[Sp - 16] = 11;
          I64[Sp - 8] = I64[R1 + 7];
          P64[Sp] = _s3Fb::P64;
          Sp = Sp - 16;
          call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-04 14:10:08.409645 UTC

block_c3IK_entry() //  [R1]
        { info_tbl: [(c3IK,
                      label: block_c3IK_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3IK:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c3IS; else goto c3IR;
      c3IS:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
      c3IR:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = P64[Sp];
          R1 = Hp - 14;
          Sp = Sp + 16;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:08.412162 UTC

sat_s3Fj_entry() //  [R1]
        { info_tbl: [(c3IH,
                      label: sat_s3Fj_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3IH:
          if ((Sp + -32) < SpLim) goto c3IN; else goto c3IO;
      c3IN:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3IO:
          I64[Sp - 16] = block_c3IE_info;
          _s3Fb::P64 = P64[R1 + 24];
          R1 = P64[R1 + 16];
          P64[Sp - 8] = _s3Fb::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto u3JB; else goto c3IF;
      u3JB:
          call block_c3IE_entry(R1) args: 0, res: 0, upd: 0;
      c3IF:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:08.415116 UTC

block_c3IE_entry() //  [R1]
        { info_tbl: [(c3IE,
                      label: block_c3IE_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3IE:
          _s3Fb::P64 = P64[Sp + 8];
          I64[Sp + 8] = block_c3IK_info;
          I64[Sp - 16] = 11;
          I64[Sp - 8] = I64[R1 + 7];
          P64[Sp] = _s3Fb::P64;
          Sp = Sp - 16;
          call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:08.417196 UTC

block_c3IK_entry() //  [R1]
        { info_tbl: [(c3IK,
                      label: block_c3IK_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3IK:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c3IS; else goto c3IR;
      c3IS:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
      c3IR:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = P64[Sp];
          R1 = Hp - 14;
          Sp = Sp + 16;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:08.419658 UTC

sat_s3Fj_entry() //  [R1]
        { info_tbl: [(c3IH,
                      label: sat_s3Fj_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3IH:
          if ((Sp + -32) < SpLim) goto c3IN; else goto c3IO;
      c3IN:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3IO:
          I64[Sp - 16] = block_c3IE_info;
          _s3Fb::P64 = P64[R1 + 24];
          R1 = P64[R1 + 16];
          P64[Sp - 8] = _s3Fb::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto u3JB; else goto c3IF;
      u3JB:
          call block_c3IE_entry(R1) args: 0, res: 0, upd: 0;
      c3IF:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:08.422733 UTC

block_c3IE_entry() //  [R1]
        { info_tbl: [(c3IE,
                      label: block_c3IE_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3IE:
          _s3Fb::P64 = P64[Sp + 8];
          I64[Sp + 8] = block_c3IK_info;
          I64[Sp - 16] = 11;
          I64[Sp - 8] = I64[R1 + 7];
          P64[Sp] = _s3Fb::P64;
          Sp = Sp - 16;
          call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:08.424828 UTC

block_c3IK_entry() //  [R1]
        { info_tbl: [(c3IK,
                      label: block_c3IK_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3IK:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c3IS; else goto c3IR;
      c3IS:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
      c3IR:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = P64[Sp];
          R1 = Hp - 14;
          Sp = Sp + 16;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:08.42786 UTC

{offset
  c3J5:
      _s3Fq::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3Jc; else goto c3Jd;
  c3Jc:
      R1 = _s3Fq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3Jd:
      _s3Fa::P64 = P64[_s3Fq::P64 + 16];
      _s3Fb::P64 = P64[_s3Fq::P64 + 24];
      I64[(young<c3J2> + 8)] = c3J2;
      R1 = _s3Fa::P64;
      if (R1 & 7 != 0) goto c3J2; else goto c3J3;
  c3J3:
      call (I64[I64[R1]])(R1) returns to c3J2, args: 8, res: 8, upd: 8;
  c3J2:
      _s3Fk::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3Jg; else goto c3Jf;
  c3Jg:
      HpAlloc = 24;
      R1 = _s3Fk::P64;
      call stg_gc_unpt_r1(R1) returns to c3J2, args: 8, res: 8, upd: 8;
  c3Jf:
      _s3Fl::I64 = I64[_s3Fk::P64 + 7];
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows8_closure;
      P64[Hp] = _s3Fb::P64;
      _c3J8::P64 = Hp - 14;
      I64[(young<c3J9> + 8)] = c3J9;
      I64[(young<c3J9> + 32)] = 11;
      I64[(young<c3J9> + 24)] = _s3Fl::I64;
      P64[(young<c3J9> + 16)] = _c3J8::P64;
      call $wshowSignedInt_entry() returns to c3J9, args: 32, res: 16, upd: 8;
  c3J9:
      _s3Fo::P64 = R1;
      _s3Fp::P64 = P64[(young<c3J9> + 16)];
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3Jj; else goto c3Ji;
  c3Jj:
      HpAlloc = 24;
      R1 = _s3Fo::P64;
      P64[(young<c3J9> + 16)] = _s3Fp::P64;
      call stg_gc_pp(R1) returns to c3J9, args: 16, res: 16, upd: 8;
  c3Ji:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _s3Fo::P64;
      P64[Hp] = _s3Fp::P64;
      _c3Jb::P64 = Hp - 14;
      R1 = _c3Jb::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:10:08.434728 UTC

{offset
  c3J5:
      _s3Fq::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3Jc; else goto c3Jd;
  c3Jc:
      R1 = _s3Fq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3Jd:
      _s3Fa::P64 = P64[_s3Fq::P64 + 16];
      _s3Fb::P64 = P64[_s3Fq::P64 + 24];
      I64[(young<c3J2> + 8)] = c3J2;
      R1 = _s3Fa::P64;
      if (R1 & 7 != 0) goto c3J2; else goto c3J3;
  c3J3:
      call (I64[I64[R1]])(R1) returns to c3J2, args: 8, res: 8, upd: 8;
  c3J2:
      _s3Fk::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3Jg; else goto c3Jf;
  c3Jg:
      HpAlloc = 24;
      R1 = _s3Fk::P64;
      call stg_gc_unpt_r1(R1) returns to c3J2, args: 8, res: 8, upd: 8;
  c3Jf:
      _s3Fl::I64 = I64[_s3Fk::P64 + 7];
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows8_closure;
      P64[Hp] = _s3Fb::P64;
      _c3J8::P64 = Hp - 14;
      I64[(young<c3J9> + 8)] = c3J9;
      I64[(young<c3J9> + 32)] = 11;
      I64[(young<c3J9> + 24)] = _s3Fl::I64;
      P64[(young<c3J9> + 16)] = _c3J8::P64;
      call $wshowSignedInt_entry() returns to c3J9, args: 32, res: 16, upd: 8;
  c3J9:
      _s3Fo::P64 = R1;
      _s3Fp::P64 = P64[(young<c3J9> + 16)];
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3Jj; else goto c3Ji;
  c3Jj:
      HpAlloc = 24;
      R1 = _s3Fo::P64;
      P64[(young<c3J9> + 16)] = _s3Fp::P64;
      call stg_gc_pp(R1) returns to c3J9, args: 16, res: 16, upd: 8;
  c3Ji:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _s3Fo::P64;
      P64[Hp] = _s3Fp::P64;
      _c3Jb::P64 = Hp - 14;
      R1 = _c3Jb::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:10:08.440954 UTC

sat_s3Fq_entry
[c3J2, c3J5, c3J9]
{offset
  c3J5:
      _s3Fq::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3Jc; else goto c3Jd;
  c3Jc:
      R1 = _s3Fq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3Jd:
      _s3Fa::P64 = P64[_s3Fq::P64 + 16];
      _s3Fb::P64 = P64[_s3Fq::P64 + 24];
      I64[(young<c3J2> + 8)] = c3J2;
      R1 = _s3Fa::P64;
      if (R1 & 7 != 0) goto c3J2; else goto c3J3;
  c3J3:
      call (I64[I64[R1]])(R1) returns to c3J2, args: 8, res: 8, upd: 8;
  c3J2:
      _s3Fk::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3Jg; else goto c3Jf;
  c3Jg:
      HpAlloc = 24;
      R1 = _s3Fk::P64;
      call stg_gc_unpt_r1(R1) returns to c3J2, args: 8, res: 8, upd: 8;
  c3Jf:
      _s3Fl::I64 = I64[_s3Fk::P64 + 7];
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows8_closure;
      P64[Hp] = _s3Fb::P64;
      _c3J8::P64 = Hp - 14;
      I64[(young<c3J9> + 8)] = c3J9;
      I64[(young<c3J9> + 32)] = 11;
      I64[(young<c3J9> + 24)] = _s3Fl::I64;
      P64[(young<c3J9> + 16)] = _c3J8::P64;
      call $wshowSignedInt_entry() returns to c3J9, args: 32, res: 16, upd: 8;
  c3J9:
      _s3Fo::P64 = R1;
      _s3Fp::P64 = P64[(young<c3J9> + 16)];
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3Jj; else goto c3Ji;
  c3Jj:
      HpAlloc = 24;
      R1 = _s3Fo::P64;
      P64[(young<c3J9> + 16)] = _s3Fp::P64;
      call stg_gc_pp(R1) returns to c3J9, args: 16, res: 16, upd: 8;
  c3Ji:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _s3Fo::P64;
      P64[Hp] = _s3Fp::P64;
      _c3Jb::P64 = Hp - 14;
      R1 = _c3Jb::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:10:08.448691 UTC

{offset
  c3J5:
      _s3Fq::P64 = R1;
      if ((Sp + 8) - 40 < SpLim) goto c3Jc; else goto c3Jd;
  c3Jc:
      R1 = _s3Fq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3Jd:
      _s3Fa::P64 = P64[_s3Fq::P64 + 16];
      _s3Fb::P64 = P64[_s3Fq::P64 + 24];
      I64[Sp - 16] = c3J2;
      R1 = _s3Fa::P64;
      P64[Sp - 8] = _s3Fb::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto c3J2; else goto c3J3;
  c3J3:
      call (I64[I64[R1]])(R1) returns to c3J2, args: 8, res: 8, upd: 8;
  c3J2:
      _s3Fb::P64 = P64[Sp + 8];
      _s3Fk::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3Jg; else goto c3Jf;
  c3Jg:
      HpAlloc = 24;
      R1 = _s3Fk::P64;
      call stg_gc_unpt_r1(R1) returns to c3J2, args: 8, res: 8, upd: 8;
  c3Jf:
      _s3Fl::I64 = I64[_s3Fk::P64 + 7];
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows8_closure;
      P64[Hp] = _s3Fb::P64;
      _c3J8::P64 = Hp - 14;
      I64[Sp + 8] = c3J9;
      I64[Sp - 16] = 11;
      I64[Sp - 8] = _s3Fl::I64;
      P64[Sp] = _c3J8::P64;
      Sp = Sp - 16;
      call $wshowSignedInt_entry() returns to c3J9, args: 32, res: 16, upd: 8;
  c3J9:
      _s3Fo::P64 = R1;
      _s3Fp::P64 = P64[Sp];
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3Jj; else goto c3Ji;
  c3Jj:
      HpAlloc = 24;
      R1 = _s3Fo::P64;
      call stg_gc_pp(R1) returns to c3J9, args: 16, res: 16, upd: 8;
  c3Ji:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _s3Fo::P64;
      P64[Hp] = _s3Fp::P64;
      _c3Jb::P64 = Hp - 14;
      R1 = _c3Jb::P64;
      Sp = Sp + 16;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:10:08.457562 UTC

{offset
  c3J5:
      if ((Sp + -32) < SpLim) goto c3Jc; else goto c3Jd;
  c3Jc:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3Jd:
      I64[Sp - 16] = c3J2;
      _s3Fb::P64 = P64[R1 + 24];
      R1 = P64[R1 + 16];
      P64[Sp - 8] = _s3Fb::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto c3J2; else goto c3J3;
  c3J3:
      call (I64[I64[R1]])(R1) returns to c3J2, args: 8, res: 8, upd: 8;
  c3J2:
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3Jg; else goto c3Jf;
  c3Jg:
      HpAlloc = 24;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to c3J2, args: 8, res: 8, upd: 8;
  c3Jf:
      _s3Fl::I64 = I64[R1 + 7];
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows8_closure;
      P64[Hp] = P64[Sp + 8];
      I64[Sp + 8] = c3J9;
      I64[Sp - 16] = 11;
      I64[Sp - 8] = _s3Fl::I64;
      P64[Sp] = Hp - 14;
      Sp = Sp - 16;
      call $wshowSignedInt_entry() returns to c3J9, args: 32, res: 16, upd: 8;
  c3J9:
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3Jj; else goto c3Ji;
  c3Jj:
      HpAlloc = 24;
      R1 = R1;
      call stg_gc_pp(R1) returns to c3J9, args: 16, res: 16, upd: 8;
  c3Ji:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = R1;
      P64[Hp] = P64[Sp];
      R1 = Hp - 14;
      Sp = Sp + 16;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:10:08.462971 UTC

[(c3J2, {}), (c3J3, {}), (c3J5, {}), (c3J9, {}), (c3Jc, {}),
 (c3Jd, {}), (c3Jf, {}), (c3Jg, {}), (c3Ji, {}), (c3Jj, {})]


==================== procpoint map ====================
2016-08-04 14:10:08.464345 UTC

[(c3J2, <procpt>), (c3J3, reached by c3J5), (c3J5, <procpt>),
 (c3J9, <procpt>), (c3Jc, reached by c3J5), (c3Jd, reached by c3J5),
 (c3Jf, reached by c3J2), (c3Jg, reached by c3J2),
 (c3Ji, reached by c3J9), (c3Jj, reached by c3J9)]


==================== Post splitting ====================
2016-08-04 14:10:08.465879 UTC

sat_s3Fq_entry() //  [R1]
        { info_tbl: [(c3J5,
                      label: sat_s3Fq_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3J5:
          if ((Sp + -32) < SpLim) goto c3Jc; else goto c3Jd;
      c3Jc:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3Jd:
          I64[Sp - 16] = block_c3J2_info;
          _s3Fb::P64 = P64[R1 + 24];
          R1 = P64[R1 + 16];
          P64[Sp - 8] = _s3Fb::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto u3JC; else goto c3J3;
      u3JC:
          call block_c3J2_entry(R1) args: 0, res: 0, upd: 0;
      c3J3:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-04 14:10:08.46939 UTC

block_c3J2_entry() //  [R1]
        { info_tbl: [(c3J2,
                      label: block_c3J2_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3J2:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c3Jg; else goto c3Jf;
      c3Jg:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c3Jf:
          _s3Fl::I64 = I64[R1 + 7];
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = shows8_closure;
          P64[Hp] = P64[Sp + 8];
          I64[Sp + 8] = block_c3J9_info;
          I64[Sp - 16] = 11;
          I64[Sp - 8] = _s3Fl::I64;
          P64[Sp] = Hp - 14;
          Sp = Sp - 16;
          call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-04 14:10:08.472484 UTC

block_c3J9_entry() //  [R1]
        { info_tbl: [(c3J9,
                      label: block_c3J9_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3J9:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c3Jj; else goto c3Ji;
      c3Jj:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
      c3Ji:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = P64[Sp];
          R1 = Hp - 14;
          Sp = Sp + 16;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:08.474921 UTC

sat_s3Fq_entry() //  [R1]
        { info_tbl: [(c3J5,
                      label: sat_s3Fq_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3J5:
          if ((Sp + -32) < SpLim) goto c3Jc; else goto c3Jd;
      c3Jc:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3Jd:
          I64[Sp - 16] = block_c3J2_info;
          _s3Fb::P64 = P64[R1 + 24];
          R1 = P64[R1 + 16];
          P64[Sp - 8] = _s3Fb::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto u3JC; else goto c3J3;
      u3JC:
          call block_c3J2_entry(R1) args: 0, res: 0, upd: 0;
      c3J3:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:08.477863 UTC

block_c3J2_entry() //  [R1]
        { info_tbl: [(c3J2,
                      label: block_c3J2_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3J2:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c3Jg; else goto c3Jf;
      c3Jg:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c3Jf:
          _s3Fl::I64 = I64[R1 + 7];
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = shows8_closure;
          P64[Hp] = P64[Sp + 8];
          I64[Sp + 8] = block_c3J9_info;
          I64[Sp - 16] = 11;
          I64[Sp - 8] = _s3Fl::I64;
          P64[Sp] = Hp - 14;
          Sp = Sp - 16;
          call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:08.480874 UTC

block_c3J9_entry() //  [R1]
        { info_tbl: [(c3J9,
                      label: block_c3J9_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3J9:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c3Jj; else goto c3Ji;
      c3Jj:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
      c3Ji:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = P64[Sp];
          R1 = Hp - 14;
          Sp = Sp + 16;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:08.48333 UTC

sat_s3Fq_entry() //  [R1]
        { info_tbl: [(c3J5,
                      label: sat_s3Fq_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3J5:
          if ((Sp + -32) < SpLim) goto c3Jc; else goto c3Jd;
      c3Jc:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3Jd:
          I64[Sp - 16] = block_c3J2_info;
          _s3Fb::P64 = P64[R1 + 24];
          R1 = P64[R1 + 16];
          P64[Sp - 8] = _s3Fb::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto u3JC; else goto c3J3;
      u3JC:
          call block_c3J2_entry(R1) args: 0, res: 0, upd: 0;
      c3J3:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:08.486343 UTC

block_c3J2_entry() //  [R1]
        { info_tbl: [(c3J2,
                      label: block_c3J2_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3J2:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c3Jg; else goto c3Jf;
      c3Jg:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c3Jf:
          _s3Fl::I64 = I64[R1 + 7];
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = shows8_closure;
          P64[Hp] = P64[Sp + 8];
          I64[Sp + 8] = block_c3J9_info;
          I64[Sp - 16] = 11;
          I64[Sp - 8] = _s3Fl::I64;
          P64[Sp] = Hp - 14;
          Sp = Sp - 16;
          call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:08.489444 UTC

block_c3J9_entry() //  [R1]
        { info_tbl: [(c3J9,
                      label: block_c3J9_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3J9:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c3Jj; else goto c3Ji;
      c3Jj:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
      c3Ji:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = P64[Sp];
          R1 = Hp - 14;
          Sp = Sp + 16;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:08.4923 UTC

{offset
  c3Jk:
      _s3Fr::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3Jl; else goto c3Jm;
  c3Jm:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c3Jo; else goto c3Jn;
  c3Jo:
      HpAlloc = 32;
      goto c3Jl;
  c3Jl:
      R1 = _s3Fr::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3Jn:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s3Fr::P64;
      _s3Fa::P64 = P64[_s3Fr::P64 + 16];
      _s3Fb::P64 = P64[_s3Fr::P64 + 24];
      I64[Hp - 24] = sat_s3Fq_info;
      P64[Hp - 8] = _s3Fa::P64;
      P64[Hp] = _s3Fb::P64;
      _c3IY::P64 = Hp - 24;
      P64[(old + 40)] = $fShowFoo2_closure;
      P64[(old + 32)] = _c3IY::P64;
      call ++_entry() args: 40, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2016-08-04 14:10:08.495725 UTC

{offset
  c3Jk:
      _s3Fr::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3Jl; else goto c3Jm;
  c3Jm:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c3Jo; else goto c3Jn;
  c3Jo:
      HpAlloc = 32;
      goto c3Jl;
  c3Jl:
      R1 = _s3Fr::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3Jn:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s3Fr::P64;
      _s3Fa::P64 = P64[_s3Fr::P64 + 16];
      _s3Fb::P64 = P64[_s3Fr::P64 + 24];
      I64[Hp - 24] = sat_s3Fq_info;
      P64[Hp - 8] = _s3Fa::P64;
      P64[Hp] = _s3Fb::P64;
      _c3IY::P64 = Hp - 24;
      P64[(old + 40)] = $fShowFoo2_closure;
      P64[(old + 32)] = _c3IY::P64;
      call ++_entry() args: 40, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-04 14:10:08.498868 UTC

sat_s3Fr_entry
[c3Jk]
{offset
  c3Jk:
      _s3Fr::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3Jl; else goto c3Jm;
  c3Jm:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c3Jo; else goto c3Jn;
  c3Jo:
      HpAlloc = 32;
      goto c3Jl;
  c3Jl:
      R1 = _s3Fr::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3Jn:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s3Fr::P64;
      _s3Fa::P64 = P64[_s3Fr::P64 + 16];
      _s3Fb::P64 = P64[_s3Fr::P64 + 24];
      I64[Hp - 24] = sat_s3Fq_info;
      P64[Hp - 8] = _s3Fa::P64;
      P64[Hp] = _s3Fb::P64;
      _c3IY::P64 = Hp - 24;
      P64[(old + 40)] = $fShowFoo2_closure;
      P64[(old + 32)] = _c3IY::P64;
      call ++_entry() args: 40, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-04 14:10:08.502699 UTC

{offset
  c3Jk:
      _s3Fr::P64 = R1;
      if ((Sp + 8) - 40 < SpLim) goto c3Jl; else goto c3Jm;
  c3Jm:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c3Jo; else goto c3Jn;
  c3Jo:
      HpAlloc = 32;
      goto c3Jl;
  c3Jl:
      R1 = _s3Fr::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3Jn:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _s3Fr::P64;
      _s3Fa::P64 = P64[_s3Fr::P64 + 16];
      _s3Fb::P64 = P64[_s3Fr::P64 + 24];
      I64[Hp - 24] = sat_s3Fq_info;
      P64[Hp - 8] = _s3Fa::P64;
      P64[Hp] = _s3Fb::P64;
      _c3IY::P64 = Hp - 24;
      P64[Sp - 32] = $fShowFoo2_closure;
      P64[Sp - 24] = _c3IY::P64;
      Sp = Sp - 32;
      call ++_entry() args: 40, res: 0, upd: 24;
}


==================== Sink assignments ====================
2016-08-04 14:10:08.506465 UTC

{offset
  c3Jk:
      _s3Fr::P64 = R1;
      if ((Sp + -32) < SpLim) goto c3Jl; else goto c3Jm;
  c3Jm:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c3Jo; else goto c3Jn;
  c3Jo:
      HpAlloc = 32;
      goto c3Jl;
  c3Jl:
      R1 = _s3Fr::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3Jn:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _s3Fr::P64;
      _s3Fa::P64 = P64[_s3Fr::P64 + 16];
      _s3Fb::P64 = P64[_s3Fr::P64 + 24];
      I64[Hp - 24] = sat_s3Fq_info;
      P64[Hp - 8] = _s3Fa::P64;
      P64[Hp] = _s3Fb::P64;
      P64[Sp - 32] = $fShowFoo2_closure;
      P64[Sp - 24] = Hp - 24;
      Sp = Sp - 32;
      call ++_entry() args: 40, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-04 14:10:08.509579 UTC

[(c3Jk, {$fShowFoo2_closure, sat_s3Fq_closure}), (c3Jl, {}),
 (c3Jm, {$fShowFoo2_closure, sat_s3Fq_closure}),
 (c3Jn, {$fShowFoo2_closure, sat_s3Fq_closure}), (c3Jo, {})]


==================== procpoint map ====================
2016-08-04 14:10:08.51091 UTC

[(c3Jk, <procpt>), (c3Jl, reached by c3Jk),
 (c3Jm, reached by c3Jk), (c3Jn, reached by c3Jk),
 (c3Jo, reached by c3Jk)]


==================== Post splitting ====================
2016-08-04 14:10:08.512221 UTC

sat_s3Fr_entry() //  [R1]
        { info_tbl: [(c3Jk,
                      label: sat_s3Fr_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Jk:
          _s3Fr::P64 = R1;
          if ((Sp + -32) < SpLim) goto c3Jl; else goto c3Jm;
      c3Jm:
          Hp = Hp + 32;
          if (Hp > HpLim) goto c3Jo; else goto c3Jn;
      c3Jo:
          HpAlloc = 32;
          goto c3Jl;
      c3Jl:
          R1 = _s3Fr::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3Jn:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s3Fr::P64;
          _s3Fa::P64 = P64[_s3Fr::P64 + 16];
          _s3Fb::P64 = P64[_s3Fr::P64 + 24];
          I64[Hp - 24] = sat_s3Fq_info;
          P64[Hp - 8] = _s3Fa::P64;
          P64[Hp] = _s3Fb::P64;
          P64[Sp - 32] = $fShowFoo2_closure;
          P64[Sp - 24] = Hp - 24;
          Sp = Sp - 32;
          call ++_entry() args: 40, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:08.516124 UTC

sat_s3Fr_entry() //  [R1]
        { info_tbl: [(c3Jk,
                      label: sat_s3Fr_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Jk:
          _s3Fr::P64 = R1;
          if ((Sp + -32) < SpLim) goto c3Jl; else goto c3Jm;
      c3Jm:
          Hp = Hp + 32;
          if (Hp > HpLim) goto c3Jo; else goto c3Jn;
      c3Jo:
          HpAlloc = 32;
          goto c3Jl;
      c3Jl:
          R1 = _s3Fr::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3Jn:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s3Fr::P64;
          _s3Fa::P64 = P64[_s3Fr::P64 + 16];
          _s3Fb::P64 = P64[_s3Fr::P64 + 24];
          I64[Hp - 24] = sat_s3Fq_info;
          P64[Hp - 8] = _s3Fa::P64;
          P64[Hp] = _s3Fb::P64;
          P64[Sp - 32] = $fShowFoo2_closure;
          P64[Sp - 24] = Hp - 24;
          Sp = Sp - 32;
          call ++_entry() args: 40, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:08.520676 UTC

sat_s3Fr_entry() //  [R1]
        { info_tbl: [(c3Jk,
                      label: sat_s3Fr_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Jk:
          _s3Fr::P64 = R1;
          if ((Sp + -32) < SpLim) goto c3Jl; else goto c3Jm;
      c3Jm:
          Hp = Hp + 32;
          if (Hp > HpLim) goto c3Jo; else goto c3Jn;
      c3Jo:
          HpAlloc = 32;
          goto c3Jl;
      c3Jl:
          R1 = _s3Fr::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3Jn:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s3Fr::P64;
          _s3Fa::P64 = P64[_s3Fr::P64 + 16];
          _s3Fb::P64 = P64[_s3Fr::P64 + 24];
          I64[Hp - 24] = sat_s3Fq_info;
          P64[Hp - 8] = _s3Fa::P64;
          P64[Hp] = _s3Fb::P64;
          P64[Sp - 32] = $fShowFoo2_closure;
          P64[Sp - 24] = Hp - 24;
          Sp = Sp - 32;
          call ++_entry() args: 40, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:08.524941 UTC

{offset
  c3Jp:
      _s3F9::I64 = I64[(old + 32)];
      _s3Fa::P64 = P64[(old + 24)];
      _s3Fb::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3Jq; else goto c3Jr;
  c3Jr:
      Hp = Hp + 56;
      if (Hp > HpLim) goto c3Jt; else goto c3Js;
  c3Jt:
      HpAlloc = 56;
      goto c3Jq;
  c3Jq:
      R1 = $w$cshowsPrec_closure;
      I64[(old + 32)] = _s3F9::I64;
      P64[(old + 24)] = _s3Fa::P64;
      P64[(old + 16)] = _s3Fb::P64;
      call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
  c3Js:
      _c3Iv::I64 = %MO_S_Ge_W64(_s3F9::I64, 11);
      _s3Fc::I64 = _c3Iv::I64;
      if (_s3Fc::I64 >= 1) goto c3Jz; else goto c3JA;
  c3Jz:
      I64[Hp - 48] = sat_s3Fr_info;
      P64[Hp - 32] = _s3Fa::P64;
      P64[Hp - 24] = _s3Fb::P64;
      _c3IU::P64 = Hp - 48;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows9_closure;
      P64[Hp] = _c3IU::P64;
      _c3Jw::P64 = Hp - 14;
      R1 = _c3Jw::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
  c3JA:
      I64[Hp - 48] = sat_s3Fj_info;
      P64[Hp - 32] = _s3Fa::P64;
      P64[Hp - 24] = _s3Fb::P64;
      _c3IA::P64 = Hp - 48;
      Hp = Hp - 24;
      P64[(old + 24)] = $fShowFoo2_closure;
      P64[(old + 16)] = _c3IA::P64;
      call ++_entry() args: 24, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:10:08.530662 UTC

{offset
  c3Jp:
      _s3F9::I64 = I64[(old + 32)];
      _s3Fa::P64 = P64[(old + 24)];
      _s3Fb::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3Jq; else goto c3Jr;
  c3Jr:
      Hp = Hp + 56;
      if (Hp > HpLim) goto c3Jt; else goto c3Js;
  c3Jt:
      HpAlloc = 56;
      goto c3Jq;
  c3Jq:
      R1 = $w$cshowsPrec_closure;
      I64[(old + 32)] = _s3F9::I64;
      P64[(old + 24)] = _s3Fa::P64;
      P64[(old + 16)] = _s3Fb::P64;
      call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
  c3Js:
      _c3Iv::I64 = %MO_S_Ge_W64(_s3F9::I64, 11);
      _s3Fc::I64 = _c3Iv::I64;
      if (_s3Fc::I64 >= 1) goto c3Jz; else goto c3JA;
  c3Jz:
      I64[Hp - 48] = sat_s3Fr_info;
      P64[Hp - 32] = _s3Fa::P64;
      P64[Hp - 24] = _s3Fb::P64;
      _c3IU::P64 = Hp - 48;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows9_closure;
      P64[Hp] = _c3IU::P64;
      _c3Jw::P64 = Hp - 14;
      R1 = _c3Jw::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
  c3JA:
      I64[Hp - 48] = sat_s3Fj_info;
      P64[Hp - 32] = _s3Fa::P64;
      P64[Hp - 24] = _s3Fb::P64;
      _c3IA::P64 = Hp - 48;
      Hp = Hp - 24;
      P64[(old + 24)] = $fShowFoo2_closure;
      P64[(old + 16)] = _c3IA::P64;
      call ++_entry() args: 24, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:10:08.536209 UTC

$w$cshowsPrec_entry
[c3Jp]
{offset
  c3Jp:
      _s3F9::I64 = I64[(old + 32)];
      _s3Fa::P64 = P64[(old + 24)];
      _s3Fb::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3Jq; else goto c3Jr;
  c3Jr:
      Hp = Hp + 56;
      if (Hp > HpLim) goto c3Jt; else goto c3Js;
  c3Jt:
      HpAlloc = 56;
      goto c3Jq;
  c3Jq:
      R1 = $w$cshowsPrec_closure;
      I64[(old + 32)] = _s3F9::I64;
      P64[(old + 24)] = _s3Fa::P64;
      P64[(old + 16)] = _s3Fb::P64;
      call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
  c3Js:
      _c3Iv::I64 = %MO_S_Ge_W64(_s3F9::I64, 11);
      _s3Fc::I64 = _c3Iv::I64;
      if (_s3Fc::I64 >= 1) goto c3Jz; else goto c3JA;
  c3Jz:
      I64[Hp - 48] = sat_s3Fr_info;
      P64[Hp - 32] = _s3Fa::P64;
      P64[Hp - 24] = _s3Fb::P64;
      _c3IU::P64 = Hp - 48;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows9_closure;
      P64[Hp] = _c3IU::P64;
      _c3Jw::P64 = Hp - 14;
      R1 = _c3Jw::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
  c3JA:
      I64[Hp - 48] = sat_s3Fj_info;
      P64[Hp - 32] = _s3Fa::P64;
      P64[Hp - 24] = _s3Fb::P64;
      _c3IA::P64 = Hp - 48;
      Hp = Hp - 24;
      P64[(old + 24)] = $fShowFoo2_closure;
      P64[(old + 16)] = _c3IA::P64;
      call ++_entry() args: 24, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:10:08.542422 UTC

{offset
  c3Jp:
      _s3F9::I64 = I64[Sp];
      _s3Fa::P64 = P64[Sp + 8];
      _s3Fb::P64 = P64[Sp + 16];
      goto c3Jr;
  c3Jr:
      Hp = Hp + 56;
      if (Hp > HpLim) goto c3Jt; else goto c3Js;
  c3Jt:
      HpAlloc = 56;
      goto c3Jq;
  c3Jq:
      R1 = $w$cshowsPrec_closure;
      call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
  c3Js:
      _c3Iv::I64 = %MO_S_Ge_W64(_s3F9::I64, 11);
      _s3Fc::I64 = _c3Iv::I64;
      if (_s3Fc::I64 >= 1) goto c3Jz; else goto c3JA;
  c3Jz:
      I64[Hp - 48] = sat_s3Fr_info;
      P64[Hp - 32] = _s3Fa::P64;
      P64[Hp - 24] = _s3Fb::P64;
      _c3IU::P64 = Hp - 48;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows9_closure;
      P64[Hp] = _c3IU::P64;
      _c3Jw::P64 = Hp - 14;
      R1 = _c3Jw::P64;
      Sp = Sp + 24;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
  c3JA:
      I64[Hp - 48] = sat_s3Fj_info;
      P64[Hp - 32] = _s3Fa::P64;
      P64[Hp - 24] = _s3Fb::P64;
      _c3IA::P64 = Hp - 48;
      Hp = Hp - 24;
      P64[Sp + 8] = $fShowFoo2_closure;
      P64[Sp + 16] = _c3IA::P64;
      Sp = Sp + 8;
      call ++_entry() args: 24, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:10:08.548042 UTC

{offset
  c3Jp:
      goto c3Jr;
  c3Jr:
      Hp = Hp + 56;
      if (Hp > HpLim) goto c3Jt; else goto c3Js;
  c3Jt:
      HpAlloc = 56;
      goto c3Jq;
  c3Jq:
      R1 = $w$cshowsPrec_closure;
      call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
  c3Js:
      _s3Fa::P64 = P64[Sp + 8];
      _s3Fb::P64 = P64[Sp + 16];
      if (%MO_S_Ge_W64(I64[Sp], 11)) goto c3Jz; else goto c3JA;
  c3Jz:
      I64[Hp - 48] = sat_s3Fr_info;
      P64[Hp - 32] = _s3Fa::P64;
      P64[Hp - 24] = _s3Fb::P64;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows9_closure;
      P64[Hp] = Hp - 48;
      R1 = Hp - 14;
      Sp = Sp + 24;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
  c3JA:
      I64[Hp - 48] = sat_s3Fj_info;
      P64[Hp - 32] = _s3Fa::P64;
      P64[Hp - 24] = _s3Fb::P64;
      _c3IA::P64 = Hp - 48;
      Hp = Hp - 24;
      P64[Sp + 8] = $fShowFoo2_closure;
      P64[Sp + 16] = _c3IA::P64;
      Sp = Sp + 8;
      call ++_entry() args: 24, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:10:08.553274 UTC

[(c3Jp,
  {$w$cshowsPrec_closure, $fShowFoo2_closure, sat_s3Fj_closure,
   sat_s3Fr_closure}),
 (c3Jq, {$w$cshowsPrec_closure}),
 (c3Jr,
  {$w$cshowsPrec_closure, $fShowFoo2_closure, sat_s3Fj_closure,
   sat_s3Fr_closure}),
 (c3Js, {$fShowFoo2_closure, sat_s3Fj_closure, sat_s3Fr_closure}),
 (c3Jt, {$w$cshowsPrec_closure}), (c3Jz, {sat_s3Fr_closure}),
 (c3JA, {$fShowFoo2_closure, sat_s3Fj_closure})]


==================== procpoint map ====================
2016-08-04 14:10:08.55539 UTC

[(c3Jp, <procpt>), (c3Jq, reached by c3Jp),
 (c3Jr, reached by c3Jp), (c3Js, reached by c3Jp),
 (c3Jt, reached by c3Jp), (c3Jz, reached by c3Jp),
 (c3JA, reached by c3Jp)]


==================== Post splitting ====================
2016-08-04 14:10:08.556649 UTC

$w$cshowsPrec_entry() //  []
        { info_tbl: [(c3Jp,
                      label: $w$cshowsPrec_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Jp:
          goto c3Jr;
      c3Jr:
          Hp = Hp + 56;
          if (Hp > HpLim) goto c3Jt; else goto c3Js;
      c3Jt:
          HpAlloc = 56;
          goto c3Jq;
      c3Jq:
          R1 = $w$cshowsPrec_closure;
          call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
      c3Js:
          _s3Fa::P64 = P64[Sp + 8];
          _s3Fb::P64 = P64[Sp + 16];
          if (%MO_S_Ge_W64(I64[Sp], 11)) goto c3Jz; else goto c3JA;
      c3Jz:
          I64[Hp - 48] = sat_s3Fr_info;
          P64[Hp - 32] = _s3Fa::P64;
          P64[Hp - 24] = _s3Fb::P64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = shows9_closure;
          P64[Hp] = Hp - 48;
          R1 = Hp - 14;
          Sp = Sp + 24;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
      c3JA:
          I64[Hp - 48] = sat_s3Fj_info;
          P64[Hp - 32] = _s3Fa::P64;
          P64[Hp - 24] = _s3Fb::P64;
          _c3IA::P64 = Hp - 48;
          Hp = Hp - 24;
          P64[Sp + 8] = $fShowFoo2_closure;
          P64[Sp + 16] = _c3IA::P64;
          Sp = Sp + 8;
          call ++_entry() args: 24, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:08.562039 UTC

$w$cshowsPrec_entry() //  []
        { info_tbl: [(c3Jp,
                      label: $w$cshowsPrec_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Jp:
          goto c3Jr;
      c3Jr:
          Hp = Hp + 56;
          if (Hp > HpLim) goto c3Jt; else goto c3Js;
      c3Jt:
          HpAlloc = 56;
          goto c3Jq;
      c3Jq:
          R1 = $w$cshowsPrec_closure;
          call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
      c3Js:
          _s3Fa::P64 = P64[Sp + 8];
          _s3Fb::P64 = P64[Sp + 16];
          if (%MO_S_Ge_W64(I64[Sp], 11)) goto c3Jz; else goto c3JA;
      c3Jz:
          I64[Hp - 48] = sat_s3Fr_info;
          P64[Hp - 32] = _s3Fa::P64;
          P64[Hp - 24] = _s3Fb::P64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = shows9_closure;
          P64[Hp] = Hp - 48;
          R1 = Hp - 14;
          Sp = Sp + 24;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
      c3JA:
          I64[Hp - 48] = sat_s3Fj_info;
          P64[Hp - 32] = _s3Fa::P64;
          P64[Hp - 24] = _s3Fb::P64;
          _c3IA::P64 = Hp - 48;
          Hp = Hp - 24;
          P64[Sp + 8] = $fShowFoo2_closure;
          P64[Sp + 16] = _c3IA::P64;
          Sp = Sp + 8;
          call ++_entry() args: 24, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:08.566819 UTC

$w$cshowsPrec_entry() //  []
        { info_tbl: [(c3Jp,
                      label: $w$cshowsPrec_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Jp:
          Hp = Hp + 56;
          if (Hp > HpLim) goto c3Jt; else goto c3Js;
      c3Jt:
          HpAlloc = 56;
          R1 = $w$cshowsPrec_closure;
          call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
      c3Js:
          _s3Fa::P64 = P64[Sp + 8];
          _s3Fb::P64 = P64[Sp + 16];
          if (%MO_S_Ge_W64(I64[Sp], 11)) goto c3Jz; else goto c3JA;
      c3Jz:
          I64[Hp - 48] = sat_s3Fr_info;
          P64[Hp - 32] = _s3Fa::P64;
          P64[Hp - 24] = _s3Fb::P64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = shows9_closure;
          P64[Hp] = Hp - 48;
          R1 = Hp - 14;
          Sp = Sp + 24;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
      c3JA:
          I64[Hp - 48] = sat_s3Fj_info;
          P64[Hp - 32] = _s3Fa::P64;
          P64[Hp - 24] = _s3Fb::P64;
          _c3IA::P64 = Hp - 48;
          Hp = Hp - 24;
          P64[Sp + 8] = $fShowFoo2_closure;
          P64[Sp + 16] = _c3IA::P64;
          Sp = Sp + 8;
          call ++_entry() args: 24, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:10:08.571663 UTC

[section "data" {
     $w$cshowsPrec_closure:
         const $w$cshowsPrec_info;
         const 0;
 },
 sat_s3Fj_entry() //  [R1]
         { info_tbl: [(c3IH,
                       label: sat_s3Fj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3IH:
           if ((Sp + -32) < SpLim) goto c3IN; else goto c3IO;
       c3IN:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3IO:
           I64[Sp - 16] = block_c3IE_info;
           _s3Fb::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 8] = _s3Fb::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u3JB; else goto c3IF;
       u3JB:
           call block_c3IE_entry(R1) args: 0, res: 0, upd: 0;
       c3IF:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3IE_entry() //  [R1]
         { info_tbl: [(c3IE,
                       label: block_c3IE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3IE:
           _s3Fb::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c3IK_info;
           I64[Sp - 16] = 11;
           I64[Sp - 8] = I64[R1 + 7];
           P64[Sp] = _s3Fb::P64;
           Sp = Sp - 16;
           call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
     }
 },
 block_c3IK_entry() //  [R1]
         { info_tbl: [(c3IK,
                       label: block_c3IK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3IK:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c3IS; else goto c3IR;
       c3IS:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
       c3IR:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp];
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s3Fq_entry() //  [R1]
         { info_tbl: [(c3J5,
                       label: sat_s3Fq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3J5:
           if ((Sp + -32) < SpLim) goto c3Jc; else goto c3Jd;
       c3Jc:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3Jd:
           I64[Sp - 16] = block_c3J2_info;
           _s3Fb::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 8] = _s3Fb::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u3JC; else goto c3J3;
       u3JC:
           call block_c3J2_entry(R1) args: 0, res: 0, upd: 0;
       c3J3:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3J2_entry() //  [R1]
         { info_tbl: [(c3J2,
                       label: block_c3J2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3J2:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c3Jg; else goto c3Jf;
       c3Jg:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c3Jf:
           _s3Fl::I64 = I64[R1 + 7];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = shows8_closure;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c3J9_info;
           I64[Sp - 16] = 11;
           I64[Sp - 8] = _s3Fl::I64;
           P64[Sp] = Hp - 14;
           Sp = Sp - 16;
           call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
     }
 },
 block_c3J9_entry() //  [R1]
         { info_tbl: [(c3J9,
                       label: block_c3J9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3J9:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c3Jj; else goto c3Ji;
       c3Jj:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
       c3Ji:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp];
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s3Fr_entry() //  [R1]
         { info_tbl: [(c3Jk,
                       label: sat_s3Fr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Jk:
           _s3Fr::P64 = R1;
           if ((Sp + -32) < SpLim) goto c3Jl; else goto c3Jm;
       c3Jm:
           Hp = Hp + 32;
           if (Hp > HpLim) goto c3Jo; else goto c3Jn;
       c3Jo:
           HpAlloc = 32;
           goto c3Jl;
       c3Jl:
           R1 = _s3Fr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3Jn:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s3Fr::P64;
           _s3Fa::P64 = P64[_s3Fr::P64 + 16];
           _s3Fb::P64 = P64[_s3Fr::P64 + 24];
           I64[Hp - 24] = sat_s3Fq_info;
           P64[Hp - 8] = _s3Fa::P64;
           P64[Hp] = _s3Fb::P64;
           P64[Sp - 32] = $fShowFoo2_closure;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call ++_entry() args: 40, res: 0, upd: 24;
     }
 },
 $w$cshowsPrec_entry() //  []
         { info_tbl: [(c3Jp,
                       label: $w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Jp:
           Hp = Hp + 56;
           if (Hp > HpLim) goto c3Jt; else goto c3Js;
       c3Jt:
           HpAlloc = 56;
           R1 = $w$cshowsPrec_closure;
           call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
       c3Js:
           _s3Fa::P64 = P64[Sp + 8];
           _s3Fb::P64 = P64[Sp + 16];
           if (%MO_S_Ge_W64(I64[Sp], 11)) goto c3Jz; else goto c3JA;
       c3Jz:
           I64[Hp - 48] = sat_s3Fr_info;
           P64[Hp - 32] = _s3Fa::P64;
           P64[Hp - 24] = _s3Fb::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = shows9_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c3JA:
           I64[Hp - 48] = sat_s3Fj_info;
           P64[Hp - 32] = _s3Fa::P64;
           P64[Hp - 24] = _s3Fb::P64;
           _c3IA::P64 = Hp - 48;
           Hp = Hp - 24;
           P64[Sp + 8] = $fShowFoo2_closure;
           P64[Sp + 16] = _c3IA::P64;
           Sp = Sp + 8;
           call ++_entry() args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:10:08.593091 UTC

[section "data" {
     $w$cshowsPrec_closure:
         const $w$cshowsPrec_info;
         const 0;
 },
 sat_s3Fj_entry() //  [R1]
         { info_tbl: [(c3IH,
                       label: sat_s3Fj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3IH:
           if ((Sp + -32) < SpLim) goto c3IN; else goto c3IO;
       c3IN:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3IO:
           I64[Sp - 16] = block_c3IE_info;
           _s3Fb::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 8] = _s3Fb::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u3JB; else goto c3IF;
       u3JB:
           call block_c3IE_entry(R1) args: 0, res: 0, upd: 0;
       c3IF:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3IE_entry() //  [R1]
         { info_tbl: [(c3IE,
                       label: block_c3IE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3IE:
           _s3Fb::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c3IK_info;
           I64[Sp - 16] = 11;
           I64[Sp - 8] = I64[R1 + 7];
           P64[Sp] = _s3Fb::P64;
           Sp = Sp - 16;
           call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
     }
 },
 block_c3IK_entry() //  [R1]
         { info_tbl: [(c3IK,
                       label: block_c3IK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3IK:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c3IS; else goto c3IR;
       c3IS:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
       c3IR:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp];
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s3Fq_entry() //  [R1]
         { info_tbl: [(c3J5,
                       label: sat_s3Fq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3J5:
           if ((Sp + -32) < SpLim) goto c3Jc; else goto c3Jd;
       c3Jc:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3Jd:
           I64[Sp - 16] = block_c3J2_info;
           _s3Fb::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 8] = _s3Fb::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u3JC; else goto c3J3;
       u3JC:
           call block_c3J2_entry(R1) args: 0, res: 0, upd: 0;
       c3J3:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3J2_entry() //  [R1]
         { info_tbl: [(c3J2,
                       label: block_c3J2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3J2:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c3Jg; else goto c3Jf;
       c3Jg:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c3Jf:
           _s3Fl::I64 = I64[R1 + 7];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = shows8_closure;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c3J9_info;
           I64[Sp - 16] = 11;
           I64[Sp - 8] = _s3Fl::I64;
           P64[Sp] = Hp - 14;
           Sp = Sp - 16;
           call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
     }
 },
 block_c3J9_entry() //  [R1]
         { info_tbl: [(c3J9,
                       label: block_c3J9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3J9:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c3Jj; else goto c3Ji;
       c3Jj:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
       c3Ji:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp];
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s3Fr_entry() //  [R1]
         { info_tbl: [(c3Jk,
                       label: sat_s3Fr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Jk:
           _s3Fr::P64 = R1;
           if ((Sp + -32) < SpLim) goto c3Jl; else goto c3Jm;
       c3Jm:
           Hp = Hp + 32;
           if (Hp > HpLim) goto c3Jo; else goto c3Jn;
       c3Jo:
           HpAlloc = 32;
           goto c3Jl;
       c3Jl:
           R1 = _s3Fr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3Jn:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s3Fr::P64;
           _s3Fa::P64 = P64[_s3Fr::P64 + 16];
           _s3Fb::P64 = P64[_s3Fr::P64 + 24];
           I64[Hp - 24] = sat_s3Fq_info;
           P64[Hp - 8] = _s3Fa::P64;
           P64[Hp] = _s3Fb::P64;
           P64[Sp - 32] = $fShowFoo2_closure;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call ++_entry() args: 40, res: 0, upd: 24;
     }
 },
 $w$cshowsPrec_entry() //  []
         { info_tbl: [(c3Jp,
                       label: $w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Jp:
           Hp = Hp + 56;
           if (Hp > HpLim) goto c3Jt; else goto c3Js;
       c3Jt:
           HpAlloc = 56;
           R1 = $w$cshowsPrec_closure;
           call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
       c3Js:
           _s3Fa::P64 = P64[Sp + 8];
           _s3Fb::P64 = P64[Sp + 16];
           if (%MO_S_Ge_W64(I64[Sp], 11)) goto c3Jz; else goto c3JA;
       c3Jz:
           I64[Hp - 48] = sat_s3Fr_info;
           P64[Hp - 32] = _s3Fa::P64;
           P64[Hp - 24] = _s3Fb::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = shows9_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c3JA:
           I64[Hp - 48] = sat_s3Fj_info;
           P64[Hp - 32] = _s3Fa::P64;
           P64[Hp - 24] = _s3Fb::P64;
           _c3IA::P64 = Hp - 48;
           Hp = Hp - 24;
           P64[Sp + 8] = $fShowFoo2_closure;
           P64[Sp + 16] = _c3IA::P64;
           Sp = Sp + 8;
           call ++_entry() args: 24, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:10:08.800163 UTC

[section "data" {
     $fShowFoo_$cshowsPrec_closure:
         const $fShowFoo_$cshowsPrec_info;
         const 0;
 },
 $fShowFoo_$cshowsPrec_entry() //  []
         { info_tbl: [(c3VU,
                       label: $fShowFoo_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 32 updfr_space: Just 8
         }
     {offset
       c3VU:
           _s3Fs::P64 = P64[(old + 32)];
           _s3Ft::P64 = P64[(old + 24)];
           _s3Fu::P64 = P64[(old + 16)];
           goto c3VP;
       c3VP:
           if ((old + 0) - <highSp> < SpLim) goto c3VY; else goto c3VZ;
       c3VY:
           R1 = $fShowFoo_$cshowsPrec_closure;
           P64[(old + 32)] = _s3Fs::P64;
           P64[(old + 24)] = _s3Ft::P64;
           P64[(old + 16)] = _s3Fu::P64;
           call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
       c3VZ:
           goto c3VO;
       c3VO:
           I64[(young<c3VR> + 8)] = c3VR;
           R1 = _s3Fs::P64;
           if (R1 & 7 != 0) goto c3VR; else goto c3VS;
       c3VS:
           call (I64[I64[R1]])(R1) returns to c3VR, args: 8, res: 8, upd: 8;
       c3VR:
           _s3Fv::P64 = R1;
           _s3Fw::I64 = I64[_s3Fv::P64 + 7];
           I64[(young<c3VX> + 8)] = c3VX;
           R1 = _s3Ft::P64;
           if (R1 & 7 != 0) goto c3VX; else goto c3W1;
       c3W1:
           call (I64[I64[R1]])(R1) returns to c3VX, args: 8, res: 8, upd: 8;
       c3VX:
           _s3Fx::P64 = R1;
           _s3Fy::P64 = P64[_s3Fx::P64 + 7];
           I64[(old + 32)] = _s3Fw::I64;
           P64[(old + 24)] = _s3Fy::P64;
           P64[(old + 16)] = _s3Fu::P64;
           call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:10:08.807251 UTC

{offset
  c3VU:
      _s3Fs::P64 = P64[(old + 32)];
      _s3Ft::P64 = P64[(old + 24)];
      _s3Fu::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3VY; else goto c3VZ;
  c3VY:
      R1 = $fShowFoo_$cshowsPrec_closure;
      P64[(old + 32)] = _s3Fs::P64;
      P64[(old + 24)] = _s3Ft::P64;
      P64[(old + 16)] = _s3Fu::P64;
      call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
  c3VZ:
      I64[(young<c3VR> + 8)] = c3VR;
      R1 = _s3Fs::P64;
      if (R1 & 7 != 0) goto c3VR; else goto c3VS;
  c3VS:
      call (I64[I64[R1]])(R1) returns to c3VR, args: 8, res: 8, upd: 8;
  c3VR:
      _s3Fv::P64 = R1;
      _s3Fw::I64 = I64[_s3Fv::P64 + 7];
      I64[(young<c3VX> + 8)] = c3VX;
      R1 = _s3Ft::P64;
      if (R1 & 7 != 0) goto c3VX; else goto c3W1;
  c3W1:
      call (I64[I64[R1]])(R1) returns to c3VX, args: 8, res: 8, upd: 8;
  c3VX:
      _s3Fx::P64 = R1;
      _s3Fy::P64 = P64[_s3Fx::P64 + 7];
      I64[(old + 32)] = _s3Fw::I64;
      P64[(old + 24)] = _s3Fy::P64;
      P64[(old + 16)] = _s3Fu::P64;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:10:08.812169 UTC

{offset
  c3VU:
      _s3Fs::P64 = P64[(old + 32)];
      _s3Ft::P64 = P64[(old + 24)];
      _s3Fu::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3VY; else goto c3VZ;
  c3VY:
      R1 = $fShowFoo_$cshowsPrec_closure;
      P64[(old + 32)] = _s3Fs::P64;
      P64[(old + 24)] = _s3Ft::P64;
      P64[(old + 16)] = _s3Fu::P64;
      call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
  c3VZ:
      I64[(young<c3VR> + 8)] = c3VR;
      R1 = _s3Fs::P64;
      if (R1 & 7 != 0) goto c3VR; else goto c3VS;
  c3VS:
      call (I64[I64[R1]])(R1) returns to c3VR, args: 8, res: 8, upd: 8;
  c3VR:
      _s3Fv::P64 = R1;
      _s3Fw::I64 = I64[_s3Fv::P64 + 7];
      I64[(young<c3VX> + 8)] = c3VX;
      R1 = _s3Ft::P64;
      if (R1 & 7 != 0) goto c3VX; else goto c3W1;
  c3W1:
      call (I64[I64[R1]])(R1) returns to c3VX, args: 8, res: 8, upd: 8;
  c3VX:
      _s3Fx::P64 = R1;
      _s3Fy::P64 = P64[_s3Fx::P64 + 7];
      I64[(old + 32)] = _s3Fw::I64;
      P64[(old + 24)] = _s3Fy::P64;
      P64[(old + 16)] = _s3Fu::P64;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:10:08.816638 UTC

$fShowFoo_$cshowsPrec_entry
[c3VR, c3VU, c3VX]
{offset
  c3VU:
      _s3Fs::P64 = P64[(old + 32)];
      _s3Ft::P64 = P64[(old + 24)];
      _s3Fu::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3VY; else goto c3VZ;
  c3VY:
      R1 = $fShowFoo_$cshowsPrec_closure;
      P64[(old + 32)] = _s3Fs::P64;
      P64[(old + 24)] = _s3Ft::P64;
      P64[(old + 16)] = _s3Fu::P64;
      call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
  c3VZ:
      I64[(young<c3VR> + 8)] = c3VR;
      R1 = _s3Fs::P64;
      if (R1 & 7 != 0) goto c3VR; else goto c3VS;
  c3VS:
      call (I64[I64[R1]])(R1) returns to c3VR, args: 8, res: 8, upd: 8;
  c3VR:
      _s3Fv::P64 = R1;
      _s3Fw::I64 = I64[_s3Fv::P64 + 7];
      I64[(young<c3VX> + 8)] = c3VX;
      R1 = _s3Ft::P64;
      if (R1 & 7 != 0) goto c3VX; else goto c3W1;
  c3W1:
      call (I64[I64[R1]])(R1) returns to c3VX, args: 8, res: 8, upd: 8;
  c3VX:
      _s3Fx::P64 = R1;
      _s3Fy::P64 = P64[_s3Fx::P64 + 7];
      I64[(old + 32)] = _s3Fw::I64;
      P64[(old + 24)] = _s3Fy::P64;
      P64[(old + 16)] = _s3Fu::P64;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:10:08.822255 UTC

{offset
  c3VU:
      _s3Fs::P64 = P64[Sp];
      _s3Ft::P64 = P64[Sp + 8];
      _s3Fu::P64 = P64[Sp + 16];
      goto c3VZ;
  c3VZ:
      I64[Sp] = c3VR;
      R1 = _s3Fs::P64;
      if (R1 & 7 != 0) goto c3VR; else goto c3VS;
  c3VS:
      call (I64[I64[R1]])(R1) returns to c3VR, args: 8, res: 8, upd: 8;
  c3VR:
      _s3Ft::P64 = P64[Sp + 8];
      _s3Fu::P64 = P64[Sp + 16];
      _s3Fv::P64 = R1;
      _s3Fw::I64 = I64[_s3Fv::P64 + 7];
      I64[Sp] = c3VX;
      R1 = _s3Ft::P64;
      I64[Sp + 8] = _s3Fw::I64;
      if (R1 & 7 != 0) goto c3VX; else goto c3W1;
  c3W1:
      call (I64[I64[R1]])(R1) returns to c3VX, args: 8, res: 8, upd: 8;
  c3VX:
      _s3Fu::P64 = P64[Sp + 16];
      _s3Fw::I64 = I64[Sp + 8];
      _s3Fx::P64 = R1;
      _s3Fy::P64 = P64[_s3Fx::P64 + 7];
      I64[Sp] = _s3Fw::I64;
      P64[Sp + 8] = _s3Fy::P64;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:10:08.826938 UTC

{offset
  c3VU:
      goto c3VZ;
  c3VZ:
      _s3Fs::P64 = P64[Sp];
      I64[Sp] = c3VR;
      R1 = _s3Fs::P64;
      if (R1 & 7 != 0) goto c3VR; else goto c3VS;
  c3VS:
      call (I64[I64[R1]])(R1) returns to c3VR, args: 8, res: 8, upd: 8;
  c3VR:
      I64[Sp] = c3VX;
      _s3Fw::I64 = I64[R1 + 7];
      R1 = P64[Sp + 8];
      I64[Sp + 8] = _s3Fw::I64;
      if (R1 & 7 != 0) goto c3VX; else goto c3W1;
  c3W1:
      call (I64[I64[R1]])(R1) returns to c3VX, args: 8, res: 8, upd: 8;
  c3VX:
      I64[Sp] = I64[Sp + 8];
      P64[Sp + 8] = P64[R1 + 7];
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:10:08.830918 UTC

[(c3VR, {$w$cshowsPrec_closure}), (c3VS, {$w$cshowsPrec_closure}),
 (c3VU, {$w$cshowsPrec_closure}), (c3VX, {$w$cshowsPrec_closure}),
 (c3VZ, {$w$cshowsPrec_closure}), (c3W1, {$w$cshowsPrec_closure})]


==================== procpoint map ====================
2016-08-04 14:10:08.832251 UTC

[(c3VR, <procpt>), (c3VS, reached by c3VU), (c3VU, <procpt>),
 (c3VX, <procpt>), (c3VZ, reached by c3VU), (c3W1, reached by c3VR)]


==================== Post splitting ====================
2016-08-04 14:10:08.833407 UTC

$fShowFoo_$cshowsPrec_entry() //  []
        { info_tbl: [(c3VU,
                      label: $fShowFoo_$cshowsPrec_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3VU:
          goto c3VZ;
      c3VZ:
          _s3Fs::P64 = P64[Sp];
          I64[Sp] = block_c3VR_info;
          R1 = _s3Fs::P64;
          if (R1 & 7 != 0) goto u3W7; else goto c3VS;
      u3W7:
          call block_c3VR_entry(R1) args: 0, res: 0, upd: 0;
      c3VS:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-04 14:10:08.835843 UTC

block_c3VR_entry() //  [R1]
        { info_tbl: [(c3VR,
                      label: block_c3VR_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3VR:
          I64[Sp] = block_c3VX_info;
          _s3Fw::I64 = I64[R1 + 7];
          R1 = P64[Sp + 8];
          I64[Sp + 8] = _s3Fw::I64;
          if (R1 & 7 != 0) goto u3W6; else goto c3W1;
      u3W6:
          call block_c3VX_entry(R1) args: 0, res: 0, upd: 0;
      c3W1:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-04 14:10:08.838148 UTC

block_c3VX_entry() //  [R1]
        { info_tbl: [(c3VX,
                      label: block_c3VX_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3VX:
          I64[Sp] = I64[Sp + 8];
          P64[Sp + 8] = P64[R1 + 7];
          call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:08.839766 UTC

$fShowFoo_$cshowsPrec_entry() //  []
        { info_tbl: [(c3VU,
                      label: $fShowFoo_$cshowsPrec_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3VU:
          goto c3VZ;
      c3VZ:
          _s3Fs::P64 = P64[Sp];
          I64[Sp] = block_c3VR_info;
          R1 = _s3Fs::P64;
          if (R1 & 7 != 0) goto u3W7; else goto c3VS;
      u3W7:
          call block_c3VR_entry(R1) args: 0, res: 0, upd: 0;
      c3VS:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:08.842011 UTC

block_c3VR_entry() //  [R1]
        { info_tbl: [(c3VR,
                      label: block_c3VR_info
                      rep:StackRep [False, False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3VR:
          I64[Sp] = block_c3VX_info;
          _s3Fw::I64 = I64[R1 + 7];
          R1 = P64[Sp + 8];
          I64[Sp + 8] = _s3Fw::I64;
          if (R1 & 7 != 0) goto u3W6; else goto c3W1;
      u3W6:
          call block_c3VX_entry(R1) args: 0, res: 0, upd: 0;
      c3W1:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:08.844321 UTC

block_c3VX_entry() //  [R1]
        { info_tbl: [(c3VX,
                      label: block_c3VX_info
                      rep:StackRep [True, False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3VX:
          I64[Sp] = I64[Sp + 8];
          P64[Sp + 8] = P64[R1 + 7];
          call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:08.845958 UTC

$fShowFoo_$cshowsPrec_entry() //  []
        { info_tbl: [(c3VU,
                      label: $fShowFoo_$cshowsPrec_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3VU:
          _s3Fs::P64 = P64[Sp];
          I64[Sp] = block_c3VR_info;
          R1 = _s3Fs::P64;
          if (R1 & 7 != 0) goto u3W7; else goto c3VS;
      u3W7:
          call block_c3VR_entry(R1) args: 0, res: 0, upd: 0;
      c3VS:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:08.84816 UTC

block_c3VR_entry() //  [R1]
        { info_tbl: [(c3VR,
                      label: block_c3VR_info
                      rep:StackRep [False, False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3VR:
          I64[Sp] = block_c3VX_info;
          _s3Fw::I64 = I64[R1 + 7];
          R1 = P64[Sp + 8];
          I64[Sp + 8] = _s3Fw::I64;
          if (R1 & 7 != 0) goto u3W6; else goto c3W1;
      u3W6:
          call block_c3VX_entry(R1) args: 0, res: 0, upd: 0;
      c3W1:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:08.850606 UTC

block_c3VX_entry() //  [R1]
        { info_tbl: [(c3VX,
                      label: block_c3VX_info
                      rep:StackRep [True, False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3VX:
          I64[Sp] = I64[Sp + 8];
          P64[Sp + 8] = P64[R1 + 7];
          call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:10:08.852272 UTC

[section "data" {
     $fShowFoo_$cshowsPrec_closure:
         const $fShowFoo_$cshowsPrec_info;
         const 0;
 },
 $fShowFoo_$cshowsPrec_entry() //  []
         { info_tbl: [(c3VU,
                       label: $fShowFoo_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3VU:
           _s3Fs::P64 = P64[Sp];
           I64[Sp] = block_c3VR_info;
           R1 = _s3Fs::P64;
           if (R1 & 7 != 0) goto u3W7; else goto c3VS;
       u3W7:
           call block_c3VR_entry(R1) args: 0, res: 0, upd: 0;
       c3VS:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3VR_entry() //  [R1]
         { info_tbl: [(c3VR,
                       label: block_c3VR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3VR:
           I64[Sp] = block_c3VX_info;
           _s3Fw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s3Fw::I64;
           if (R1 & 7 != 0) goto u3W6; else goto c3W1;
       u3W6:
           call block_c3VX_entry(R1) args: 0, res: 0, upd: 0;
       c3W1:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3VX_entry() //  [R1]
         { info_tbl: [(c3VX,
                       label: block_c3VX_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3VX:
           I64[Sp] = I64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 7];
           call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:10:08.857798 UTC

[section "data" {
     $fShowFoo_$cshowsPrec_closure:
         const $fShowFoo_$cshowsPrec_info;
         const 0;
 },
 $fShowFoo_$cshowsPrec_entry() //  []
         { info_tbl: [(c3VU,
                       label: $fShowFoo_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3VU:
           _s3Fs::P64 = P64[Sp];
           I64[Sp] = block_c3VR_info;
           R1 = _s3Fs::P64;
           if (R1 & 7 != 0) goto u3W7; else goto c3VS;
       u3W7:
           call block_c3VR_entry(R1) args: 0, res: 0, upd: 0;
       c3VS:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3VR_entry() //  [R1]
         { info_tbl: [(c3VR,
                       label: block_c3VR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3VR:
           I64[Sp] = block_c3VX_info;
           _s3Fw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s3Fw::I64;
           if (R1 & 7 != 0) goto u3W6; else goto c3W1;
       u3W6:
           call block_c3VX_entry(R1) args: 0, res: 0, upd: 0;
       c3W1:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3VX_entry() //  [R1]
         { info_tbl: [(c3VX,
                       label: block_c3VX_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3VX:
           I64[Sp] = I64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 7];
           call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:10:08.897328 UTC

[section "data" {
     $fShowFoo1_closure:
         const $fShowFoo1_info;
         const 0;
 },
 $fShowFoo1_entry() //  []
         { info_tbl: [(c3XV,
                       label: $fShowFoo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 24 updfr_space: Just 8
         }
     {offset
       c3XV:
           _s3Fz::P64 = P64[(old + 24)];
           _s3FA::P64 = P64[(old + 16)];
           goto c3XQ;
       c3XQ:
           if ((old + 0) - <highSp> < SpLim) goto c3XW; else goto c3XX;
       c3XW:
           R1 = $fShowFoo1_closure;
           P64[(old + 24)] = _s3Fz::P64;
           P64[(old + 16)] = _s3FA::P64;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
       c3XX:
           goto c3XP;
       c3XP:
           I64[(young<c3XS> + 8)] = c3XS;
           R1 = _s3Fz::P64;
           if (R1 & 7 != 0) goto c3XS; else goto c3XT;
       c3XT:
           call (I64[I64[R1]])(R1) returns to c3XS, args: 8, res: 8, upd: 8;
       c3XS:
           _s3FB::P64 = R1;
           _s3FC::P64 = P64[_s3FB::P64 + 7];
           I64[(old + 32)] = 0;
           P64[(old + 24)] = _s3FC::P64;
           P64[(old + 16)] = _s3FA::P64;
           call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:10:08.903746 UTC

{offset
  c3XV:
      _s3Fz::P64 = P64[(old + 24)];
      _s3FA::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3XW; else goto c3XX;
  c3XW:
      R1 = $fShowFoo1_closure;
      P64[(old + 24)] = _s3Fz::P64;
      P64[(old + 16)] = _s3FA::P64;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3XX:
      I64[(young<c3XS> + 8)] = c3XS;
      R1 = _s3Fz::P64;
      if (R1 & 7 != 0) goto c3XS; else goto c3XT;
  c3XT:
      call (I64[I64[R1]])(R1) returns to c3XS, args: 8, res: 8, upd: 8;
  c3XS:
      _s3FB::P64 = R1;
      _s3FC::P64 = P64[_s3FB::P64 + 7];
      I64[(old + 32)] = 0;
      P64[(old + 24)] = _s3FC::P64;
      P64[(old + 16)] = _s3FA::P64;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:10:08.907241 UTC

{offset
  c3XV:
      _s3Fz::P64 = P64[(old + 24)];
      _s3FA::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3XW; else goto c3XX;
  c3XW:
      R1 = $fShowFoo1_closure;
      P64[(old + 24)] = _s3Fz::P64;
      P64[(old + 16)] = _s3FA::P64;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3XX:
      I64[(young<c3XS> + 8)] = c3XS;
      R1 = _s3Fz::P64;
      if (R1 & 7 != 0) goto c3XS; else goto c3XT;
  c3XT:
      call (I64[I64[R1]])(R1) returns to c3XS, args: 8, res: 8, upd: 8;
  c3XS:
      _s3FB::P64 = R1;
      _s3FC::P64 = P64[_s3FB::P64 + 7];
      I64[(old + 32)] = 0;
      P64[(old + 24)] = _s3FC::P64;
      P64[(old + 16)] = _s3FA::P64;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:10:08.910529 UTC

$fShowFoo1_entry
[c3XS, c3XV]
{offset
  c3XV:
      _s3Fz::P64 = P64[(old + 24)];
      _s3FA::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3XW; else goto c3XX;
  c3XW:
      R1 = $fShowFoo1_closure;
      P64[(old + 24)] = _s3Fz::P64;
      P64[(old + 16)] = _s3FA::P64;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3XX:
      I64[(young<c3XS> + 8)] = c3XS;
      R1 = _s3Fz::P64;
      if (R1 & 7 != 0) goto c3XS; else goto c3XT;
  c3XT:
      call (I64[I64[R1]])(R1) returns to c3XS, args: 8, res: 8, upd: 8;
  c3XS:
      _s3FB::P64 = R1;
      _s3FC::P64 = P64[_s3FB::P64 + 7];
      I64[(old + 32)] = 0;
      P64[(old + 24)] = _s3FC::P64;
      P64[(old + 16)] = _s3FA::P64;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:10:08.914529 UTC

{offset
  c3XV:
      _s3Fz::P64 = P64[Sp];
      _s3FA::P64 = P64[Sp + 8];
      if ((Sp + 24) - 32 < SpLim) goto c3XW; else goto c3XX;
  c3XW:
      R1 = $fShowFoo1_closure;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3XX:
      I64[Sp] = c3XS;
      R1 = _s3Fz::P64;
      if (R1 & 7 != 0) goto c3XS; else goto c3XT;
  c3XT:
      call (I64[I64[R1]])(R1) returns to c3XS, args: 8, res: 8, upd: 8;
  c3XS:
      _s3FA::P64 = P64[Sp + 8];
      _s3FB::P64 = R1;
      _s3FC::P64 = P64[_s3FB::P64 + 7];
      I64[Sp - 8] = 0;
      P64[Sp] = _s3FC::P64;
      Sp = Sp - 8;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:10:08.917921 UTC

{offset
  c3XV:
      if ((Sp + -8) < SpLim) goto c3XW; else goto c3XX;
  c3XW:
      R1 = $fShowFoo1_closure;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3XX:
      _s3Fz::P64 = P64[Sp];
      I64[Sp] = c3XS;
      R1 = _s3Fz::P64;
      if (R1 & 7 != 0) goto c3XS; else goto c3XT;
  c3XT:
      call (I64[I64[R1]])(R1) returns to c3XS, args: 8, res: 8, upd: 8;
  c3XS:
      I64[Sp - 8] = 0;
      P64[Sp] = P64[R1 + 7];
      Sp = Sp - 8;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:10:08.920304 UTC

[(c3XS, {$w$cshowsPrec_closure}), (c3XT, {$w$cshowsPrec_closure}),
 (c3XV, {$fShowFoo1_closure, $w$cshowsPrec_closure}),
 (c3XW, {$fShowFoo1_closure}), (c3XX, {$w$cshowsPrec_closure})]


==================== procpoint map ====================
2016-08-04 14:10:08.921578 UTC

[(c3XS, <procpt>), (c3XT, reached by c3XV), (c3XV, <procpt>),
 (c3XW, reached by c3XV), (c3XX, reached by c3XV)]


==================== Post splitting ====================
2016-08-04 14:10:08.922655 UTC

$fShowFoo1_entry() //  []
        { info_tbl: [(c3XV,
                      label: $fShowFoo1_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3XV:
          if ((Sp + -8) < SpLim) goto c3XW; else goto c3XX;
      c3XW:
          R1 = $fShowFoo1_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
      c3XX:
          _s3Fz::P64 = P64[Sp];
          I64[Sp] = block_c3XS_info;
          R1 = _s3Fz::P64;
          if (R1 & 7 != 0) goto u3Y1; else goto c3XT;
      u3Y1:
          call block_c3XS_entry(R1) args: 0, res: 0, upd: 0;
      c3XT:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-04 14:10:08.925491 UTC

block_c3XS_entry() //  [R1]
        { info_tbl: [(c3XS,
                      label: block_c3XS_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3XS:
          I64[Sp - 8] = 0;
          P64[Sp] = P64[R1 + 7];
          Sp = Sp - 8;
          call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:08.927117 UTC

$fShowFoo1_entry() //  []
        { info_tbl: [(c3XV,
                      label: $fShowFoo1_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3XV:
          if ((Sp + -8) < SpLim) goto c3XW; else goto c3XX;
      c3XW:
          R1 = $fShowFoo1_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
      c3XX:
          _s3Fz::P64 = P64[Sp];
          I64[Sp] = block_c3XS_info;
          R1 = _s3Fz::P64;
          if (R1 & 7 != 0) goto u3Y1; else goto c3XT;
      u3Y1:
          call block_c3XS_entry(R1) args: 0, res: 0, upd: 0;
      c3XT:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:08.929752 UTC

block_c3XS_entry() //  [R1]
        { info_tbl: [(c3XS,
                      label: block_c3XS_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3XS:
          I64[Sp - 8] = 0;
          P64[Sp] = P64[R1 + 7];
          Sp = Sp - 8;
          call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:08.931468 UTC

$fShowFoo1_entry() //  []
        { info_tbl: [(c3XV,
                      label: $fShowFoo1_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3XV:
          if ((Sp + -8) < SpLim) goto c3XW; else goto c3XX;
      c3XW:
          R1 = $fShowFoo1_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
      c3XX:
          _s3Fz::P64 = P64[Sp];
          I64[Sp] = block_c3XS_info;
          R1 = _s3Fz::P64;
          if (R1 & 7 != 0) goto u3Y1; else goto c3XT;
      u3Y1:
          call block_c3XS_entry(R1) args: 0, res: 0, upd: 0;
      c3XT:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:08.934138 UTC

block_c3XS_entry() //  [R1]
        { info_tbl: [(c3XS,
                      label: block_c3XS_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3XS:
          I64[Sp - 8] = 0;
          P64[Sp] = P64[R1 + 7];
          Sp = Sp - 8;
          call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:10:08.935783 UTC

[section "data" {
     $fShowFoo1_closure:
         const $fShowFoo1_info;
         const 0;
 },
 $fShowFoo1_entry() //  []
         { info_tbl: [(c3XV,
                       label: $fShowFoo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3XV:
           if ((Sp + -8) < SpLim) goto c3XW; else goto c3XX;
       c3XW:
           R1 = $fShowFoo1_closure;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
       c3XX:
           _s3Fz::P64 = P64[Sp];
           I64[Sp] = block_c3XS_info;
           R1 = _s3Fz::P64;
           if (R1 & 7 != 0) goto u3Y1; else goto c3XT;
       u3Y1:
           call block_c3XS_entry(R1) args: 0, res: 0, upd: 0;
       c3XT:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3XS_entry() //  [R1]
         { info_tbl: [(c3XS,
                       label: block_c3XS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3XS:
           I64[Sp - 8] = 0;
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 8;
           call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:10:08.940074 UTC

[section "data" {
     $fShowFoo1_closure:
         const $fShowFoo1_info;
         const 0;
 },
 $fShowFoo1_entry() //  []
         { info_tbl: [(c3XV,
                       label: $fShowFoo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3XV:
           if ((Sp + -8) < SpLim) goto c3XW; else goto c3XX;
       c3XW:
           R1 = $fShowFoo1_closure;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
       c3XX:
           _s3Fz::P64 = P64[Sp];
           I64[Sp] = block_c3XS_info;
           R1 = _s3Fz::P64;
           if (R1 & 7 != 0) goto u3Y1; else goto c3XT;
       u3Y1:
           call block_c3XS_entry(R1) args: 0, res: 0, upd: 0;
       c3XT:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3XS_entry() //  [R1]
         { info_tbl: [(c3XS,
                       label: block_c3XS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3XS:
           I64[Sp - 8] = 0;
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 8;
           call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:10:08.96964 UTC

[section "data" {
     $fShowFoo_$cshowList_closure:
         const $fShowFoo_$cshowList_info;
         const 0;
 },
 $fShowFoo_$cshowList_entry() //  []
         { info_tbl: [(c3Zm,
                       label: $fShowFoo_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 24 updfr_space: Just 8
         }
     {offset
       c3Zm:
           _B2::P64 = P64[(old + 24)];
           _B1::P64 = P64[(old + 16)];
           goto c3Zk;
       c3Zk:
           if ((old + 0) - <highSp> < SpLim) goto c3Zn; else goto c3Zo;
       c3Zn:
           R1 = $fShowFoo_$cshowList_closure;
           P64[(old + 24)] = _B2::P64;
           P64[(old + 16)] = _B1::P64;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
       c3Zo:
           goto c3Zj;
       c3Zj:
           P64[(old + 32)] = $fShowFoo1_closure+2;
           P64[(old + 24)] = _B2::P64;
           P64[(old + 16)] = _B1::P64;
           call showList___entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:10:08.973744 UTC

{offset
  c3Zm:
      _B2::P64 = P64[(old + 24)];
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3Zn; else goto c3Zo;
  c3Zn:
      R1 = $fShowFoo_$cshowList_closure;
      P64[(old + 24)] = _B2::P64;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3Zo:
      P64[(old + 32)] = $fShowFoo1_closure+2;
      P64[(old + 24)] = _B2::P64;
      P64[(old + 16)] = _B1::P64;
      call showList___entry() args: 32, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:10:08.977146 UTC

{offset
  c3Zm:
      _B2::P64 = P64[(old + 24)];
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3Zn; else goto c3Zo;
  c3Zn:
      R1 = $fShowFoo_$cshowList_closure;
      P64[(old + 24)] = _B2::P64;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3Zo:
      P64[(old + 32)] = $fShowFoo1_closure+2;
      P64[(old + 24)] = _B2::P64;
      P64[(old + 16)] = _B1::P64;
      call showList___entry() args: 32, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:10:08.979446 UTC

$fShowFoo_$cshowList_entry
[c3Zm]
{offset
  c3Zm:
      _B2::P64 = P64[(old + 24)];
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3Zn; else goto c3Zo;
  c3Zn:
      R1 = $fShowFoo_$cshowList_closure;
      P64[(old + 24)] = _B2::P64;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3Zo:
      P64[(old + 32)] = $fShowFoo1_closure+2;
      P64[(old + 24)] = _B2::P64;
      P64[(old + 16)] = _B1::P64;
      call showList___entry() args: 32, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:10:08.982291 UTC

{offset
  c3Zm:
      _B2::P64 = P64[Sp];
      _B1::P64 = P64[Sp + 8];
      if ((Sp + 24) - 32 < SpLim) goto c3Zn; else goto c3Zo;
  c3Zn:
      R1 = $fShowFoo_$cshowList_closure;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3Zo:
      P64[Sp - 8] = $fShowFoo1_closure+2;
      Sp = Sp - 8;
      call showList___entry() args: 32, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:10:08.984307 UTC

{offset
  c3Zm:
      if ((Sp + -8) < SpLim) goto c3Zn; else goto c3Zo;
  c3Zn:
      R1 = $fShowFoo_$cshowList_closure;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3Zo:
      P64[Sp - 8] = $fShowFoo1_closure+2;
      Sp = Sp - 8;
      call showList___entry() args: 32, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:10:08.98579 UTC

[(c3Zm, {$fShowFoo_$cshowList_closure, $fShowFoo1_closure}),
 (c3Zn, {$fShowFoo_$cshowList_closure}),
 (c3Zo, {$fShowFoo1_closure})]


==================== procpoint map ====================
2016-08-04 14:10:08.986815 UTC

[(c3Zm, <procpt>), (c3Zn, reached by c3Zm),
 (c3Zo, reached by c3Zm)]


==================== Post splitting ====================
2016-08-04 14:10:08.987714 UTC

$fShowFoo_$cshowList_entry() //  []
        { info_tbl: [(c3Zm,
                      label: $fShowFoo_$cshowList_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Zm:
          if ((Sp + -8) < SpLim) goto c3Zn; else goto c3Zo;
      c3Zn:
          R1 = $fShowFoo_$cshowList_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
      c3Zo:
          P64[Sp - 8] = $fShowFoo1_closure+2;
          Sp = Sp - 8;
          call showList___entry() args: 32, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:08.989995 UTC

$fShowFoo_$cshowList_entry() //  []
        { info_tbl: [(c3Zm,
                      label: $fShowFoo_$cshowList_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Zm:
          if ((Sp + -8) < SpLim) goto c3Zn; else goto c3Zo;
      c3Zn:
          R1 = $fShowFoo_$cshowList_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
      c3Zo:
          P64[Sp - 8] = $fShowFoo1_closure+2;
          Sp = Sp - 8;
          call showList___entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:08.99206 UTC

$fShowFoo_$cshowList_entry() //  []
        { info_tbl: [(c3Zm,
                      label: $fShowFoo_$cshowList_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Zm:
          if ((Sp + -8) < SpLim) goto c3Zn; else goto c3Zo;
      c3Zn:
          R1 = $fShowFoo_$cshowList_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
      c3Zo:
          P64[Sp - 8] = $fShowFoo1_closure+2;
          Sp = Sp - 8;
          call showList___entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:10:08.994172 UTC

[section "data" {
     $fShowFoo_$cshowList_closure:
         const $fShowFoo_$cshowList_info;
         const 0;
 },
 $fShowFoo_$cshowList_entry() //  []
         { info_tbl: [(c3Zm,
                       label: $fShowFoo_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Zm:
           if ((Sp + -8) < SpLim) goto c3Zn; else goto c3Zo;
       c3Zn:
           R1 = $fShowFoo_$cshowList_closure;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
       c3Zo:
           P64[Sp - 8] = $fShowFoo1_closure+2;
           Sp = Sp - 8;
           call showList___entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:10:08.996642 UTC

[section "data" {
     $fShowFoo_$cshowList_closure:
         const $fShowFoo_$cshowList_info;
         const 0;
 },
 $fShowFoo_$cshowList_entry() //  []
         { info_tbl: [(c3Zm,
                       label: $fShowFoo_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Zm:
           if ((Sp + -8) < SpLim) goto c3Zn; else goto c3Zo;
       c3Zn:
           R1 = $fShowFoo_$cshowList_closure;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
       c3Zo:
           P64[Sp - 8] = $fShowFoo1_closure+2;
           Sp = Sp - 8;
           call showList___entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:10:09.012285 UTC

[section "data" {
     $fShowFoo_$cshow_closure:
         const $fShowFoo_$cshow_info;
         const 0;
 },
 $fShowFoo_$cshow_entry() //  []
         { info_tbl: [(c406,
                       label: $fShowFoo_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 16 updfr_space: Just 8
         }
     {offset
       c406:
           _s3FD::P64 = P64[(old + 16)];
           goto c401;
       c401:
           if ((old + 0) - <highSp> < SpLim) goto c407; else goto c408;
       c407:
           R1 = $fShowFoo_$cshow_closure;
           P64[(old + 16)] = _s3FD::P64;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c408:
           goto c400;
       c400:
           I64[(young<c403> + 8)] = c403;
           R1 = _s3FD::P64;
           if (R1 & 7 != 0) goto c403; else goto c404;
       c404:
           call (I64[I64[R1]])(R1) returns to c403, args: 8, res: 8, upd: 8;
       c403:
           _s3FE::P64 = R1;
           _s3FF::P64 = P64[_s3FE::P64 + 7];
           I64[(old + 32)] = 0;
           P64[(old + 24)] = _s3FF::P64;
           P64[(old + 16)] = []_closure+1;
           call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.017261 UTC

{offset
  c406:
      _s3FD::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c407; else goto c408;
  c407:
      R1 = $fShowFoo_$cshow_closure;
      P64[(old + 16)] = _s3FD::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c408:
      I64[(young<c403> + 8)] = c403;
      R1 = _s3FD::P64;
      if (R1 & 7 != 0) goto c403; else goto c404;
  c404:
      call (I64[I64[R1]])(R1) returns to c403, args: 8, res: 8, upd: 8;
  c403:
      _s3FE::P64 = R1;
      _s3FF::P64 = P64[_s3FE::P64 + 7];
      I64[(old + 32)] = 0;
      P64[(old + 24)] = _s3FF::P64;
      P64[(old + 16)] = []_closure+1;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:10:09.020489 UTC

{offset
  c406:
      _s3FD::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c407; else goto c408;
  c407:
      R1 = $fShowFoo_$cshow_closure;
      P64[(old + 16)] = _s3FD::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c408:
      I64[(young<c403> + 8)] = c403;
      R1 = _s3FD::P64;
      if (R1 & 7 != 0) goto c403; else goto c404;
  c404:
      call (I64[I64[R1]])(R1) returns to c403, args: 8, res: 8, upd: 8;
  c403:
      _s3FE::P64 = R1;
      _s3FF::P64 = P64[_s3FE::P64 + 7];
      I64[(old + 32)] = 0;
      P64[(old + 24)] = _s3FF::P64;
      P64[(old + 16)] = []_closure+1;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:10:09.023454 UTC

$fShowFoo_$cshow_entry
[c403, c406]
{offset
  c406:
      _s3FD::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c407; else goto c408;
  c407:
      R1 = $fShowFoo_$cshow_closure;
      P64[(old + 16)] = _s3FD::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c408:
      I64[(young<c403> + 8)] = c403;
      R1 = _s3FD::P64;
      if (R1 & 7 != 0) goto c403; else goto c404;
  c404:
      call (I64[I64[R1]])(R1) returns to c403, args: 8, res: 8, upd: 8;
  c403:
      _s3FE::P64 = R1;
      _s3FF::P64 = P64[_s3FE::P64 + 7];
      I64[(old + 32)] = 0;
      P64[(old + 24)] = _s3FF::P64;
      P64[(old + 16)] = []_closure+1;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:10:09.027134 UTC

{offset
  c406:
      _s3FD::P64 = P64[Sp];
      if ((Sp + 16) - 32 < SpLim) goto c407; else goto c408;
  c407:
      R1 = $fShowFoo_$cshow_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c408:
      I64[Sp] = c403;
      R1 = _s3FD::P64;
      if (R1 & 7 != 0) goto c403; else goto c404;
  c404:
      call (I64[I64[R1]])(R1) returns to c403, args: 8, res: 8, upd: 8;
  c403:
      _s3FE::P64 = R1;
      _s3FF::P64 = P64[_s3FE::P64 + 7];
      I64[Sp - 16] = 0;
      P64[Sp - 8] = _s3FF::P64;
      P64[Sp] = []_closure+1;
      Sp = Sp - 16;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:10:09.030448 UTC

{offset
  c406:
      if ((Sp + -16) < SpLim) goto c407; else goto c408;
  c407:
      R1 = $fShowFoo_$cshow_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c408:
      _s3FD::P64 = P64[Sp];
      I64[Sp] = c403;
      R1 = _s3FD::P64;
      if (R1 & 7 != 0) goto c403; else goto c404;
  c404:
      call (I64[I64[R1]])(R1) returns to c403, args: 8, res: 8, upd: 8;
  c403:
      I64[Sp - 16] = 0;
      P64[Sp - 8] = P64[R1 + 7];
      P64[Sp] = []_closure+1;
      Sp = Sp - 16;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:10:09.033012 UTC

[(c403, {$w$cshowsPrec_closure}), (c404, {$w$cshowsPrec_closure}),
 (c406, {$w$cshowsPrec_closure, $fShowFoo_$cshow_closure}),
 (c407, {$fShowFoo_$cshow_closure}),
 (c408, {$w$cshowsPrec_closure})]


==================== procpoint map ====================
2016-08-04 14:10:09.035196 UTC

[(c403, <procpt>), (c404, reached by c406), (c406, <procpt>),
 (c407, reached by c406), (c408, reached by c406)]


==================== Post splitting ====================
2016-08-04 14:10:09.036303 UTC

$fShowFoo_$cshow_entry() //  []
        { info_tbl: [(c406,
                      label: $fShowFoo_$cshow_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c406:
          if ((Sp + -16) < SpLim) goto c407; else goto c408;
      c407:
          R1 = $fShowFoo_$cshow_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c408:
          _s3FD::P64 = P64[Sp];
          I64[Sp] = block_c403_info;
          R1 = _s3FD::P64;
          if (R1 & 7 != 0) goto u40c; else goto c404;
      u40c:
          call block_c403_entry(R1) args: 0, res: 0, upd: 0;
      c404:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-04 14:10:09.039137 UTC

block_c403_entry() //  [R1]
        { info_tbl: [(c403,
                      label: block_c403_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c403:
          I64[Sp - 16] = 0;
          P64[Sp - 8] = P64[R1 + 7];
          P64[Sp] = []_closure+1;
          Sp = Sp - 16;
          call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:09.040927 UTC

$fShowFoo_$cshow_entry() //  []
        { info_tbl: [(c406,
                      label: $fShowFoo_$cshow_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c406:
          if ((Sp + -16) < SpLim) goto c407; else goto c408;
      c407:
          R1 = $fShowFoo_$cshow_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c408:
          _s3FD::P64 = P64[Sp];
          I64[Sp] = block_c403_info;
          R1 = _s3FD::P64;
          if (R1 & 7 != 0) goto u40c; else goto c404;
      u40c:
          call block_c403_entry(R1) args: 0, res: 0, upd: 0;
      c404:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:09.043536 UTC

block_c403_entry() //  [R1]
        { info_tbl: [(c403,
                      label: block_c403_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c403:
          I64[Sp - 16] = 0;
          P64[Sp - 8] = P64[R1 + 7];
          P64[Sp] = []_closure+1;
          Sp = Sp - 16;
          call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.045284 UTC

$fShowFoo_$cshow_entry() //  []
        { info_tbl: [(c406,
                      label: $fShowFoo_$cshow_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c406:
          if ((Sp + -16) < SpLim) goto c407; else goto c408;
      c407:
          R1 = $fShowFoo_$cshow_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c408:
          _s3FD::P64 = P64[Sp];
          I64[Sp] = block_c403_info;
          R1 = _s3FD::P64;
          if (R1 & 7 != 0) goto u40c; else goto c404;
      u40c:
          call block_c403_entry(R1) args: 0, res: 0, upd: 0;
      c404:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.047946 UTC

block_c403_entry() //  [R1]
        { info_tbl: [(c403,
                      label: block_c403_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c403:
          I64[Sp - 16] = 0;
          P64[Sp - 8] = P64[R1 + 7];
          P64[Sp] = []_closure+1;
          Sp = Sp - 16;
          call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:10:09.049837 UTC

[section "data" {
     $fShowFoo_$cshow_closure:
         const $fShowFoo_$cshow_info;
         const 0;
 },
 $fShowFoo_$cshow_entry() //  []
         { info_tbl: [(c406,
                       label: $fShowFoo_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c406:
           if ((Sp + -16) < SpLim) goto c407; else goto c408;
       c407:
           R1 = $fShowFoo_$cshow_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c408:
           _s3FD::P64 = P64[Sp];
           I64[Sp] = block_c403_info;
           R1 = _s3FD::P64;
           if (R1 & 7 != 0) goto u40c; else goto c404;
       u40c:
           call block_c403_entry(R1) args: 0, res: 0, upd: 0;
       c404:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c403_entry() //  [R1]
         { info_tbl: [(c403,
                       label: block_c403_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c403:
           I64[Sp - 16] = 0;
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp] = []_closure+1;
           Sp = Sp - 16;
           call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:10:09.054193 UTC

[section "data" {
     $fShowFoo_$cshow_closure:
         const $fShowFoo_$cshow_info;
         const 0;
 },
 $fShowFoo_$cshow_entry() //  []
         { info_tbl: [(c406,
                       label: $fShowFoo_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c406:
           if ((Sp + -16) < SpLim) goto c407; else goto c408;
       c407:
           R1 = $fShowFoo_$cshow_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c408:
           _s3FD::P64 = P64[Sp];
           I64[Sp] = block_c403_info;
           R1 = _s3FD::P64;
           if (R1 & 7 != 0) goto u40c; else goto c404;
       u40c:
           call block_c403_entry(R1) args: 0, res: 0, upd: 0;
       c404:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c403_entry() //  [R1]
         { info_tbl: [(c403,
                       label: block_c403_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c403:
           I64[Sp - 16] = 0;
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp] = []_closure+1;
           Sp = Sp - 16;
           call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:10:09.085325 UTC

[section "data" {
     $fShowFoo_closure:
         const D:Show_static_info;
         const $fShowFoo_$cshowsPrec_closure+3;
         const $fShowFoo_$cshow_closure+1;
         const $fShowFoo_$cshowList_closure+2;
         const 0;
 }]


==================== Post CPS Cmm ====================
2016-08-04 14:10:09.086462 UTC

[section "data" {
     $fShowFoo_closure:
         const D:Show_static_info;
         const $fShowFoo_$cshowsPrec_closure+3;
         const $fShowFoo_$cshow_closure+1;
         const $fShowFoo_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2016-08-04 14:10:09.087515 UTC

[section "data" {
     $fShowFoo_closure:
         const D:Show_static_info;
         const $fShowFoo_$cshowsPrec_closure+3;
         const $fShowFoo_$cshow_closure+1;
         const $fShowFoo_$cshowList_closure+2;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:10:09.091152 UTC

[section "data" {
     mkfoo_rpe_closure:
         const mkfoo_rpe_info;
 },
 mkfoo_rpe_entry() //  []
         { info_tbl: [(c41G,
                       label: mkfoo_rpe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 16 updfr_space: Just 8
         }
     {offset
       c41G:
           _B1::P64 = P64[(old + 16)];
           goto c41D;
       c41D:
           if ((old + 0) - <highSp> < SpLim) goto c41H; else goto c41I;
       c41I:
           goto c41C;
       c41C:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c41K; else goto c41J;
       c41K:
           HpAlloc = 16;
           goto c41H;
       c41H:
           R1 = mkfoo_rpe_closure;
           P64[(old + 16)] = _B1::P64;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c41J:
           I64[Hp - 8] = Foo_con_info;
           P64[Hp] = _B1::P64;
           _c41F::P64 = Hp - 7;
           R1 = _c41F::P64;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.095572 UTC

{offset
  c41G:
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c41H; else goto c41I;
  c41I:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c41K; else goto c41J;
  c41K:
      HpAlloc = 16;
      goto c41H;
  c41H:
      R1 = mkfoo_rpe_closure;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c41J:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c41F::P64 = Hp - 7;
      R1 = _c41F::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:10:09.098343 UTC

{offset
  c41G:
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c41H; else goto c41I;
  c41I:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c41K; else goto c41J;
  c41K:
      HpAlloc = 16;
      goto c41H;
  c41H:
      R1 = mkfoo_rpe_closure;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c41J:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c41F::P64 = Hp - 7;
      R1 = _c41F::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:10:09.100842 UTC

mkfoo_rpe_entry
[c41G]
{offset
  c41G:
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c41H; else goto c41I;
  c41I:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c41K; else goto c41J;
  c41K:
      HpAlloc = 16;
      goto c41H;
  c41H:
      R1 = mkfoo_rpe_closure;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c41J:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c41F::P64 = Hp - 7;
      R1 = _c41F::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:10:09.104937 UTC

{offset
  c41G:
      _B1::P64 = P64[Sp];
      goto c41I;
  c41I:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c41K; else goto c41J;
  c41K:
      HpAlloc = 16;
      goto c41H;
  c41H:
      R1 = mkfoo_rpe_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c41J:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c41F::P64 = Hp - 7;
      R1 = _c41F::P64;
      Sp = Sp + 8;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:10:09.107578 UTC

{offset
  c41G:
      goto c41I;
  c41I:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c41K; else goto c41J;
  c41K:
      HpAlloc = 16;
      goto c41H;
  c41H:
      R1 = mkfoo_rpe_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c41J:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = P64[Sp];
      R1 = Hp - 7;
      Sp = Sp + 8;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:10:09.109647 UTC

[(c41G, {}), (c41H, {}), (c41I, {}), (c41J, {}), (c41K, {})]


==================== procpoint map ====================
2016-08-04 14:10:09.110607 UTC

[(c41G, <procpt>), (c41H, reached by c41G),
 (c41I, reached by c41G), (c41J, reached by c41G),
 (c41K, reached by c41G)]


==================== Post splitting ====================
2016-08-04 14:10:09.111713 UTC

mkfoo_rpe_entry() //  []
        { info_tbl: [(c41G,
                      label: mkfoo_rpe_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c41G:
          goto c41I;
      c41I:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c41K; else goto c41J;
      c41K:
          HpAlloc = 16;
          goto c41H;
      c41H:
          R1 = mkfoo_rpe_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c41J:
          I64[Hp - 8] = Foo_con_info;
          P64[Hp] = P64[Sp];
          R1 = Hp - 7;
          Sp = Sp + 8;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:09.114518 UTC

mkfoo_rpe_entry() //  []
        { info_tbl: [(c41G,
                      label: mkfoo_rpe_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c41G:
          goto c41I;
      c41I:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c41K; else goto c41J;
      c41K:
          HpAlloc = 16;
          goto c41H;
      c41H:
          R1 = mkfoo_rpe_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c41J:
          I64[Hp - 8] = Foo_con_info;
          P64[Hp] = P64[Sp];
          R1 = Hp - 7;
          Sp = Sp + 8;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.11708 UTC

mkfoo_rpe_entry() //  []
        { info_tbl: [(c41G,
                      label: mkfoo_rpe_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c41G:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c41K; else goto c41J;
      c41K:
          HpAlloc = 16;
          R1 = mkfoo_rpe_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c41J:
          I64[Hp - 8] = Foo_con_info;
          P64[Hp] = P64[Sp];
          R1 = Hp - 7;
          Sp = Sp + 8;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:10:09.119617 UTC

[section "data" {
     mkfoo_rpe_closure:
         const mkfoo_rpe_info;
 },
 mkfoo_rpe_entry() //  []
         { info_tbl: [(c41G,
                       label: mkfoo_rpe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c41G:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c41K; else goto c41J;
       c41K:
           HpAlloc = 16;
           R1 = mkfoo_rpe_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c41J:
           I64[Hp - 8] = Foo_con_info;
           P64[Hp] = P64[Sp];
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:10:09.12239 UTC

[section "data" {
     mkfoo_rpe_closure:
         const mkfoo_rpe_info;
 },
 mkfoo_rpe_entry() //  []
         { info_tbl: [(c41G,
                       label: mkfoo_rpe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c41G:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c41K; else goto c41J;
       c41K:
           HpAlloc = 16;
           R1 = mkfoo_rpe_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c41J:
           I64[Hp - 8] = Foo_con_info;
           P64[Hp] = P64[Sp];
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:10:09.144475 UTC

[section "data" {
     lvl_r3EN_closure:
         const I#_static_info;
         const 4;
 }]


==================== Post CPS Cmm ====================
2016-08-04 14:10:09.145416 UTC

[section "data" {
     lvl_r3EN_closure:
         const I#_static_info;
         const 4;
 }]


==================== Output Cmm ====================
2016-08-04 14:10:09.146268 UTC

[section "data" {
     lvl_r3EN_closure:
         const I#_static_info;
         const 4;
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:10:09.148795 UTC

[section "data" {
     lvl1_r3EO_closure:
         const lvl1_r3EO_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r3EO_entry() //  [R1]
         { info_tbl: [(c431,
                       label: lvl1_r3EO_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c431:
           _r3EO::P64 = R1;
           goto c42W;
       c42W:
           if ((old + 0) - <highSp> < SpLim) goto c432; else goto c433;
       c432:
           R1 = _r3EO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c433:
           (_c42Y::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3EO::P64);
           if (_c42Y::I64 == 0) goto c430; else goto c42Z;
       c430:
           call (I64[I64[_r3EO::P64]])() args: 8, res: 0, upd: 8;
       c42Z:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _c42Y::I64;
           P64[(old + 32)] = lvl_r3EN_closure+1;
           call mkfoo_rpe_entry() args: 32, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.153407 UTC

{offset
  c431:
      _r3EO::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c432; else goto c433;
  c432:
      R1 = _r3EO::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c433:
      (_c42Y::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3EO::P64);
      if (_c42Y::I64 == 0) goto c430; else goto c42Z;
  c430:
      call (I64[I64[_r3EO::P64]])() args: 8, res: 0, upd: 8;
  c42Z:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c42Y::I64;
      P64[(old + 32)] = lvl_r3EN_closure+1;
      call mkfoo_rpe_entry() args: 32, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2016-08-04 14:10:09.156234 UTC

{offset
  c431:
      _r3EO::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c432; else goto c433;
  c432:
      R1 = _r3EO::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c433:
      (_c42Y::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3EO::P64);
      if (_c42Y::I64 == 0) goto c430; else goto c42Z;
  c430:
      call (I64[I64[_r3EO::P64]])() args: 8, res: 0, upd: 8;
  c42Z:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c42Y::I64;
      P64[(old + 32)] = lvl_r3EN_closure+1;
      call mkfoo_rpe_entry() args: 32, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-04 14:10:09.158824 UTC

lvl1_r3EO_entry
[c431]
{offset
  c431:
      _r3EO::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c432; else goto c433;
  c432:
      R1 = _r3EO::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c433:
      (_c42Y::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3EO::P64);
      if (_c42Y::I64 == 0) goto c430; else goto c42Z;
  c430:
      call (I64[I64[_r3EO::P64]])() args: 8, res: 0, upd: 8;
  c42Z:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c42Y::I64;
      P64[(old + 32)] = lvl_r3EN_closure+1;
      call mkfoo_rpe_entry() args: 32, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-04 14:10:09.161975 UTC

{offset
  c431:
      _r3EO::P64 = R1;
      if ((Sp + 8) - 32 < SpLim) goto c432; else goto c433;
  c432:
      R1 = _r3EO::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c433:
      (_c42Y::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3EO::P64);
      if (_c42Y::I64 == 0) goto c430; else goto c42Z;
  c430:
      call (I64[I64[_r3EO::P64]])() args: 8, res: 0, upd: 8;
  c42Z:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _c42Y::I64;
      P64[Sp - 24] = lvl_r3EN_closure+1;
      Sp = Sp - 24;
      call mkfoo_rpe_entry() args: 32, res: 0, upd: 24;
}


==================== Sink assignments ====================
2016-08-04 14:10:09.166109 UTC

{offset
  c431:
      if ((Sp + -24) < SpLim) goto c432; else goto c433;
  c432:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c433:
      (_c42Y::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
      if (_c42Y::I64 == 0) goto c430; else goto c42Z;
  c430:
      call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
  c42Z:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _c42Y::I64;
      P64[Sp - 24] = lvl_r3EN_closure+1;
      Sp = Sp - 24;
      call mkfoo_rpe_entry() args: 32, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-04 14:10:09.168699 UTC

[(c42Z, {}), (c430, {}), (c431, {}), (c432, {}), (c433, {})]


==================== procpoint map ====================
2016-08-04 14:10:09.169672 UTC

[(c42Z, reached by c431), (c430, reached by c431),
 (c431, <procpt>), (c432, reached by c431), (c433, reached by c431)]


==================== Post splitting ====================
2016-08-04 14:10:09.170719 UTC

lvl1_r3EO_entry() //  [R1]
        { info_tbl: [(c431,
                      label: lvl1_r3EO_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c431:
          if ((Sp + -24) < SpLim) goto c432; else goto c433;
      c432:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c433:
          (_c42Y::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
          if (_c42Y::I64 == 0) goto c430; else goto c42Z;
      c430:
          call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
      c42Z:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c42Y::I64;
          P64[Sp - 24] = lvl_r3EN_closure+1;
          Sp = Sp - 24;
          call mkfoo_rpe_entry() args: 32, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:09.173945 UTC

lvl1_r3EO_entry() //  [R1]
        { info_tbl: [(c431,
                      label: lvl1_r3EO_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c431:
          if ((Sp + -24) < SpLim) goto c432; else goto c433;
      c432:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c433:
          (_c42Y::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
          if (_c42Y::I64 == 0) goto c430; else goto c42Z;
      c430:
          call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
      c42Z:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c42Y::I64;
          P64[Sp - 24] = lvl_r3EN_closure+1;
          Sp = Sp - 24;
          call mkfoo_rpe_entry() args: 32, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.176942 UTC

lvl1_r3EO_entry() //  [R1]
        { info_tbl: [(c431,
                      label: lvl1_r3EO_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c431:
          if ((Sp + -24) < SpLim) goto c432; else goto c433;
      c432:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c433:
          (_c42Y::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
          if (_c42Y::I64 == 0) goto c430; else goto c42Z;
      c430:
          call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
      c42Z:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c42Y::I64;
          P64[Sp - 24] = lvl_r3EN_closure+1;
          Sp = Sp - 24;
          call mkfoo_rpe_entry() args: 32, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:10:09.180077 UTC

[section "data" {
     lvl1_r3EO_closure:
         const lvl1_r3EO_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r3EO_entry() //  [R1]
         { info_tbl: [(c431,
                       label: lvl1_r3EO_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c431:
           if ((Sp + -24) < SpLim) goto c432; else goto c433;
       c432:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c433:
           (_c42Y::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c42Y::I64 == 0) goto c430; else goto c42Z;
       c430:
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c42Z:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c42Y::I64;
           P64[Sp - 24] = lvl_r3EN_closure+1;
           Sp = Sp - 24;
           call mkfoo_rpe_entry() args: 32, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:10:09.183848 UTC

[section "data" {
     lvl1_r3EO_closure:
         const lvl1_r3EO_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r3EO_entry() //  [R1]
         { info_tbl: [(c431,
                       label: lvl1_r3EO_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c431:
           if ((Sp + -24) < SpLim) goto c432; else goto c433;
       c432:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c433:
           (_c42Y::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c42Y::I64 == 0) goto c430; else goto c42Z;
       c430:
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c42Z:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c42Y::I64;
           P64[Sp - 24] = lvl_r3EN_closure+1;
           Sp = Sp - 24;
           call mkfoo_rpe_entry() args: 32, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:10:09.20849 UTC

[section "data" {
     a_r3EP_closure:
         const a_r3EP_info;
         const 0;
 },
 a_r3EP_entry() //  []
         { info_tbl: [(c44o,
                       label: a_r3EP_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 16 updfr_space: Just 8
         }
     {offset
       c44o:
           _s3FG::P64 = P64[(old + 16)];
           goto c44j;
       c44j:
           if ((old + 0) - <highSp> < SpLim) goto c44s; else goto c44t;
       c44s:
           R1 = a_r3EP_closure;
           P64[(old + 16)] = _s3FG::P64;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c44t:
           goto c44i;
       c44i:
           I64[(young<c44l> + 8)] = c44l;
           R1 = lvl1_r3EO_closure;
           if (R1 & 7 != 0) goto c44l; else goto c44m;
       c44m:
           call (I64[I64[R1]])(R1) returns to c44l, args: 8, res: 8, upd: 8;
       c44l:
           _s3FI::P64 = R1;
           _s3FJ::P64 = P64[_s3FI::P64 + 7];
           I64[(young<c44r> + 8)] = c44r;
           R1 = _s3FG::P64;
           if (R1 & 7 != 0) goto c44r; else goto c44v;
       c44v:
           call (I64[I64[R1]])(R1) returns to c44r, args: 8, res: 8, upd: 8;
       c44r:
           _s3FK::P64 = R1;
           _s3FL::P64 = P64[_s3FK::P64 + 7];
           P64[_s3FL::P64 + 8] = _s3FI::P64;
           _c44A::I64 = dirty_MUT_VAR;
           _c44B::I64 = BaseReg;
           _c44C::P64 = _s3FL::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] (_c44A::I64)(_c44B::I64, _c44C::P64);
           R1 = ()_closure+1;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.217036 UTC

{offset
  c44o:
      _s3FG::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c44s; else goto c44t;
  c44s:
      R1 = a_r3EP_closure;
      P64[(old + 16)] = _s3FG::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c44t:
      I64[(young<c44l> + 8)] = c44l;
      R1 = lvl1_r3EO_closure;
      if (R1 & 7 != 0) goto c44l; else goto c44m;
  c44m:
      call (I64[I64[R1]])(R1) returns to c44l, args: 8, res: 8, upd: 8;
  c44l:
      _s3FI::P64 = R1;
      _s3FJ::P64 = P64[_s3FI::P64 + 7];
      I64[(young<c44r> + 8)] = c44r;
      R1 = _s3FG::P64;
      if (R1 & 7 != 0) goto c44r; else goto c44v;
  c44v:
      call (I64[I64[R1]])(R1) returns to c44r, args: 8, res: 8, upd: 8;
  c44r:
      _s3FK::P64 = R1;
      _s3FL::P64 = P64[_s3FK::P64 + 7];
      P64[_s3FL::P64 + 8] = _s3FI::P64;
      _c44A::I64 = dirty_MUT_VAR;
      _c44B::I64 = BaseReg;
      _c44C::P64 = _s3FL::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_c44A::I64)(_c44B::I64, _c44C::P64);
      R1 = ()_closure+1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:10:09.221904 UTC

{offset
  c44o:
      _s3FG::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c44s; else goto c44t;
  c44s:
      R1 = a_r3EP_closure;
      P64[(old + 16)] = _s3FG::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c44t:
      I64[(young<c44l> + 8)] = c44l;
      R1 = lvl1_r3EO_closure;
      if (R1 & 7 != 0) goto c44l; else goto c44m;
  c44m:
      call (I64[I64[R1]])(R1) returns to c44l, args: 8, res: 8, upd: 8;
  c44l:
      _s3FI::P64 = R1;
      _s3FJ::P64 = P64[_s3FI::P64 + 7];
      I64[(young<c44r> + 8)] = c44r;
      R1 = _s3FG::P64;
      if (R1 & 7 != 0) goto c44r; else goto c44v;
  c44v:
      call (I64[I64[R1]])(R1) returns to c44r, args: 8, res: 8, upd: 8;
  c44r:
      _s3FK::P64 = R1;
      _s3FL::P64 = P64[_s3FK::P64 + 7];
      P64[_s3FL::P64 + 8] = _s3FI::P64;
      _c44A::I64 = dirty_MUT_VAR;
      _c44B::I64 = BaseReg;
      _c44C::P64 = _s3FL::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_c44A::I64)(_c44B::I64, _c44C::P64);
      R1 = ()_closure+1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:10:09.226308 UTC

a_r3EP_entry
[c44l, c44o, c44r]
{offset
  c44o:
      _s3FG::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c44s; else goto c44t;
  c44s:
      R1 = a_r3EP_closure;
      P64[(old + 16)] = _s3FG::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c44t:
      I64[(young<c44l> + 8)] = c44l;
      R1 = lvl1_r3EO_closure;
      if (R1 & 7 != 0) goto c44l; else goto c44m;
  c44m:
      call (I64[I64[R1]])(R1) returns to c44l, args: 8, res: 8, upd: 8;
  c44l:
      _s3FI::P64 = R1;
      _s3FJ::P64 = P64[_s3FI::P64 + 7];
      I64[(young<c44r> + 8)] = c44r;
      R1 = _s3FG::P64;
      if (R1 & 7 != 0) goto c44r; else goto c44v;
  c44v:
      call (I64[I64[R1]])(R1) returns to c44r, args: 8, res: 8, upd: 8;
  c44r:
      _s3FK::P64 = R1;
      _s3FL::P64 = P64[_s3FK::P64 + 7];
      P64[_s3FL::P64 + 8] = _s3FI::P64;
      _c44A::I64 = dirty_MUT_VAR;
      _c44B::I64 = BaseReg;
      _c44C::P64 = _s3FL::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_c44A::I64)(_c44B::I64, _c44C::P64);
      R1 = ()_closure+1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:10:09.232025 UTC

{offset
  c44o:
      _s3FG::P64 = P64[Sp];
      if ((Sp + 16) - 24 < SpLim) goto c44s; else goto c44t;
  c44s:
      R1 = a_r3EP_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c44t:
      I64[Sp - 8] = c44l;
      R1 = lvl1_r3EO_closure;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto c44l; else goto c44m;
  c44m:
      call (I64[I64[R1]])(R1) returns to c44l, args: 8, res: 8, upd: 8;
  c44l:
      _s3FG::P64 = P64[Sp + 8];
      _s3FI::P64 = R1;
      _s3FJ::P64 = P64[_s3FI::P64 + 7];
      I64[Sp] = c44r;
      R1 = _s3FG::P64;
      P64[Sp + 8] = _s3FI::P64;
      if (R1 & 7 != 0) goto c44r; else goto c44v;
  c44v:
      call (I64[I64[R1]])(R1) returns to c44r, args: 8, res: 8, upd: 8;
  c44r:
      _s3FI::P64 = P64[Sp + 8];
      _s3FK::P64 = R1;
      _s3FL::P64 = P64[_s3FK::P64 + 7];
      P64[_s3FL::P64 + 8] = _s3FI::P64;
      _c44A::I64 = dirty_MUT_VAR;
      _c44B::I64 = BaseReg;
      _c44C::P64 = _s3FL::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_c44A::I64)(_c44B::I64, _c44C::P64);
      R1 = ()_closure+1;
      Sp = Sp + 16;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:10:09.237587 UTC

{offset
  c44o:
      if ((Sp + -8) < SpLim) goto c44s; else goto c44t;
  c44s:
      R1 = a_r3EP_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c44t:
      I64[Sp - 8] = c44l;
      R1 = lvl1_r3EO_closure;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto c44l; else goto c44m;
  c44m:
      call (I64[I64[R1]])(R1) returns to c44l, args: 8, res: 8, upd: 8;
  c44l:
      I64[Sp] = c44r;
      _s3FI::P64 = R1;
      R1 = P64[Sp + 8];
      P64[Sp + 8] = _s3FI::P64;
      if (R1 & 7 != 0) goto c44r; else goto c44v;
  c44v:
      call (I64[I64[R1]])(R1) returns to c44r, args: 8, res: 8, upd: 8;
  c44r:
      _s3FL::P64 = P64[R1 + 7];
      P64[_s3FL::P64 + 8] = P64[Sp + 8];
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s3FL::P64);
      R1 = ()_closure+1;
      Sp = Sp + 16;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:10:09.241451 UTC

[(c44l, {}), (c44m, {}),
 (c44o, {lvl1_r3EO_closure, a_r3EP_closure}), (c44r, {}),
 (c44s, {a_r3EP_closure}), (c44t, {lvl1_r3EO_closure}), (c44v, {})]


==================== procpoint map ====================
2016-08-04 14:10:09.242864 UTC

[(c44l, <procpt>), (c44m, reached by c44o), (c44o, <procpt>),
 (c44r, <procpt>), (c44s, reached by c44o), (c44t, reached by c44o),
 (c44v, reached by c44l)]


==================== Post splitting ====================
2016-08-04 14:10:09.244136 UTC

a_r3EP_entry() //  []
        { info_tbl: [(c44o,
                      label: a_r3EP_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44o:
          if ((Sp + -8) < SpLim) goto c44s; else goto c44t;
      c44s:
          R1 = a_r3EP_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c44t:
          I64[Sp - 8] = block_c44l_info;
          R1 = lvl1_r3EO_closure;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto u44E; else goto c44m;
      u44E:
          call block_c44l_entry(R1) args: 0, res: 0, upd: 0;
      c44m:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-04 14:10:09.247126 UTC

block_c44l_entry() //  [R1]
        { info_tbl: [(c44l,
                      label: block_c44l_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44l:
          I64[Sp] = block_c44r_info;
          _s3FI::P64 = R1;
          R1 = P64[Sp + 8];
          P64[Sp + 8] = _s3FI::P64;
          if (R1 & 7 != 0) goto u44D; else goto c44v;
      u44D:
          call block_c44r_entry(R1) args: 0, res: 0, upd: 0;
      c44v:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-04 14:10:09.250569 UTC

block_c44r_entry() //  [R1]
        { info_tbl: [(c44r,
                      label: block_c44r_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44r:
          _s3FL::P64 = P64[R1 + 7];
          P64[_s3FL::P64 + 8] = P64[Sp + 8];
          call "ccall" arg hints:  [PtrHint,
                                    PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s3FL::P64);
          R1 = ()_closure+1;
          Sp = Sp + 16;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:09.252765 UTC

a_r3EP_entry() //  []
        { info_tbl: [(c44o,
                      label: a_r3EP_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44o:
          if ((Sp + -8) < SpLim) goto c44s; else goto c44t;
      c44s:
          R1 = a_r3EP_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c44t:
          I64[Sp - 8] = block_c44l_info;
          R1 = lvl1_r3EO_closure;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto u44E; else goto c44m;
      u44E:
          call block_c44l_entry(R1) args: 0, res: 0, upd: 0;
      c44m:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:09.255392 UTC

block_c44l_entry() //  [R1]
        { info_tbl: [(c44l,
                      label: block_c44l_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44l:
          I64[Sp] = block_c44r_info;
          _s3FI::P64 = R1;
          R1 = P64[Sp + 8];
          P64[Sp + 8] = _s3FI::P64;
          if (R1 & 7 != 0) goto u44D; else goto c44v;
      u44D:
          call block_c44r_entry(R1) args: 0, res: 0, upd: 0;
      c44v:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:09.257619 UTC

block_c44r_entry() //  [R1]
        { info_tbl: [(c44r,
                      label: block_c44r_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44r:
          _s3FL::P64 = P64[R1 + 7];
          P64[_s3FL::P64 + 8] = P64[Sp + 8];
          call "ccall" arg hints:  [PtrHint,
                                    PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s3FL::P64);
          R1 = ()_closure+1;
          Sp = Sp + 16;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.25977 UTC

a_r3EP_entry() //  []
        { info_tbl: [(c44o,
                      label: a_r3EP_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44o:
          if ((Sp + -8) < SpLim) goto c44s; else goto c44t;
      c44s:
          R1 = a_r3EP_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c44t:
          I64[Sp - 8] = block_c44l_info;
          R1 = lvl1_r3EO_closure;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto u44E; else goto c44m;
      u44E:
          call block_c44l_entry(R1) args: 0, res: 0, upd: 0;
      c44m:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.262526 UTC

block_c44l_entry() //  [R1]
        { info_tbl: [(c44l,
                      label: block_c44l_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44l:
          I64[Sp] = block_c44r_info;
          _s3FI::P64 = R1;
          R1 = P64[Sp + 8];
          P64[Sp + 8] = _s3FI::P64;
          if (R1 & 7 != 0) goto u44D; else goto c44v;
      u44D:
          call block_c44r_entry(R1) args: 0, res: 0, upd: 0;
      c44v:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.264815 UTC

block_c44r_entry() //  [R1]
        { info_tbl: [(c44r,
                      label: block_c44r_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44r:
          _s3FL::P64 = P64[R1 + 7];
          P64[_s3FL::P64 + 8] = P64[Sp + 8];
          call "ccall" arg hints:  [PtrHint,
                                    PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s3FL::P64);
          R1 = ()_closure+1;
          Sp = Sp + 16;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:10:09.266975 UTC

[section "data" {
     a_r3EP_closure:
         const a_r3EP_info;
         const 0;
 },
 a_r3EP_entry() //  []
         { info_tbl: [(c44o,
                       label: a_r3EP_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44o:
           if ((Sp + -8) < SpLim) goto c44s; else goto c44t;
       c44s:
           R1 = a_r3EP_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c44t:
           I64[Sp - 8] = block_c44l_info;
           R1 = lvl1_r3EO_closure;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44E; else goto c44m;
       u44E:
           call block_c44l_entry(R1) args: 0, res: 0, upd: 0;
       c44m:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c44l_entry() //  [R1]
         { info_tbl: [(c44l,
                       label: block_c44l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44l:
           I64[Sp] = block_c44r_info;
           _s3FI::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s3FI::P64;
           if (R1 & 7 != 0) goto u44D; else goto c44v;
       u44D:
           call block_c44r_entry(R1) args: 0, res: 0, upd: 0;
       c44v:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c44r_entry() //  [R1]
         { info_tbl: [(c44r,
                       label: block_c44r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44r:
           _s3FL::P64 = P64[R1 + 7];
           P64[_s3FL::P64 + 8] = P64[Sp + 8];
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s3FL::P64);
           R1 = ()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:10:09.273657 UTC

[section "data" {
     a_r3EP_closure:
         const a_r3EP_info;
         const 0;
 },
 a_r3EP_entry() //  []
         { info_tbl: [(c44o,
                       label: a_r3EP_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44o:
           if ((Sp + -8) < SpLim) goto c44s; else goto c44t;
       c44s:
           R1 = a_r3EP_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c44t:
           I64[Sp - 8] = block_c44l_info;
           R1 = lvl1_r3EO_closure;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44E; else goto c44m;
       u44E:
           call block_c44l_entry(R1) args: 0, res: 0, upd: 0;
       c44m:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c44l_entry() //  [R1]
         { info_tbl: [(c44l,
                       label: block_c44l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44l:
           I64[Sp] = block_c44r_info;
           _s3FI::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s3FI::P64;
           if (R1 & 7 != 0) goto u44D; else goto c44v;
       u44D:
           call block_c44r_entry(R1) args: 0, res: 0, upd: 0;
       c44v:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c44r_entry() //  [R1]
         { info_tbl: [(c44r,
                       label: block_c44r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44r:
           _s3FL::P64 = P64[R1 + 7];
           P64[_s3FL::P64 + 8] = P64[Sp + 8];
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s3FL::P64);
           R1 = ()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:10:09.322136 UTC

[section "data" {
     dowrite_closure:
         const dowrite_info;
         const 0;
 },
 dowrite_entry() //  []
         { info_tbl: [(c471,
                       label: dowrite_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 16 updfr_space: Just 8
         }
     {offset
       c471:
           _B2::P64 = P64[(old + 16)];
           goto c46Z;
       c46Z:
           if ((old + 0) - <highSp> < SpLim) goto c472; else goto c473;
       c472:
           R1 = dowrite_closure;
           P64[(old + 16)] = _B2::P64;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c473:
           goto c46Y;
       c46Y:
           P64[(old + 16)] = _B2::P64;
           call a_r3EP_entry() args: 16, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.325621 UTC

{offset
  c471:
      _B2::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c472; else goto c473;
  c472:
      R1 = dowrite_closure;
      P64[(old + 16)] = _B2::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c473:
      P64[(old + 16)] = _B2::P64;
      call a_r3EP_entry() args: 16, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:10:09.328484 UTC

{offset
  c471:
      _B2::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c472; else goto c473;
  c472:
      R1 = dowrite_closure;
      P64[(old + 16)] = _B2::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c473:
      P64[(old + 16)] = _B2::P64;
      call a_r3EP_entry() args: 16, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:10:09.330311 UTC

dowrite_entry
[c471]
{offset
  c471:
      _B2::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c472; else goto c473;
  c472:
      R1 = dowrite_closure;
      P64[(old + 16)] = _B2::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c473:
      P64[(old + 16)] = _B2::P64;
      call a_r3EP_entry() args: 16, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:10:09.332546 UTC

{offset
  c471:
      _B2::P64 = P64[Sp];
      goto c473;
  c473:
      call a_r3EP_entry() args: 16, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:10:09.333685 UTC

{offset
  c471:
      goto c473;
  c473:
      call a_r3EP_entry() args: 16, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:10:09.334586 UTC

[(c471, {a_r3EP_closure}), (c473, {a_r3EP_closure})]


==================== procpoint map ====================
2016-08-04 14:10:09.335435 UTC

[(c471, <procpt>), (c473, reached by c471)]


==================== Post splitting ====================
2016-08-04 14:10:09.336234 UTC

dowrite_entry() //  []
        { info_tbl: [(c471,
                      label: dowrite_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c471:
          goto c473;
      c473:
          call a_r3EP_entry() args: 16, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:09.337722 UTC

dowrite_entry() //  []
        { info_tbl: [(c471,
                      label: dowrite_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c471:
          goto c473;
      c473:
          call a_r3EP_entry() args: 16, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.339148 UTC

dowrite_entry() //  []
        { info_tbl: [(c471,
                      label: dowrite_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c471:
          call a_r3EP_entry() args: 16, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:10:09.34053 UTC

[section "data" {
     dowrite_closure:
         const dowrite_info;
         const 0;
 },
 dowrite_entry() //  []
         { info_tbl: [(c471,
                       label: dowrite_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c471:
           call a_r3EP_entry() args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:10:09.342315 UTC

[section "data" {
     dowrite_closure:
         const dowrite_info;
         const 0;
 },
 dowrite_entry() //  []
         { info_tbl: [(c471,
                       label: dowrite_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c471:
           call a_r3EP_entry() args: 16, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:10:09.349526 UTC

[section "data" {
     main3_closure:
         const I#_static_info;
         const 3;
 }]


==================== Post CPS Cmm ====================
2016-08-04 14:10:09.35042 UTC

[section "data" {
     main3_closure:
         const I#_static_info;
         const 3;
 }]


==================== Output Cmm ====================
2016-08-04 14:10:09.351285 UTC

[section "data" {
     main3_closure:
         const I#_static_info;
         const 3;
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:10:09.353763 UTC

[section "data" {
     main2_closure:
         const Foo_static_info;
         const main3_closure+1;
         const 1;
 }]


==================== Post CPS Cmm ====================
2016-08-04 14:10:09.35472 UTC

[section "data" {
     main2_closure:
         const Foo_static_info;
         const main3_closure+1;
         const 1;
 }]


==================== Output Cmm ====================
2016-08-04 14:10:09.35563 UTC

[section "data" {
     main2_closure:
         const Foo_static_info;
         const main3_closure+1;
         const 1;
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:10:09.359352 UTC

[section "data" {
     main7_closure:
         const main7_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     c47b_str:
         I8[] [104,105]
 },
 main7_entry() //  [R1]
         { info_tbl: [(c47c,
                       label: main7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c47c:
           _r3EL::P64 = R1;
           goto c476;
       c476:
           if ((old + 0) - <highSp> < SpLim) goto c47d; else goto c47e;
       c47d:
           R1 = _r3EL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c47e:
           (_c478::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3EL::P64);
           if (_c478::I64 == 0) goto c47a; else goto c479;
       c47a:
           call (I64[I64[_r3EL::P64]])() args: 8, res: 0, upd: 8;
       c479:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _c478::I64;
           I64[(old + 32)] = c47b_str;
           call unpackCString#_entry() args: 32, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.363962 UTC

{offset
  c47c:
      _r3EL::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c47d; else goto c47e;
  c47d:
      R1 = _r3EL::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c47e:
      (_c478::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3EL::P64);
      if (_c478::I64 == 0) goto c47a; else goto c479;
  c47a:
      call (I64[I64[_r3EL::P64]])() args: 8, res: 0, upd: 8;
  c479:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c478::I64;
      I64[(old + 32)] = c47b_str;
      call unpackCString#_entry() args: 32, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2016-08-04 14:10:09.366696 UTC

{offset
  c47c:
      _r3EL::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c47d; else goto c47e;
  c47d:
      R1 = _r3EL::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c47e:
      (_c478::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3EL::P64);
      if (_c478::I64 == 0) goto c47a; else goto c479;
  c47a:
      call (I64[I64[_r3EL::P64]])() args: 8, res: 0, upd: 8;
  c479:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c478::I64;
      I64[(old + 32)] = c47b_str;
      call unpackCString#_entry() args: 32, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-04 14:10:09.369273 UTC

main7_entry
[c47c]
{offset
  c47c:
      _r3EL::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c47d; else goto c47e;
  c47d:
      R1 = _r3EL::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c47e:
      (_c478::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3EL::P64);
      if (_c478::I64 == 0) goto c47a; else goto c479;
  c47a:
      call (I64[I64[_r3EL::P64]])() args: 8, res: 0, upd: 8;
  c479:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c478::I64;
      I64[(old + 32)] = c47b_str;
      call unpackCString#_entry() args: 32, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-04 14:10:09.37232 UTC

{offset
  c47c:
      _r3EL::P64 = R1;
      if ((Sp + 8) - 32 < SpLim) goto c47d; else goto c47e;
  c47d:
      R1 = _r3EL::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c47e:
      (_c478::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3EL::P64);
      if (_c478::I64 == 0) goto c47a; else goto c479;
  c47a:
      call (I64[I64[_r3EL::P64]])() args: 8, res: 0, upd: 8;
  c479:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _c478::I64;
      I64[Sp - 24] = c47b_str;
      Sp = Sp - 24;
      call unpackCString#_entry() args: 32, res: 0, upd: 24;
}


==================== Sink assignments ====================
2016-08-04 14:10:09.375399 UTC

{offset
  c47c:
      if ((Sp + -24) < SpLim) goto c47d; else goto c47e;
  c47d:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c47e:
      (_c478::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
      if (_c478::I64 == 0) goto c47a; else goto c479;
  c47a:
      call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
  c479:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _c478::I64;
      I64[Sp - 24] = c47b_str;
      Sp = Sp - 24;
      call unpackCString#_entry() args: 32, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-04 14:10:09.377765 UTC

[(c479, {}), (c47a, {}), (c47c, {}), (c47d, {}), (c47e, {})]


==================== procpoint map ====================
2016-08-04 14:10:09.378744 UTC

[(c479, reached by c47c), (c47a, reached by c47c),
 (c47c, <procpt>), (c47d, reached by c47c), (c47e, reached by c47c)]


==================== Post splitting ====================
2016-08-04 14:10:09.379779 UTC

main7_entry() //  [R1]
        { info_tbl: [(c47c,
                      label: main7_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c47c:
          if ((Sp + -24) < SpLim) goto c47d; else goto c47e;
      c47d:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c47e:
          (_c478::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
          if (_c478::I64 == 0) goto c47a; else goto c479;
      c47a:
          call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
      c479:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c478::I64;
          I64[Sp - 24] = c47b_str;
          Sp = Sp - 24;
          call unpackCString#_entry() args: 32, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:09.382993 UTC

main7_entry() //  [R1]
        { info_tbl: [(c47c,
                      label: main7_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c47c:
          if ((Sp + -24) < SpLim) goto c47d; else goto c47e;
      c47d:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c47e:
          (_c478::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
          if (_c478::I64 == 0) goto c47a; else goto c479;
      c47a:
          call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
      c479:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c478::I64;
          I64[Sp - 24] = c47b_str;
          Sp = Sp - 24;
          call unpackCString#_entry() args: 32, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.385947 UTC

main7_entry() //  [R1]
        { info_tbl: [(c47c,
                      label: main7_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c47c:
          if ((Sp + -24) < SpLim) goto c47d; else goto c47e;
      c47d:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c47e:
          (_c478::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
          if (_c478::I64 == 0) goto c47a; else goto c479;
      c47a:
          call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
      c479:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c478::I64;
          I64[Sp - 24] = c47b_str;
          Sp = Sp - 24;
          call unpackCString#_entry() args: 32, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:10:09.389033 UTC

[section "data" {
     main7_closure:
         const main7_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     c47b_str:
         I8[] [104,105]
 },
 main7_entry() //  [R1]
         { info_tbl: [(c47c,
                       label: main7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47c:
           if ((Sp + -24) < SpLim) goto c47d; else goto c47e;
       c47d:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c47e:
           (_c478::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c478::I64 == 0) goto c47a; else goto c479;
       c47a:
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c479:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c478::I64;
           I64[Sp - 24] = c47b_str;
           Sp = Sp - 24;
           call unpackCString#_entry() args: 32, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:10:09.392806 UTC

[section "data" {
     main7_closure:
         const main7_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     c47b_str:
         I8[] [104,105]
 },
 main7_entry() //  [R1]
         { info_tbl: [(c47c,
                       label: main7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47c:
           if ((Sp + -24) < SpLim) goto c47d; else goto c47e;
       c47d:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c47e:
           (_c478::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c478::I64 == 0) goto c47a; else goto c479;
       c47a:
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c479:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c478::I64;
           I64[Sp - 24] = c47b_str;
           Sp = Sp - 24;
           call unpackCString#_entry() args: 32, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:10:09.418544 UTC

[section "data" {
     main6_closure:
         const :_static_info;
         const shows6_closure;
         const []_closure+1;
         const 1;
 }]


==================== Post CPS Cmm ====================
2016-08-04 14:10:09.419614 UTC

[section "data" {
     main6_closure:
         const :_static_info;
         const shows6_closure;
         const []_closure+1;
         const 1;
 }]


==================== Output Cmm ====================
2016-08-04 14:10:09.420579 UTC

[section "data" {
     main6_closure:
         const :_static_info;
         const shows6_closure;
         const []_closure+1;
         const 1;
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:10:09.423744 UTC

[section "data" {
     main5_closure:
         const main5_info;
         const 0;
         const 0;
         const 0;
 },
 main5_entry() //  [R1]
         { info_tbl: [(c48x,
                       label: main5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c48x:
           _r3EJ::P64 = R1;
           goto c48s;
       c48s:
           if ((old + 0) - <highSp> < SpLim) goto c48y; else goto c48z;
       c48y:
           R1 = _r3EJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c48z:
           (_c48u::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3EJ::P64);
           if (_c48u::I64 == 0) goto c48w; else goto c48v;
       c48w:
           call (I64[I64[_r3EJ::P64]])() args: 8, res: 0, upd: 8;
       c48v:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _c48u::I64;
           P64[(old + 40)] = main7_closure;
           P64[(old + 32)] = main6_closure+2;
           call showLitString_entry() args: 40, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.429394 UTC

{offset
  c48x:
      _r3EJ::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c48y; else goto c48z;
  c48y:
      R1 = _r3EJ::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c48z:
      (_c48u::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3EJ::P64);
      if (_c48u::I64 == 0) goto c48w; else goto c48v;
  c48w:
      call (I64[I64[_r3EJ::P64]])() args: 8, res: 0, upd: 8;
  c48v:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c48u::I64;
      P64[(old + 40)] = main7_closure;
      P64[(old + 32)] = main6_closure+2;
      call showLitString_entry() args: 40, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2016-08-04 14:10:09.432417 UTC

{offset
  c48x:
      _r3EJ::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c48y; else goto c48z;
  c48y:
      R1 = _r3EJ::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c48z:
      (_c48u::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3EJ::P64);
      if (_c48u::I64 == 0) goto c48w; else goto c48v;
  c48w:
      call (I64[I64[_r3EJ::P64]])() args: 8, res: 0, upd: 8;
  c48v:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c48u::I64;
      P64[(old + 40)] = main7_closure;
      P64[(old + 32)] = main6_closure+2;
      call showLitString_entry() args: 40, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-04 14:10:09.435076 UTC

main5_entry
[c48x]
{offset
  c48x:
      _r3EJ::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c48y; else goto c48z;
  c48y:
      R1 = _r3EJ::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c48z:
      (_c48u::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3EJ::P64);
      if (_c48u::I64 == 0) goto c48w; else goto c48v;
  c48w:
      call (I64[I64[_r3EJ::P64]])() args: 8, res: 0, upd: 8;
  c48v:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c48u::I64;
      P64[(old + 40)] = main7_closure;
      P64[(old + 32)] = main6_closure+2;
      call showLitString_entry() args: 40, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-04 14:10:09.438309 UTC

{offset
  c48x:
      _r3EJ::P64 = R1;
      if ((Sp + 8) - 40 < SpLim) goto c48y; else goto c48z;
  c48y:
      R1 = _r3EJ::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c48z:
      (_c48u::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3EJ::P64);
      if (_c48u::I64 == 0) goto c48w; else goto c48v;
  c48w:
      call (I64[I64[_r3EJ::P64]])() args: 8, res: 0, upd: 8;
  c48v:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _c48u::I64;
      P64[Sp - 32] = main7_closure;
      P64[Sp - 24] = main6_closure+2;
      Sp = Sp - 32;
      call showLitString_entry() args: 40, res: 0, upd: 24;
}


==================== Sink assignments ====================
2016-08-04 14:10:09.441621 UTC

{offset
  c48x:
      if ((Sp + -32) < SpLim) goto c48y; else goto c48z;
  c48y:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c48z:
      (_c48u::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
      if (_c48u::I64 == 0) goto c48w; else goto c48v;
  c48w:
      call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
  c48v:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _c48u::I64;
      P64[Sp - 32] = main7_closure;
      P64[Sp - 24] = main6_closure+2;
      Sp = Sp - 32;
      call showLitString_entry() args: 40, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-04 14:10:09.444209 UTC

[(c48v, {showLitString_closure, main7_closure}), (c48w, {}),
 (c48x, {showLitString_closure, main7_closure}), (c48y, {}),
 (c48z, {showLitString_closure, main7_closure})]


==================== procpoint map ====================
2016-08-04 14:10:09.445455 UTC

[(c48v, reached by c48x), (c48w, reached by c48x),
 (c48x, <procpt>), (c48y, reached by c48x), (c48z, reached by c48x)]


==================== Post splitting ====================
2016-08-04 14:10:09.44651 UTC

main5_entry() //  [R1]
        { info_tbl: [(c48x,
                      label: main5_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c48x:
          if ((Sp + -32) < SpLim) goto c48y; else goto c48z;
      c48y:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c48z:
          (_c48u::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
          if (_c48u::I64 == 0) goto c48w; else goto c48v;
      c48w:
          call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
      c48v:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c48u::I64;
          P64[Sp - 32] = main7_closure;
          P64[Sp - 24] = main6_closure+2;
          Sp = Sp - 32;
          call showLitString_entry() args: 40, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:09.449868 UTC

main5_entry() //  [R1]
        { info_tbl: [(c48x,
                      label: main5_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c48x:
          if ((Sp + -32) < SpLim) goto c48y; else goto c48z;
      c48y:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c48z:
          (_c48u::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
          if (_c48u::I64 == 0) goto c48w; else goto c48v;
      c48w:
          call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
      c48v:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c48u::I64;
          P64[Sp - 32] = main7_closure;
          P64[Sp - 24] = main6_closure+2;
          Sp = Sp - 32;
          call showLitString_entry() args: 40, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.452986 UTC

main5_entry() //  [R1]
        { info_tbl: [(c48x,
                      label: main5_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c48x:
          if ((Sp + -32) < SpLim) goto c48y; else goto c48z;
      c48y:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c48z:
          (_c48u::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
          if (_c48u::I64 == 0) goto c48w; else goto c48v;
      c48w:
          call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
      c48v:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c48u::I64;
          P64[Sp - 32] = main7_closure;
          P64[Sp - 24] = main6_closure+2;
          Sp = Sp - 32;
          call showLitString_entry() args: 40, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:10:09.456189 UTC

[section "data" {
     main5_closure:
         const main5_info;
         const 0;
         const 0;
         const 0;
 },
 main5_entry() //  [R1]
         { info_tbl: [(c48x,
                       label: main5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48x:
           if ((Sp + -32) < SpLim) goto c48y; else goto c48z;
       c48y:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c48z:
           (_c48u::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c48u::I64 == 0) goto c48w; else goto c48v;
       c48w:
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c48v:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c48u::I64;
           P64[Sp - 32] = main7_closure;
           P64[Sp - 24] = main6_closure+2;
           Sp = Sp - 32;
           call showLitString_entry() args: 40, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:10:09.460039 UTC

[section "data" {
     main5_closure:
         const main5_info;
         const 0;
         const 0;
         const 0;
 },
 main5_entry() //  [R1]
         { info_tbl: [(c48x,
                       label: main5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48x:
           if ((Sp + -32) < SpLim) goto c48y; else goto c48z;
       c48y:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c48z:
           (_c48u::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c48u::I64 == 0) goto c48w; else goto c48v;
       c48w:
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c48v:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c48u::I64;
           P64[Sp - 32] = main7_closure;
           P64[Sp - 24] = main6_closure+2;
           Sp = Sp - 32;
           call showLitString_entry() args: 40, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:10:09.486934 UTC

[section "data" {
     main4_closure:
         const :_static_info;
         const shows6_closure;
         const main5_closure;
         const 0;
 }]


==================== Post CPS Cmm ====================
2016-08-04 14:10:09.487977 UTC

[section "data" {
     main4_closure:
         const :_static_info;
         const shows6_closure;
         const main5_closure;
         const 0;
 }]


==================== Output Cmm ====================
2016-08-04 14:10:09.488959 UTC

[section "data" {
     main4_closure:
         const :_static_info;
         const shows6_closure;
         const main5_closure;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:10:09.491964 UTC

[section "data" {
     main1_closure:
         const main1_info;
         const 0;
 },
 sat_s3FW_entry() //  [R1]
         { info_tbl: [(c4ad,
                       label: sat_s3FW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4ad:
           _s3FW::P64 = R1;
           goto c4ab;
       c4ab:
           if ((old + 0) - <highSp> < SpLim) goto c4ae; else goto c4af;
       c4ae:
           R1 = _s3FW::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4af:
           goto c4aa;
       c4aa:
           _s3FV::P64 = P64[_s3FW::P64 + 7];
           P64[(old + 16)] = _s3FV::P64;
           call dowrite_entry() args: 16, res: 0, upd: 8;
     }
 },
 sat_s3FX_entry() //  [R1]
         { info_tbl: [(c4ag,
                       label: sat_s3FX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4ag:
           _s3FX::P64 = R1;
           goto c4a5;
       c4a5:
           if ((old + 0) - <highSp> < SpLim) goto c4ah; else goto c4ai;
       c4ai:
           goto c4a4;
       c4a4:
           Hp = Hp + 32;
           if (Hp > HpLim) goto c4ak; else goto c4aj;
       c4ak:
           HpAlloc = 32;
           goto c4ah;
       c4ah:
           R1 = _s3FX::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4aj:
           _s3FT::P64 = P64[_s3FX::P64 + 7];
           I64[Hp - 24] = STRef_con_info;
           P64[Hp - 16] = _s3FT::P64;
           _c4a7::P64 = Hp - 23;
           I64[Hp - 8] = sat_s3FW_info;
           P64[Hp] = _c4a7::P64;
           _c4a8::P64 = Hp - 7;
           R1 = _c4a8::P64;
           P64[(old + 16)] = childHandler1_closure+2;
           call stg_catch#(R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_s3G4_entry() //  [R1]
         { info_tbl: [(c4ar,
                       label: sat_s3G4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4ar:
           _s3G4::P64 = R1;
           goto c4ap;
       c4ap:
           if ((old + 0) - <highSp> < SpLim) goto c4as; else goto c4at;
       c4as:
           R1 = _s3G4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4at:
           _s3G3::P64 = P64[_s3G4::P64 + 16];
           P64[(old + 16)] = _s3G3::P64;
           call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
     }
 },
 main1_entry() //  []
         { info_tbl: [(c4au,
                       label: main1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4au:
           goto c49W;
       c49W:
           if ((old + 0) - <highSp> < SpLim) goto c4av; else goto c4aw;
       c4av:
           R1 = main1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4aw:
           goto c49V;
       c49V:
           I64[(young<c49Y> + 8)] = c49Y;
           P64[(young<c49Y> + 32)] = stdout_closure;
           P64[(young<c49Y> + 24)] = main4_closure+2;
           P64[(young<c49Y> + 16)] = True_closure+2;
           call hPutStr2_entry() returns to c49Y, args: 32, res: 8, upd: 8;
       c49Y:
           _s3FQ::P64 = R1;
           I64[(young<c4a0> + 8)] = c4a0;
           R1 = main2_closure+1;
           call stg_newMutVar#(R1) returns to c4a0, args: 8, res: 8, upd: 8;
       c4a0:
           _s3FT::P64 = R1;
           Hp = Hp + 16;
           if (Hp > HpLim) goto c4aA; else goto c4az;
       c4aA:
           HpAlloc = 16;
           goto c4ay;
       c4ay:
           R1 = _s3FT::P64;
           call stg_gc_unpt_r1(R1) returns to c4a0, args: 8, res: 8, upd: 8;
       c4az:
           I64[Hp - 8] = sat_s3FX_info;
           P64[Hp] = _s3FT::P64;
           _c4a2::P64 = Hp - 7;
           I64[(young<c4al> + 8)] = c4al;
           R1 = _c4a2::P64;
           call stg_fork#(R1) returns to c4al, args: 8, res: 8, upd: 8;
       c4al:
           _s3G0::P64 = R1;
           Hp = Hp + 24;
           if (Hp > HpLim) goto c4aD; else goto c4aC;
       c4aD:
           HpAlloc = 24;
           goto c4aB;
       c4aB:
           R1 = _s3G0::P64;
           call stg_gc_unpt_r1(R1) returns to c4al, args: 8, res: 8, upd: 8;
       c4aC:
           _s3G3::P64 = P64[_s3FT::P64 + 8];
           _s3G3::P64 = _s3G3::P64;
           I64[Hp - 16] = sat_s3G4_info;
           P64[Hp] = _s3G3::P64;
           _c4an::P64 = Hp - 16;
           P64[(old + 32)] = stdout_closure;
           P64[(old + 24)] = _c4an::P64;
           P64[(old + 16)] = True_closure+2;
           call hPutStr2_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.510337 UTC

{offset
  c4ad:
      _s3FW::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c4ae; else goto c4af;
  c4ae:
      R1 = _s3FW::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4af:
      _s3FV::P64 = P64[_s3FW::P64 + 7];
      P64[(old + 16)] = _s3FV::P64;
      call dowrite_entry() args: 16, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:10:09.512312 UTC

{offset
  c4ad:
      _s3FW::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c4ae; else goto c4af;
  c4ae:
      R1 = _s3FW::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4af:
      _s3FV::P64 = P64[_s3FW::P64 + 7];
      P64[(old + 16)] = _s3FV::P64;
      call dowrite_entry() args: 16, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:10:09.513997 UTC

sat_s3FW_entry
[c4ad]
{offset
  c4ad:
      _s3FW::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c4ae; else goto c4af;
  c4ae:
      R1 = _s3FW::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4af:
      _s3FV::P64 = P64[_s3FW::P64 + 7];
      P64[(old + 16)] = _s3FV::P64;
      call dowrite_entry() args: 16, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:10:09.51618 UTC

{offset
  c4ad:
      _s3FW::P64 = R1;
      if ((Sp + 8) - 16 < SpLim) goto c4ae; else goto c4af;
  c4ae:
      R1 = _s3FW::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4af:
      _s3FV::P64 = P64[_s3FW::P64 + 7];
      P64[Sp - 8] = _s3FV::P64;
      Sp = Sp - 8;
      call dowrite_entry() args: 16, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:10:09.518301 UTC

{offset
  c4ad:
      if ((Sp + -8) < SpLim) goto c4ae; else goto c4af;
  c4ae:
      R1 = R1;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4af:
      P64[Sp - 8] = P64[R1 + 7];
      Sp = Sp - 8;
      call dowrite_entry() args: 16, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:10:09.519825 UTC

[(c4ad, {dowrite_closure}), (c4ae, {}), (c4af, {dowrite_closure})]


==================== procpoint map ====================
2016-08-04 14:10:09.520726 UTC

[(c4ad, <procpt>), (c4ae, reached by c4ad),
 (c4af, reached by c4ad)]


==================== Post splitting ====================
2016-08-04 14:10:09.521655 UTC

sat_s3FW_entry() //  [R1]
        { info_tbl: [(c4ad,
                      label: sat_s3FW_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4ad:
          if ((Sp + -8) < SpLim) goto c4ae; else goto c4af;
      c4ae:
          R1 = R1;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c4af:
          P64[Sp - 8] = P64[R1 + 7];
          Sp = Sp - 8;
          call dowrite_entry() args: 16, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:09.52394 UTC

sat_s3FW_entry() //  [R1]
        { info_tbl: [(c4ad,
                      label: sat_s3FW_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4ad:
          if ((Sp + -8) < SpLim) goto c4ae; else goto c4af;
      c4ae:
          R1 = R1;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c4af:
          P64[Sp - 8] = P64[R1 + 7];
          Sp = Sp - 8;
          call dowrite_entry() args: 16, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.526045 UTC

sat_s3FW_entry() //  [R1]
        { info_tbl: [(c4ad,
                      label: sat_s3FW_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4ad:
          if ((Sp + -8) < SpLim) goto c4ae; else goto c4af;
      c4ae:
          R1 = R1;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c4af:
          P64[Sp - 8] = P64[R1 + 7];
          Sp = Sp - 8;
          call dowrite_entry() args: 16, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.528548 UTC

{offset
  c4ag:
      _s3FX::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c4ah; else goto c4ai;
  c4ai:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c4ak; else goto c4aj;
  c4ak:
      HpAlloc = 32;
      goto c4ah;
  c4ah:
      R1 = _s3FX::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4aj:
      _s3FT::P64 = P64[_s3FX::P64 + 7];
      I64[Hp - 24] = STRef_con_info;
      P64[Hp - 16] = _s3FT::P64;
      _c4a7::P64 = Hp - 23;
      I64[Hp - 8] = sat_s3FW_info;
      P64[Hp] = _c4a7::P64;
      _c4a8::P64 = Hp - 7;
      R1 = _c4a8::P64;
      P64[(old + 16)] = childHandler1_closure+2;
      call stg_catch#(R1) args: 16, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:10:09.531789 UTC

{offset
  c4ag:
      _s3FX::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c4ah; else goto c4ai;
  c4ai:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c4ak; else goto c4aj;
  c4ak:
      HpAlloc = 32;
      goto c4ah;
  c4ah:
      R1 = _s3FX::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4aj:
      _s3FT::P64 = P64[_s3FX::P64 + 7];
      I64[Hp - 24] = STRef_con_info;
      P64[Hp - 16] = _s3FT::P64;
      _c4a7::P64 = Hp - 23;
      I64[Hp - 8] = sat_s3FW_info;
      P64[Hp] = _c4a7::P64;
      _c4a8::P64 = Hp - 7;
      R1 = _c4a8::P64;
      P64[(old + 16)] = childHandler1_closure+2;
      call stg_catch#(R1) args: 16, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:10:09.534753 UTC

sat_s3FX_entry
[c4ag]
{offset
  c4ag:
      _s3FX::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c4ah; else goto c4ai;
  c4ai:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c4ak; else goto c4aj;
  c4ak:
      HpAlloc = 32;
      goto c4ah;
  c4ah:
      R1 = _s3FX::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4aj:
      _s3FT::P64 = P64[_s3FX::P64 + 7];
      I64[Hp - 24] = STRef_con_info;
      P64[Hp - 16] = _s3FT::P64;
      _c4a7::P64 = Hp - 23;
      I64[Hp - 8] = sat_s3FW_info;
      P64[Hp] = _c4a7::P64;
      _c4a8::P64 = Hp - 7;
      R1 = _c4a8::P64;
      P64[(old + 16)] = childHandler1_closure+2;
      call stg_catch#(R1) args: 16, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:10:09.538285 UTC

{offset
  c4ag:
      _s3FX::P64 = R1;
      if ((Sp + 8) - 16 < SpLim) goto c4ah; else goto c4ai;
  c4ai:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c4ak; else goto c4aj;
  c4ak:
      HpAlloc = 32;
      goto c4ah;
  c4ah:
      R1 = _s3FX::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4aj:
      _s3FT::P64 = P64[_s3FX::P64 + 7];
      I64[Hp - 24] = STRef_con_info;
      P64[Hp - 16] = _s3FT::P64;
      _c4a7::P64 = Hp - 23;
      I64[Hp - 8] = sat_s3FW_info;
      P64[Hp] = _c4a7::P64;
      _c4a8::P64 = Hp - 7;
      R1 = _c4a8::P64;
      P64[Sp - 8] = childHandler1_closure+2;
      Sp = Sp - 8;
      call stg_catch#(R1) args: 16, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:10:09.541883 UTC

{offset
  c4ag:
      _s3FX::P64 = R1;
      if ((Sp + -8) < SpLim) goto c4ah; else goto c4ai;
  c4ai:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c4ak; else goto c4aj;
  c4ak:
      HpAlloc = 32;
      goto c4ah;
  c4ah:
      R1 = _s3FX::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4aj:
      _s3FT::P64 = P64[_s3FX::P64 + 7];
      I64[Hp - 24] = STRef_con_info;
      P64[Hp - 16] = _s3FT::P64;
      I64[Hp - 8] = sat_s3FW_info;
      P64[Hp] = Hp - 23;
      R1 = Hp - 7;
      P64[Sp - 8] = childHandler1_closure+2;
      Sp = Sp - 8;
      call stg_catch#(R1) args: 16, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:10:09.544626 UTC

[(c4ag, {childHandler1_closure, sat_s3FW_closure}), (c4ah, {}),
 (c4ai, {childHandler1_closure, sat_s3FW_closure}),
 (c4aj, {childHandler1_closure, sat_s3FW_closure}), (c4ak, {})]


==================== procpoint map ====================
2016-08-04 14:10:09.545937 UTC

[(c4ag, <procpt>), (c4ah, reached by c4ag),
 (c4ai, reached by c4ag), (c4aj, reached by c4ag),
 (c4ak, reached by c4ag)]


==================== Post splitting ====================
2016-08-04 14:10:09.547023 UTC

sat_s3FX_entry() //  [R1]
        { info_tbl: [(c4ag,
                      label: sat_s3FX_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4ag:
          _s3FX::P64 = R1;
          if ((Sp + -8) < SpLim) goto c4ah; else goto c4ai;
      c4ai:
          Hp = Hp + 32;
          if (Hp > HpLim) goto c4ak; else goto c4aj;
      c4ak:
          HpAlloc = 32;
          goto c4ah;
      c4ah:
          R1 = _s3FX::P64;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c4aj:
          _s3FT::P64 = P64[_s3FX::P64 + 7];
          I64[Hp - 24] = STRef_con_info;
          P64[Hp - 16] = _s3FT::P64;
          I64[Hp - 8] = sat_s3FW_info;
          P64[Hp] = Hp - 23;
          R1 = Hp - 7;
          P64[Sp - 8] = childHandler1_closure+2;
          Sp = Sp - 8;
          call stg_catch#(R1) args: 16, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:09.550706 UTC

sat_s3FX_entry() //  [R1]
        { info_tbl: [(c4ag,
                      label: sat_s3FX_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4ag:
          _s3FX::P64 = R1;
          if ((Sp + -8) < SpLim) goto c4ah; else goto c4ai;
      c4ai:
          Hp = Hp + 32;
          if (Hp > HpLim) goto c4ak; else goto c4aj;
      c4ak:
          HpAlloc = 32;
          goto c4ah;
      c4ah:
          R1 = _s3FX::P64;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c4aj:
          _s3FT::P64 = P64[_s3FX::P64 + 7];
          I64[Hp - 24] = STRef_con_info;
          P64[Hp - 16] = _s3FT::P64;
          I64[Hp - 8] = sat_s3FW_info;
          P64[Hp] = Hp - 23;
          R1 = Hp - 7;
          P64[Sp - 8] = childHandler1_closure+2;
          Sp = Sp - 8;
          call stg_catch#(R1) args: 16, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.554156 UTC

sat_s3FX_entry() //  [R1]
        { info_tbl: [(c4ag,
                      label: sat_s3FX_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4ag:
          _s3FX::P64 = R1;
          if ((Sp + -8) < SpLim) goto c4ah; else goto c4ai;
      c4ai:
          Hp = Hp + 32;
          if (Hp > HpLim) goto c4ak; else goto c4aj;
      c4ak:
          HpAlloc = 32;
          goto c4ah;
      c4ah:
          R1 = _s3FX::P64;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c4aj:
          _s3FT::P64 = P64[_s3FX::P64 + 7];
          I64[Hp - 24] = STRef_con_info;
          P64[Hp - 16] = _s3FT::P64;
          I64[Hp - 8] = sat_s3FW_info;
          P64[Hp] = Hp - 23;
          R1 = Hp - 7;
          P64[Sp - 8] = childHandler1_closure+2;
          Sp = Sp - 8;
          call stg_catch#(R1) args: 16, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.557827 UTC

{offset
  c4ar:
      _s3G4::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c4as; else goto c4at;
  c4as:
      R1 = _s3G4::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c4at:
      _s3G3::P64 = P64[_s3G4::P64 + 16];
      P64[(old + 16)] = _s3G3::P64;
      call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:10:09.560643 UTC

{offset
  c4ar:
      _s3G4::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c4as; else goto c4at;
  c4as:
      R1 = _s3G4::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c4at:
      _s3G3::P64 = P64[_s3G4::P64 + 16];
      P64[(old + 16)] = _s3G3::P64;
      call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:10:09.562397 UTC

sat_s3G4_entry
[c4ar]
{offset
  c4ar:
      _s3G4::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c4as; else goto c4at;
  c4as:
      R1 = _s3G4::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c4at:
      _s3G3::P64 = P64[_s3G4::P64 + 16];
      P64[(old + 16)] = _s3G3::P64;
      call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:10:09.564545 UTC

{offset
  c4ar:
      _s3G4::P64 = R1;
      if ((Sp + 8) - 16 < SpLim) goto c4as; else goto c4at;
  c4as:
      R1 = _s3G4::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c4at:
      _s3G3::P64 = P64[_s3G4::P64 + 16];
      P64[Sp - 8] = _s3G3::P64;
      Sp = Sp - 8;
      call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:10:09.566627 UTC

{offset
  c4ar:
      if ((Sp + -8) < SpLim) goto c4as; else goto c4at;
  c4as:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c4at:
      P64[Sp - 8] = P64[R1 + 16];
      Sp = Sp - 8;
      call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:10:09.568103 UTC

[(c4ar, {$fShowFoo_$cshow_closure}), (c4as, {}),
 (c4at, {$fShowFoo_$cshow_closure})]


==================== procpoint map ====================
2016-08-04 14:10:09.569129 UTC

[(c4ar, <procpt>), (c4as, reached by c4ar),
 (c4at, reached by c4ar)]


==================== Post splitting ====================
2016-08-04 14:10:09.570017 UTC

sat_s3G4_entry() //  [R1]
        { info_tbl: [(c4ar,
                      label: sat_s3G4_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4ar:
          if ((Sp + -8) < SpLim) goto c4as; else goto c4at;
      c4as:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c4at:
          P64[Sp - 8] = P64[R1 + 16];
          Sp = Sp - 8;
          call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:09.572212 UTC

sat_s3G4_entry() //  [R1]
        { info_tbl: [(c4ar,
                      label: sat_s3G4_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4ar:
          if ((Sp + -8) < SpLim) goto c4as; else goto c4at;
      c4as:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c4at:
          P64[Sp - 8] = P64[R1 + 16];
          Sp = Sp - 8;
          call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.574228 UTC

sat_s3G4_entry() //  [R1]
        { info_tbl: [(c4ar,
                      label: sat_s3G4_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4ar:
          if ((Sp + -8) < SpLim) goto c4as; else goto c4at;
      c4as:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c4at:
          P64[Sp - 8] = P64[R1 + 16];
          Sp = Sp - 8;
          call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.576752 UTC

{offset
  c4au:
      if ((old + 0) - <highSp> < SpLim) goto c4av; else goto c4aw;
  c4av:
      R1 = main1_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4aw:
      I64[(young<c49Y> + 8)] = c49Y;
      P64[(young<c49Y> + 32)] = stdout_closure;
      P64[(young<c49Y> + 24)] = main4_closure+2;
      P64[(young<c49Y> + 16)] = True_closure+2;
      call hPutStr2_entry() returns to c49Y, args: 32, res: 8, upd: 8;
  c49Y:
      _s3FQ::P64 = R1;
      I64[(young<c4a0> + 8)] = c4a0;
      R1 = main2_closure+1;
      call stg_newMutVar#(R1) returns to c4a0, args: 8, res: 8, upd: 8;
  c4a0:
      _s3FT::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto c4aA; else goto c4az;
  c4aA:
      HpAlloc = 16;
      R1 = _s3FT::P64;
      call stg_gc_unpt_r1(R1) returns to c4a0, args: 8, res: 8, upd: 8;
  c4az:
      I64[Hp - 8] = sat_s3FX_info;
      P64[Hp] = _s3FT::P64;
      _c4a2::P64 = Hp - 7;
      I64[(young<c4al> + 8)] = c4al;
      R1 = _c4a2::P64;
      call stg_fork#(R1) returns to c4al, args: 8, res: 8, upd: 8;
  c4al:
      _s3G0::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c4aD; else goto c4aC;
  c4aD:
      HpAlloc = 24;
      R1 = _s3G0::P64;
      call stg_gc_unpt_r1(R1) returns to c4al, args: 8, res: 8, upd: 8;
  c4aC:
      _s3G3::P64 = P64[_s3FT::P64 + 8];
      _s3G3::P64 = _s3G3::P64;
      I64[Hp - 16] = sat_s3G4_info;
      P64[Hp] = _s3G3::P64;
      _c4an::P64 = Hp - 16;
      P64[(old + 32)] = stdout_closure;
      P64[(old + 24)] = _c4an::P64;
      P64[(old + 16)] = True_closure+2;
      call hPutStr2_entry() args: 32, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:10:09.583187 UTC

{offset
  c4au:
      if ((old + 0) - <highSp> < SpLim) goto c4av; else goto c4aw;
  c4av:
      R1 = main1_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4aw:
      I64[(young<c49Y> + 8)] = c49Y;
      P64[(young<c49Y> + 32)] = stdout_closure;
      P64[(young<c49Y> + 24)] = main4_closure+2;
      P64[(young<c49Y> + 16)] = True_closure+2;
      call hPutStr2_entry() returns to c49Y, args: 32, res: 8, upd: 8;
  c49Y:
      _s3FQ::P64 = R1;
      I64[(young<c4a0> + 8)] = c4a0;
      R1 = main2_closure+1;
      call stg_newMutVar#(R1) returns to c4a0, args: 8, res: 8, upd: 8;
  c4a0:
      _s3FT::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto c4aA; else goto c4az;
  c4aA:
      HpAlloc = 16;
      R1 = _s3FT::P64;
      call stg_gc_unpt_r1(R1) returns to c4a0, args: 8, res: 8, upd: 8;
  c4az:
      I64[Hp - 8] = sat_s3FX_info;
      P64[Hp] = _s3FT::P64;
      _c4a2::P64 = Hp - 7;
      I64[(young<c4al> + 8)] = c4al;
      R1 = _c4a2::P64;
      call stg_fork#(R1) returns to c4al, args: 8, res: 8, upd: 8;
  c4al:
      _s3G0::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c4aD; else goto c4aC;
  c4aD:
      HpAlloc = 24;
      R1 = _s3G0::P64;
      call stg_gc_unpt_r1(R1) returns to c4al, args: 8, res: 8, upd: 8;
  c4aC:
      _s3G3::P64 = P64[_s3FT::P64 + 8];
      _s3G3::P64 = _s3G3::P64;
      I64[Hp - 16] = sat_s3G4_info;
      P64[Hp] = _s3G3::P64;
      _c4an::P64 = Hp - 16;
      P64[(old + 32)] = stdout_closure;
      P64[(old + 24)] = _c4an::P64;
      P64[(old + 16)] = True_closure+2;
      call hPutStr2_entry() args: 32, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:10:09.58904 UTC

main1_entry
[c49Y, c4a0, c4al, c4au]
{offset
  c4au:
      if ((old + 0) - <highSp> < SpLim) goto c4av; else goto c4aw;
  c4av:
      R1 = main1_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4aw:
      I64[(young<c49Y> + 8)] = c49Y;
      P64[(young<c49Y> + 32)] = stdout_closure;
      P64[(young<c49Y> + 24)] = main4_closure+2;
      P64[(young<c49Y> + 16)] = True_closure+2;
      call hPutStr2_entry() returns to c49Y, args: 32, res: 8, upd: 8;
  c49Y:
      _s3FQ::P64 = R1;
      I64[(young<c4a0> + 8)] = c4a0;
      R1 = main2_closure+1;
      call stg_newMutVar#(R1) returns to c4a0, args: 8, res: 8, upd: 8;
  c4a0:
      _s3FT::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto c4aA; else goto c4az;
  c4aA:
      HpAlloc = 16;
      R1 = _s3FT::P64;
      call stg_gc_unpt_r1(R1) returns to c4a0, args: 8, res: 8, upd: 8;
  c4az:
      I64[Hp - 8] = sat_s3FX_info;
      P64[Hp] = _s3FT::P64;
      _c4a2::P64 = Hp - 7;
      I64[(young<c4al> + 8)] = c4al;
      R1 = _c4a2::P64;
      call stg_fork#(R1) returns to c4al, args: 8, res: 8, upd: 8;
  c4al:
      _s3G0::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c4aD; else goto c4aC;
  c4aD:
      HpAlloc = 24;
      R1 = _s3G0::P64;
      call stg_gc_unpt_r1(R1) returns to c4al, args: 8, res: 8, upd: 8;
  c4aC:
      _s3G3::P64 = P64[_s3FT::P64 + 8];
      _s3G3::P64 = _s3G3::P64;
      I64[Hp - 16] = sat_s3G4_info;
      P64[Hp] = _s3G3::P64;
      _c4an::P64 = Hp - 16;
      P64[(old + 32)] = stdout_closure;
      P64[(old + 24)] = _c4an::P64;
      P64[(old + 16)] = True_closure+2;
      call hPutStr2_entry() args: 32, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:10:09.596143 UTC

{offset
  c4au:
      if ((Sp + 8) - 40 < SpLim) goto c4av; else goto c4aw;
  c4av:
      R1 = main1_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4aw:
      I64[Sp - 8] = c49Y;
      P64[Sp - 32] = stdout_closure;
      P64[Sp - 24] = main4_closure+2;
      P64[Sp - 16] = True_closure+2;
      Sp = Sp - 32;
      call hPutStr2_entry() returns to c49Y, args: 32, res: 8, upd: 8;
  c49Y:
      _s3FQ::P64 = R1;
      I64[Sp] = c4a0;
      R1 = main2_closure+1;
      call stg_newMutVar#(R1) returns to c4a0, args: 8, res: 8, upd: 8;
  c4a0:
      _s3FT::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto c4aA; else goto c4az;
  c4aA:
      HpAlloc = 16;
      R1 = _s3FT::P64;
      call stg_gc_unpt_r1(R1) returns to c4a0, args: 8, res: 8, upd: 8;
  c4az:
      I64[Hp - 8] = sat_s3FX_info;
      P64[Hp] = _s3FT::P64;
      _c4a2::P64 = Hp - 7;
      I64[Sp - 8] = c4al;
      R1 = _c4a2::P64;
      P64[Sp] = _s3FT::P64;
      Sp = Sp - 8;
      call stg_fork#(R1) returns to c4al, args: 8, res: 8, upd: 8;
  c4al:
      _s3FT::P64 = P64[Sp + 8];
      _s3G0::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c4aD; else goto c4aC;
  c4aD:
      HpAlloc = 24;
      R1 = _s3G0::P64;
      call stg_gc_unpt_r1(R1) returns to c4al, args: 8, res: 8, upd: 8;
  c4aC:
      _s3G3::P64 = P64[_s3FT::P64 + 8];
      _s3G3::P64 = _s3G3::P64;
      I64[Hp - 16] = sat_s3G4_info;
      P64[Hp] = _s3G3::P64;
      _c4an::P64 = Hp - 16;
      P64[Sp - 8] = stdout_closure;
      P64[Sp] = _c4an::P64;
      P64[Sp + 8] = True_closure+2;
      Sp = Sp - 8;
      call hPutStr2_entry() args: 32, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:10:09.603367 UTC

{offset
  c4au:
      if ((Sp + -32) < SpLim) goto c4av; else goto c4aw;
  c4av:
      R1 = main1_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4aw:
      I64[Sp - 8] = c49Y;
      P64[Sp - 32] = stdout_closure;
      P64[Sp - 24] = main4_closure+2;
      P64[Sp - 16] = True_closure+2;
      Sp = Sp - 32;
      call hPutStr2_entry() returns to c49Y, args: 32, res: 8, upd: 8;
  c49Y:
      I64[Sp] = c4a0;
      R1 = main2_closure+1;
      call stg_newMutVar#(R1) returns to c4a0, args: 8, res: 8, upd: 8;
  c4a0:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c4aA; else goto c4az;
  c4aA:
      HpAlloc = 16;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to c4a0, args: 8, res: 8, upd: 8;
  c4az:
      I64[Hp - 8] = sat_s3FX_info;
      P64[Hp] = R1;
      I64[Sp - 8] = c4al;
      _s3FT::P64 = R1;
      R1 = Hp - 7;
      P64[Sp] = _s3FT::P64;
      Sp = Sp - 8;
      call stg_fork#(R1) returns to c4al, args: 8, res: 8, upd: 8;
  c4al:
      Hp = Hp + 24;
      if (Hp > HpLim) goto c4aD; else goto c4aC;
  c4aD:
      HpAlloc = 24;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to c4al, args: 8, res: 8, upd: 8;
  c4aC:
      I64[Hp - 16] = sat_s3G4_info;
      P64[Hp] = P64[P64[Sp + 8] + 8];
      P64[Sp - 8] = stdout_closure;
      P64[Sp] = Hp - 16;
      P64[Sp + 8] = True_closure+2;
      Sp = Sp - 8;
      call hPutStr2_entry() args: 32, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:10:09.608662 UTC

[(c49Y,
  {hPutStr2_closure, stdout_closure, sat_s3FX_closure,
   sat_s3G4_closure}),
 (c4a0,
  {hPutStr2_closure, stdout_closure, sat_s3FX_closure,
   sat_s3G4_closure}),
 (c4al, {hPutStr2_closure, stdout_closure, sat_s3G4_closure}),
 (c4au,
  {hPutStr2_closure, stdout_closure, main1_closure, main4_closure,
   sat_s3FX_closure, sat_s3G4_closure}),
 (c4av, {main1_closure}),
 (c4aw,
  {hPutStr2_closure, stdout_closure, main4_closure, sat_s3FX_closure,
   sat_s3G4_closure}),
 (c4az,
  {hPutStr2_closure, stdout_closure, sat_s3FX_closure,
   sat_s3G4_closure}),
 (c4aA,
  {hPutStr2_closure, stdout_closure, sat_s3FX_closure,
   sat_s3G4_closure}),
 (c4aC, {hPutStr2_closure, stdout_closure, sat_s3G4_closure}),
 (c4aD, {hPutStr2_closure, stdout_closure, sat_s3G4_closure})]


==================== procpoint map ====================
2016-08-04 14:10:09.612358 UTC

[(c49Y, <procpt>), (c4a0, <procpt>), (c4al, <procpt>),
 (c4au, <procpt>), (c4av, reached by c4au), (c4aw, reached by c4au),
 (c4az, reached by c4a0), (c4aA, reached by c4a0),
 (c4aC, reached by c4al), (c4aD, reached by c4al)]


==================== Post splitting ====================
2016-08-04 14:10:09.613872 UTC

main1_entry() //  []
        { info_tbl: [(c4au,
                      label: main1_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4au:
          if ((Sp + -32) < SpLim) goto c4av; else goto c4aw;
      c4av:
          R1 = main1_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c4aw:
          I64[Sp - 8] = block_c49Y_info;
          P64[Sp - 32] = stdout_closure;
          P64[Sp - 24] = main4_closure+2;
          P64[Sp - 16] = True_closure+2;
          Sp = Sp - 32;
          call hPutStr2_entry() args: 32, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-04 14:10:09.616792 UTC

block_c49Y_entry() //  []
        { info_tbl: [(c49Y,
                      label: block_c49Y_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c49Y:
          I64[Sp] = block_c4a0_info;
          R1 = main2_closure+1;
          call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-04 14:10:09.618289 UTC

block_c4a0_entry() //  [R1]
        { info_tbl: [(c4a0,
                      label: block_c4a0_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4a0:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c4aA; else goto c4az;
      c4aA:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c4az:
          I64[Hp - 8] = sat_s3FX_info;
          P64[Hp] = R1;
          I64[Sp - 8] = block_c4al_info;
          _s3FT::P64 = R1;
          R1 = Hp - 7;
          P64[Sp] = _s3FT::P64;
          Sp = Sp - 8;
          call stg_fork#(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-04 14:10:09.620958 UTC

block_c4al_entry() //  [R1]
        { info_tbl: [(c4al,
                      label: block_c4al_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4al:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c4aD; else goto c4aC;
      c4aD:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c4aC:
          I64[Hp - 16] = sat_s3G4_info;
          P64[Hp] = P64[P64[Sp + 8] + 8];
          P64[Sp - 8] = stdout_closure;
          P64[Sp] = Hp - 16;
          P64[Sp + 8] = True_closure+2;
          Sp = Sp - 8;
          call hPutStr2_entry() args: 32, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:09.623696 UTC

main1_entry() //  []
        { info_tbl: [(c4au,
                      label: main1_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4au:
          if ((Sp + -32) < SpLim) goto c4av; else goto c4aw;
      c4av:
          R1 = main1_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c4aw:
          I64[Sp - 8] = block_c49Y_info;
          P64[Sp - 32] = stdout_closure;
          P64[Sp - 24] = main4_closure+2;
          P64[Sp - 16] = True_closure+2;
          Sp = Sp - 32;
          call hPutStr2_entry() args: 32, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:09.626146 UTC

block_c49Y_entry() //  []
        { info_tbl: [(c49Y,
                      label: block_c49Y_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c49Y:
          I64[Sp] = block_c4a0_info;
          R1 = main2_closure+1;
          call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:09.628481 UTC

block_c4a0_entry() //  [R1]
        { info_tbl: [(c4a0,
                      label: block_c4a0_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4a0:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c4aA; else goto c4az;
      c4aA:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c4az:
          I64[Hp - 8] = sat_s3FX_info;
          P64[Hp] = R1;
          I64[Sp - 8] = block_c4al_info;
          _s3FT::P64 = R1;
          R1 = Hp - 7;
          P64[Sp] = _s3FT::P64;
          Sp = Sp - 8;
          call stg_fork#(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:09.631188 UTC

block_c4al_entry() //  [R1]
        { info_tbl: [(c4al,
                      label: block_c4al_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4al:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c4aD; else goto c4aC;
      c4aD:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c4aC:
          I64[Hp - 16] = sat_s3G4_info;
          P64[Hp] = P64[P64[Sp + 8] + 8];
          P64[Sp - 8] = stdout_closure;
          P64[Sp] = Hp - 16;
          P64[Sp + 8] = True_closure+2;
          Sp = Sp - 8;
          call hPutStr2_entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.633892 UTC

main1_entry() //  []
        { info_tbl: [(c4au,
                      label: main1_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4au:
          if ((Sp + -32) < SpLim) goto c4av; else goto c4aw;
      c4av:
          R1 = main1_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c4aw:
          I64[Sp - 8] = block_c49Y_info;
          P64[Sp - 32] = stdout_closure;
          P64[Sp - 24] = main4_closure+2;
          P64[Sp - 16] = True_closure+2;
          Sp = Sp - 32;
          call hPutStr2_entry() args: 32, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.636367 UTC

block_c49Y_entry() //  []
        { info_tbl: [(c49Y,
                      label: block_c49Y_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c49Y:
          I64[Sp] = block_c4a0_info;
          R1 = main2_closure+1;
          call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.637863 UTC

block_c4a0_entry() //  [R1]
        { info_tbl: [(c4a0,
                      label: block_c4a0_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4a0:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c4aA; else goto c4az;
      c4aA:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c4az:
          I64[Hp - 8] = sat_s3FX_info;
          P64[Hp] = R1;
          I64[Sp - 8] = block_c4al_info;
          _s3FT::P64 = R1;
          R1 = Hp - 7;
          P64[Sp] = _s3FT::P64;
          Sp = Sp - 8;
          call stg_fork#(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.640515 UTC

block_c4al_entry() //  [R1]
        { info_tbl: [(c4al,
                      label: block_c4al_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4al:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c4aD; else goto c4aC;
      c4aD:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c4aC:
          I64[Hp - 16] = sat_s3G4_info;
          P64[Hp] = P64[P64[Sp + 8] + 8];
          P64[Sp - 8] = stdout_closure;
          P64[Sp] = Hp - 16;
          P64[Sp + 8] = True_closure+2;
          Sp = Sp - 8;
          call hPutStr2_entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:10:09.643224 UTC

[section "data" {
     main1_closure:
         const main1_info;
         const 0;
 },
 sat_s3FW_entry() //  [R1]
         { info_tbl: [(c4ad,
                       label: sat_s3FW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ad:
           if ((Sp + -8) < SpLim) goto c4ae; else goto c4af;
       c4ae:
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4af:
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 8;
           call dowrite_entry() args: 16, res: 0, upd: 8;
     }
 },
 sat_s3FX_entry() //  [R1]
         { info_tbl: [(c4ag,
                       label: sat_s3FX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ag:
           _s3FX::P64 = R1;
           if ((Sp + -8) < SpLim) goto c4ah; else goto c4ai;
       c4ai:
           Hp = Hp + 32;
           if (Hp > HpLim) goto c4ak; else goto c4aj;
       c4ak:
           HpAlloc = 32;
           goto c4ah;
       c4ah:
           R1 = _s3FX::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4aj:
           _s3FT::P64 = P64[_s3FX::P64 + 7];
           I64[Hp - 24] = STRef_con_info;
           P64[Hp - 16] = _s3FT::P64;
           I64[Hp - 8] = sat_s3FW_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           P64[Sp - 8] = childHandler1_closure+2;
           Sp = Sp - 8;
           call stg_catch#(R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_s3G4_entry() //  [R1]
         { info_tbl: [(c4ar,
                       label: sat_s3G4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ar:
           if ((Sp + -8) < SpLim) goto c4as; else goto c4at;
       c4as:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4at:
           P64[Sp - 8] = P64[R1 + 16];
           Sp = Sp - 8;
           call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
     }
 },
 main1_entry() //  []
         { info_tbl: [(c4au,
                       label: main1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4au:
           if ((Sp + -32) < SpLim) goto c4av; else goto c4aw;
       c4av:
           R1 = main1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4aw:
           I64[Sp - 8] = block_c49Y_info;
           P64[Sp - 32] = stdout_closure;
           P64[Sp - 24] = main4_closure+2;
           P64[Sp - 16] = True_closure+2;
           Sp = Sp - 32;
           call hPutStr2_entry() args: 32, res: 8, upd: 8;
     }
 },
 block_c49Y_entry() //  []
         { info_tbl: [(c49Y,
                       label: block_c49Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c49Y:
           I64[Sp] = block_c4a0_info;
           R1 = main2_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c4a0_entry() //  [R1]
         { info_tbl: [(c4a0,
                       label: block_c4a0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a0:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c4aA; else goto c4az;
       c4aA:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4az:
           I64[Hp - 8] = sat_s3FX_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c4al_info;
           _s3FT::P64 = R1;
           R1 = Hp - 7;
           P64[Sp] = _s3FT::P64;
           Sp = Sp - 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c4al_entry() //  [R1]
         { info_tbl: [(c4al,
                       label: block_c4al_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4al:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c4aD; else goto c4aC;
       c4aD:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4aC:
           I64[Hp - 16] = sat_s3G4_info;
           P64[Hp] = P64[P64[Sp + 8] + 8];
           P64[Sp - 8] = stdout_closure;
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = True_closure+2;
           Sp = Sp - 8;
           call hPutStr2_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:10:09.6578 UTC

[section "data" {
     main1_closure:
         const main1_info;
         const 0;
 },
 sat_s3FW_entry() //  [R1]
         { info_tbl: [(c4ad,
                       label: sat_s3FW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ad:
           if ((Sp + -8) < SpLim) goto c4ae; else goto c4af;
       c4ae:
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4af:
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 8;
           call dowrite_entry() args: 16, res: 0, upd: 8;
     }
 },
 sat_s3FX_entry() //  [R1]
         { info_tbl: [(c4ag,
                       label: sat_s3FX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ag:
           _s3FX::P64 = R1;
           if ((Sp + -8) < SpLim) goto c4ah; else goto c4ai;
       c4ai:
           Hp = Hp + 32;
           if (Hp > HpLim) goto c4ak; else goto c4aj;
       c4ak:
           HpAlloc = 32;
           goto c4ah;
       c4ah:
           R1 = _s3FX::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4aj:
           _s3FT::P64 = P64[_s3FX::P64 + 7];
           I64[Hp - 24] = STRef_con_info;
           P64[Hp - 16] = _s3FT::P64;
           I64[Hp - 8] = sat_s3FW_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           P64[Sp - 8] = childHandler1_closure+2;
           Sp = Sp - 8;
           call stg_catch#(R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_s3G4_entry() //  [R1]
         { info_tbl: [(c4ar,
                       label: sat_s3G4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ar:
           if ((Sp + -8) < SpLim) goto c4as; else goto c4at;
       c4as:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4at:
           P64[Sp - 8] = P64[R1 + 16];
           Sp = Sp - 8;
           call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
     }
 },
 main1_entry() //  []
         { info_tbl: [(c4au,
                       label: main1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4au:
           if ((Sp + -32) < SpLim) goto c4av; else goto c4aw;
       c4av:
           R1 = main1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4aw:
           I64[Sp - 8] = block_c49Y_info;
           P64[Sp - 32] = stdout_closure;
           P64[Sp - 24] = main4_closure+2;
           P64[Sp - 16] = True_closure+2;
           Sp = Sp - 32;
           call hPutStr2_entry() args: 32, res: 8, upd: 8;
     }
 },
 block_c49Y_entry() //  []
         { info_tbl: [(c49Y,
                       label: block_c49Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c49Y:
           I64[Sp] = block_c4a0_info;
           R1 = main2_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c4a0_entry() //  [R1]
         { info_tbl: [(c4a0,
                       label: block_c4a0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a0:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c4aA; else goto c4az;
       c4aA:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4az:
           I64[Hp - 8] = sat_s3FX_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c4al_info;
           _s3FT::P64 = R1;
           R1 = Hp - 7;
           P64[Sp] = _s3FT::P64;
           Sp = Sp - 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c4al_entry() //  [R1]
         { info_tbl: [(c4al,
                       label: block_c4al_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4al:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c4aD; else goto c4aC;
       c4aD:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4aC:
           I64[Hp - 16] = sat_s3G4_info;
           P64[Hp] = P64[P64[Sp + 8] + 8];
           P64[Sp - 8] = stdout_closure;
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = True_closure+2;
           Sp = Sp - 8;
           call hPutStr2_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:10:09.788492 UTC

[section "data" {
     main_closure:
         const main_info;
         const 0;
 },
 main_entry() //  []
         { info_tbl: [(c4hx,
                       label: main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4hx:
           goto c4hv;
       c4hv:
           if ((old + 0) - <highSp> < SpLim) goto c4hy; else goto c4hz;
       c4hy:
           R1 = main_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4hz:
           goto c4hu;
       c4hu:
           call main1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.791605 UTC

{offset
  c4hx:
      if ((old + 0) - <highSp> < SpLim) goto c4hy; else goto c4hz;
  c4hy:
      R1 = main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4hz:
      call main1_entry() args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:10:09.793092 UTC

{offset
  c4hx:
      if ((old + 0) - <highSp> < SpLim) goto c4hy; else goto c4hz;
  c4hy:
      R1 = main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4hz:
      call main1_entry() args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:10:09.79437 UTC

main_entry
[c4hx]
{offset
  c4hx:
      if ((old + 0) - <highSp> < SpLim) goto c4hy; else goto c4hz;
  c4hy:
      R1 = main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4hz:
      call main1_entry() args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:10:09.79602 UTC

{offset
  c4hx:
      goto c4hz;
  c4hz:
      call main1_entry() args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:10:09.796997 UTC

{offset
  c4hx:
      goto c4hz;
  c4hz:
      call main1_entry() args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:10:09.797867 UTC

[(c4hx, {main1_closure}), (c4hz, {main1_closure})]


==================== procpoint map ====================
2016-08-04 14:10:09.798717 UTC

[(c4hx, <procpt>), (c4hz, reached by c4hx)]


==================== Post splitting ====================
2016-08-04 14:10:09.79952 UTC

main_entry() //  []
        { info_tbl: [(c4hx,
                      label: main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4hx:
          goto c4hz;
      c4hz:
          call main1_entry() args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:09.800997 UTC

main_entry() //  []
        { info_tbl: [(c4hx,
                      label: main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4hx:
          goto c4hz;
      c4hz:
          call main1_entry() args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.802423 UTC

main_entry() //  []
        { info_tbl: [(c4hx,
                      label: main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4hx:
          call main1_entry() args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:10:09.803787 UTC

[section "data" {
     main_closure:
         const main_info;
         const 0;
 },
 main_entry() //  []
         { info_tbl: [(c4hx,
                       label: main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4hx:
           call main1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:10:09.80552 UTC

[section "data" {
     main_closure:
         const main_info;
         const 0;
 },
 main_entry() //  []
         { info_tbl: [(c4hx,
                       label: main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4hx:
           call main1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:10:09.812699 UTC

[section "data" {
     main8_closure:
         const main8_info;
         const 0;
 },
 main8_entry() //  []
         { info_tbl: [(c4hF,
                       label: main8_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4hF:
           goto c4hD;
       c4hD:
           if ((old + 0) - <highSp> < SpLim) goto c4hG; else goto c4hH;
       c4hG:
           R1 = main8_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4hH:
           goto c4hC;
       c4hC:
           P64[(old + 16)] = main1_closure+1;
           call runMainIO1_entry() args: 16, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.815716 UTC

{offset
  c4hF:
      if ((old + 0) - <highSp> < SpLim) goto c4hG; else goto c4hH;
  c4hG:
      R1 = main8_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4hH:
      P64[(old + 16)] = main1_closure+1;
      call runMainIO1_entry() args: 16, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:10:09.817303 UTC

{offset
  c4hF:
      if ((old + 0) - <highSp> < SpLim) goto c4hG; else goto c4hH;
  c4hG:
      R1 = main8_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4hH:
      P64[(old + 16)] = main1_closure+1;
      call runMainIO1_entry() args: 16, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:10:09.818747 UTC

main8_entry
[c4hF]
{offset
  c4hF:
      if ((old + 0) - <highSp> < SpLim) goto c4hG; else goto c4hH;
  c4hG:
      R1 = main8_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4hH:
      P64[(old + 16)] = main1_closure+1;
      call runMainIO1_entry() args: 16, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:10:09.820568 UTC

{offset
  c4hF:
      if ((Sp + 8) - 16 < SpLim) goto c4hG; else goto c4hH;
  c4hG:
      R1 = main8_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4hH:
      P64[Sp - 8] = main1_closure+1;
      Sp = Sp - 8;
      call runMainIO1_entry() args: 16, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:10:09.823146 UTC

{offset
  c4hF:
      if ((Sp + -8) < SpLim) goto c4hG; else goto c4hH;
  c4hG:
      R1 = main8_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4hH:
      P64[Sp - 8] = main1_closure+1;
      Sp = Sp - 8;
      call runMainIO1_entry() args: 16, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:10:09.824641 UTC

[(c4hF, {runMainIO1_closure, main1_closure, main8_closure}),
 (c4hG, {main8_closure}),
 (c4hH, {runMainIO1_closure, main1_closure})]


==================== procpoint map ====================
2016-08-04 14:10:09.825757 UTC

[(c4hF, <procpt>), (c4hG, reached by c4hF),
 (c4hH, reached by c4hF)]


==================== Post splitting ====================
2016-08-04 14:10:09.826641 UTC

main8_entry() //  []
        { info_tbl: [(c4hF,
                      label: main8_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4hF:
          if ((Sp + -8) < SpLim) goto c4hG; else goto c4hH;
      c4hG:
          R1 = main8_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c4hH:
          P64[Sp - 8] = main1_closure+1;
          Sp = Sp - 8;
          call runMainIO1_entry() args: 16, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:09.828885 UTC

main8_entry() //  []
        { info_tbl: [(c4hF,
                      label: main8_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4hF:
          if ((Sp + -8) < SpLim) goto c4hG; else goto c4hH;
      c4hG:
          R1 = main8_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c4hH:
          P64[Sp - 8] = main1_closure+1;
          Sp = Sp - 8;
          call runMainIO1_entry() args: 16, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.830911 UTC

main8_entry() //  []
        { info_tbl: [(c4hF,
                      label: main8_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4hF:
          if ((Sp + -8) < SpLim) goto c4hG; else goto c4hH;
      c4hG:
          R1 = main8_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c4hH:
          P64[Sp - 8] = main1_closure+1;
          Sp = Sp - 8;
          call runMainIO1_entry() args: 16, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:10:09.833074 UTC

[section "data" {
     main8_closure:
         const main8_info;
         const 0;
 },
 main8_entry() //  []
         { info_tbl: [(c4hF,
                       label: main8_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4hF:
           if ((Sp + -8) < SpLim) goto c4hG; else goto c4hH;
       c4hG:
           R1 = main8_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4hH:
           P64[Sp - 8] = main1_closure+1;
           Sp = Sp - 8;
           call runMainIO1_entry() args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:10:09.835542 UTC

[section "data" {
     main8_closure:
         const main8_info;
         const 0;
 },
 main8_entry() //  []
         { info_tbl: [(c4hF,
                       label: main8_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4hF:
           if ((Sp + -8) < SpLim) goto c4hG; else goto c4hH;
       c4hG:
           R1 = main8_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4hH:
           P64[Sp - 8] = main1_closure+1;
           Sp = Sp - 8;
           call runMainIO1_entry() args: 16, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:10:09.850702 UTC

[section "data" {
     main_closure:
         const main_info;
         const 0;
 },
 main_entry() //  []
         { info_tbl: [(c4im,
                       label: main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4im:
           goto c4ik;
       c4ik:
           if ((old + 0) - <highSp> < SpLim) goto c4in; else goto c4io;
       c4in:
           R1 = main_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4io:
           goto c4ij;
       c4ij:
           call main8_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.853496 UTC

{offset
  c4im:
      if ((old + 0) - <highSp> < SpLim) goto c4in; else goto c4io;
  c4in:
      R1 = main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4io:
      call main8_entry() args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:10:09.854918 UTC

{offset
  c4im:
      if ((old + 0) - <highSp> < SpLim) goto c4in; else goto c4io;
  c4in:
      R1 = main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4io:
      call main8_entry() args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:10:09.856174 UTC

main_entry
[c4im]
{offset
  c4im:
      if ((old + 0) - <highSp> < SpLim) goto c4in; else goto c4io;
  c4in:
      R1 = main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4io:
      call main8_entry() args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:10:09.857792 UTC

{offset
  c4im:
      goto c4io;
  c4io:
      call main8_entry() args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:10:09.858773 UTC

{offset
  c4im:
      goto c4io;
  c4io:
      call main8_entry() args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:10:09.859632 UTC

[(c4im, {main8_closure}), (c4io, {main8_closure})]


==================== procpoint map ====================
2016-08-04 14:10:09.860443 UTC

[(c4im, <procpt>), (c4io, reached by c4im)]


==================== Post splitting ====================
2016-08-04 14:10:09.861245 UTC

main_entry() //  []
        { info_tbl: [(c4im,
                      label: main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4im:
          goto c4io;
      c4io:
          call main8_entry() args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:09.862704 UTC

main_entry() //  []
        { info_tbl: [(c4im,
                      label: main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4im:
          goto c4io;
      c4io:
          call main8_entry() args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.864073 UTC

main_entry() //  []
        { info_tbl: [(c4im,
                      label: main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4im:
          call main8_entry() args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:10:09.866243 UTC

[section "data" {
     main_closure:
         const main_info;
         const 0;
 },
 main_entry() //  []
         { info_tbl: [(c4im,
                       label: main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4im:
           call main8_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:10:09.867928 UTC

[section "data" {
     main_closure:
         const main_info;
         const 0;
 },
 main_entry() //  []
         { info_tbl: [(c4im,
                       label: main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4im:
           call main8_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:10:09.874965 UTC

[section "data" {
     Foo_closure:
         const Foo_info;
 },
 Foo_entry() //  []
         { info_tbl: [(c4iv,
                       label: Foo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 16 updfr_space: Just 8
         }
     {offset
       c4iv:
           _B1::P64 = P64[(old + 16)];
           goto c4is;
       c4is:
           if ((old + 0) - <highSp> < SpLim) goto c4iw; else goto c4ix;
       c4ix:
           goto c4ir;
       c4ir:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c4iz; else goto c4iy;
       c4iz:
           HpAlloc = 16;
           goto c4iw;
       c4iw:
           R1 = Foo_closure;
           P64[(old + 16)] = _B1::P64;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c4iy:
           I64[Hp - 8] = Foo_con_info;
           P64[Hp] = _B1::P64;
           _c4iu::P64 = Hp - 7;
           R1 = _c4iu::P64;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.879191 UTC

{offset
  c4iv:
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c4iw; else goto c4ix;
  c4ix:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c4iz; else goto c4iy;
  c4iz:
      HpAlloc = 16;
      goto c4iw;
  c4iw:
      R1 = Foo_closure;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c4iy:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c4iu::P64 = Hp - 7;
      R1 = _c4iu::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:10:09.881925 UTC

{offset
  c4iv:
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c4iw; else goto c4ix;
  c4ix:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c4iz; else goto c4iy;
  c4iz:
      HpAlloc = 16;
      goto c4iw;
  c4iw:
      R1 = Foo_closure;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c4iy:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c4iu::P64 = Hp - 7;
      R1 = _c4iu::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:10:09.884418 UTC

Foo_entry
[c4iv]
{offset
  c4iv:
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c4iw; else goto c4ix;
  c4ix:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c4iz; else goto c4iy;
  c4iz:
      HpAlloc = 16;
      goto c4iw;
  c4iw:
      R1 = Foo_closure;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c4iy:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c4iu::P64 = Hp - 7;
      R1 = _c4iu::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:10:09.887435 UTC

{offset
  c4iv:
      _B1::P64 = P64[Sp];
      goto c4ix;
  c4ix:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c4iz; else goto c4iy;
  c4iz:
      HpAlloc = 16;
      goto c4iw;
  c4iw:
      R1 = Foo_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c4iy:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c4iu::P64 = Hp - 7;
      R1 = _c4iu::P64;
      Sp = Sp + 8;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:10:09.89008 UTC

{offset
  c4iv:
      goto c4ix;
  c4ix:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c4iz; else goto c4iy;
  c4iz:
      HpAlloc = 16;
      goto c4iw;
  c4iw:
      R1 = Foo_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c4iy:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = P64[Sp];
      R1 = Hp - 7;
      Sp = Sp + 8;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:10:09.892043 UTC

[(c4iv, {}), (c4iw, {}), (c4ix, {}), (c4iy, {}), (c4iz, {})]


==================== procpoint map ====================
2016-08-04 14:10:09.892991 UTC

[(c4iv, <procpt>), (c4iw, reached by c4iv),
 (c4ix, reached by c4iv), (c4iy, reached by c4iv),
 (c4iz, reached by c4iv)]


==================== Post splitting ====================
2016-08-04 14:10:09.894049 UTC

Foo_entry() //  []
        { info_tbl: [(c4iv,
                      label: Foo_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4iv:
          goto c4ix;
      c4ix:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c4iz; else goto c4iy;
      c4iz:
          HpAlloc = 16;
          goto c4iw;
      c4iw:
          R1 = Foo_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c4iy:
          I64[Hp - 8] = Foo_con_info;
          P64[Hp] = P64[Sp];
          R1 = Hp - 7;
          Sp = Sp + 8;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:09.896765 UTC

Foo_entry() //  []
        { info_tbl: [(c4iv,
                      label: Foo_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4iv:
          goto c4ix;
      c4ix:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c4iz; else goto c4iy;
      c4iz:
          HpAlloc = 16;
          goto c4iw;
      c4iw:
          R1 = Foo_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c4iy:
          I64[Hp - 8] = Foo_con_info;
          P64[Hp] = P64[Sp];
          R1 = Hp - 7;
          Sp = Sp + 8;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.899269 UTC

Foo_entry() //  []
        { info_tbl: [(c4iv,
                      label: Foo_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4iv:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c4iz; else goto c4iy;
      c4iz:
          HpAlloc = 16;
          R1 = Foo_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c4iy:
          I64[Hp - 8] = Foo_con_info;
          P64[Hp] = P64[Sp];
          R1 = Hp - 7;
          Sp = Sp + 8;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:10:09.90171 UTC

[section "data" {
     Foo_closure:
         const Foo_info;
 },
 Foo_entry() //  []
         { info_tbl: [(c4iv,
                       label: Foo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4iv:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c4iz; else goto c4iy;
       c4iz:
           HpAlloc = 16;
           R1 = Foo_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c4iy:
           I64[Hp - 8] = Foo_con_info;
           P64[Hp] = P64[Sp];
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:10:09.90433 UTC

[section "data" {
     Foo_closure:
         const Foo_info;
 },
 Foo_entry() //  []
         { info_tbl: [(c4iv,
                       label: Foo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4iv:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c4iz; else goto c4iy;
       c4iz:
           HpAlloc = 16;
           R1 = Foo_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c4iy:
           I64[Hp - 8] = Foo_con_info;
           P64[Hp] = P64[Sp];
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:10:09.927393 UTC

[Foo_con_entry() //  []
         { info_tbl: [(c4jK,
                       label: Foo_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4jK:
           R1 = R1 + 1;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foo_static_entry() //  []
         { info_tbl: [(c4jL,
                       label: Foo_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4jL:
           R1 = R1 + 1;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.930987 UTC

{offset
  c4jK:
      R1 = R1 + 1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:10:09.932111 UTC

{offset
  c4jK:
      R1 = R1 + 1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:10:09.933149 UTC

Foo_con_entry
[c4jK]
{offset
  c4jK:
      R1 = R1 + 1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:10:09.934378 UTC

{offset
  c4jK:
      R1 = R1 + 1;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:10:09.93543 UTC

{offset
  c4jK:
      R1 = R1 + 1;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:10:09.936367 UTC

[(c4jK, {})]


==================== procpoint map ====================
2016-08-04 14:10:09.937044 UTC

[(c4jK, <procpt>)]


==================== Post splitting ====================
2016-08-04 14:10:09.937736 UTC

Foo_con_entry() //  [R1]
        { info_tbl: [(c4jK,
                      label: Foo_con_info
                      rep:HeapRep 1 ptrs {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4jK:
          R1 = R1 + 1;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:09.939436 UTC

Foo_con_entry() //  [R1]
        { info_tbl: [(c4jK,
                      label: Foo_con_info
                      rep:HeapRep 1 ptrs {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4jK:
          R1 = R1 + 1;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.941023 UTC

Foo_con_entry() //  [R1]
        { info_tbl: [(c4jK,
                      label: Foo_con_info
                      rep:HeapRep 1 ptrs {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4jK:
          R1 = R1 + 1;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.942765 UTC

{offset
  c4jL:
      R1 = R1 + 1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:10:09.943839 UTC

{offset
  c4jL:
      R1 = R1 + 1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:10:09.944816 UTC

Foo_static_entry
[c4jL]
{offset
  c4jL:
      R1 = R1 + 1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:10:09.94603 UTC

{offset
  c4jL:
      R1 = R1 + 1;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:10:09.947072 UTC

{offset
  c4jL:
      R1 = R1 + 1;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:10:09.948034 UTC

[(c4jL, {})]


==================== procpoint map ====================
2016-08-04 14:10:09.948738 UTC

[(c4jL, <procpt>)]


==================== Post splitting ====================
2016-08-04 14:10:09.949427 UTC

Foo_static_entry() //  [R1]
        { info_tbl: [(c4jL,
                      label: Foo_static_info
                      rep:HeapRep static {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4jL:
          R1 = R1 + 1;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:10:09.951095 UTC

Foo_static_entry() //  [R1]
        { info_tbl: [(c4jL,
                      label: Foo_static_info
                      rep:HeapRep static {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4jL:
          R1 = R1 + 1;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:10:09.95266 UTC

Foo_static_entry() //  [R1]
        { info_tbl: [(c4jL,
                      label: Foo_static_info
                      rep:HeapRep static {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4jL:
          R1 = R1 + 1;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:10:09.954263 UTC

[Foo_con_entry() //  [R1]
         { info_tbl: [(c4jK,
                       label: Foo_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4jK:
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foo_static_entry() //  [R1]
         { info_tbl: [(c4jL,
                       label: Foo_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4jL:
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:10:09.957952 UTC

[Foo_con_entry() //  [R1]
         { info_tbl: [(c4jK,
                       label: Foo_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4jK:
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foo_static_entry() //  [R1]
         { info_tbl: [(c4jL,
                       label: Foo_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4jL:
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:10:09.976867 UTC

[section "relreadonly" {
     S3JD_srt:
         const $fShowFoo2_closure;
         const $w$cshowsPrec_closure;
         const $fShowFoo1_closure;
         const $fShowFoo_$cshowList_closure;
         const $fShowFoo_$cshow_closure;
         const lvl1_r3EO_closure;
         const a_r3EP_closure;
         const showLitString_closure;
         const main7_closure;
         const dowrite_closure;
         const childHandler1_closure;
         const hPutStr2_closure;
         const stdout_closure;
         const main1_closure;
         const main4_closure;
         const runMainIO1_closure;
         const main8_closure;
 }]

