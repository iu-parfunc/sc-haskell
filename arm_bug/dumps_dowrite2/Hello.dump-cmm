
==================== Cmm produced by new codegen ====================
2016-08-04 14:18:39.757557 UTC

[section "data" { __stginit_main@main:Main:
 }]


==================== Post CPS Cmm ====================
2016-08-04 14:18:39.758551 UTC

[section "data" { __stginit_main@main:Main:
 }]


==================== Output Cmm ====================
2016-08-04 14:18:39.759331 UTC

[section "data" { __stginit_main@main:Main:
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:18:39.761574 UTC

[section "data" {
     $fShowFoo2_closure:
         const $fShowFoo2_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     c3FN_str:
         I8[] [70,111,111,32]
 },
 $fShowFoo2_entry() //  [R1]
         { info_tbl: [(c3FO,
                       label: $fShowFoo2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c3FO:
           _rj::P64 = R1;
           goto c3FI;
       c3FI:
           if ((old + 0) - <highSp> < SpLim) goto c3FP; else goto c3FQ;
       c3FP:
           R1 = _rj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3FQ:
           (_c3FK::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rj::P64);
           if (_c3FK::I64 == 0) goto c3FM; else goto c3FL;
       c3FM:
           call (I64[I64[_rj::P64]])() args: 8, res: 0, upd: 8;
       c3FL:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _c3FK::I64;
           I64[(old + 32)] = c3FN_str;
           call unpackCString#_entry() args: 32, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:18:39.767038 UTC

{offset
  c3FO:
      _rj::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3FP; else goto c3FQ;
  c3FP:
      R1 = _rj::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3FQ:
      (_c3FK::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rj::P64);
      if (_c3FK::I64 == 0) goto c3FM; else goto c3FL;
  c3FM:
      call (I64[I64[_rj::P64]])() args: 8, res: 0, upd: 8;
  c3FL:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c3FK::I64;
      I64[(old + 32)] = c3FN_str;
      call unpackCString#_entry() args: 32, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2016-08-04 14:18:39.769907 UTC

{offset
  c3FO:
      _rj::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3FP; else goto c3FQ;
  c3FP:
      R1 = _rj::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3FQ:
      (_c3FK::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rj::P64);
      if (_c3FK::I64 == 0) goto c3FM; else goto c3FL;
  c3FM:
      call (I64[I64[_rj::P64]])() args: 8, res: 0, upd: 8;
  c3FL:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c3FK::I64;
      I64[(old + 32)] = c3FN_str;
      call unpackCString#_entry() args: 32, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-04 14:18:39.772512 UTC

$fShowFoo2_entry
[c3FO]
{offset
  c3FO:
      _rj::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3FP; else goto c3FQ;
  c3FP:
      R1 = _rj::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3FQ:
      (_c3FK::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rj::P64);
      if (_c3FK::I64 == 0) goto c3FM; else goto c3FL;
  c3FM:
      call (I64[I64[_rj::P64]])() args: 8, res: 0, upd: 8;
  c3FL:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _c3FK::I64;
      I64[(old + 32)] = c3FN_str;
      call unpackCString#_entry() args: 32, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-04 14:18:39.777694 UTC

{offset
  c3FO:
      _rj::P64 = R1;
      if ((Sp + 8) - 32 < SpLim) goto c3FP; else goto c3FQ;
  c3FP:
      R1 = _rj::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3FQ:
      (_c3FK::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rj::P64);
      if (_c3FK::I64 == 0) goto c3FM; else goto c3FL;
  c3FM:
      call (I64[I64[_rj::P64]])() args: 8, res: 0, upd: 8;
  c3FL:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _c3FK::I64;
      I64[Sp - 24] = c3FN_str;
      Sp = Sp - 24;
      call unpackCString#_entry() args: 32, res: 0, upd: 24;
}


==================== Sink assignments ====================
2016-08-04 14:18:39.780909 UTC

{offset
  c3FO:
      if ((Sp + -24) < SpLim) goto c3FP; else goto c3FQ;
  c3FP:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3FQ:
      (_c3FK::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
      if (_c3FK::I64 == 0) goto c3FM; else goto c3FL;
  c3FM:
      call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
  c3FL:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _c3FK::I64;
      I64[Sp - 24] = c3FN_str;
      Sp = Sp - 24;
      call unpackCString#_entry() args: 32, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-04 14:18:39.783358 UTC

[(c3FL, {}), (c3FM, {}), (c3FO, {}), (c3FP, {}), (c3FQ, {})]


==================== procpoint map ====================
2016-08-04 14:18:39.78437 UTC

[(c3FL, reached by c3FO), (c3FM, reached by c3FO),
 (c3FO, <procpt>), (c3FP, reached by c3FO), (c3FQ, reached by c3FO)]


==================== Post splitting ====================
2016-08-04 14:18:39.785464 UTC

$fShowFoo2_entry() //  [R1]
        { info_tbl: [(c3FO,
                      label: $fShowFoo2_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3FO:
          if ((Sp + -24) < SpLim) goto c3FP; else goto c3FQ;
      c3FP:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3FQ:
          (_c3FK::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
          if (_c3FK::I64 == 0) goto c3FM; else goto c3FL;
      c3FM:
          call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
      c3FL:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c3FK::I64;
          I64[Sp - 24] = c3FN_str;
          Sp = Sp - 24;
          call unpackCString#_entry() args: 32, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:39.788712 UTC

$fShowFoo2_entry() //  [R1]
        { info_tbl: [(c3FO,
                      label: $fShowFoo2_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3FO:
          if ((Sp + -24) < SpLim) goto c3FP; else goto c3FQ;
      c3FP:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3FQ:
          (_c3FK::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
          if (_c3FK::I64 == 0) goto c3FM; else goto c3FL;
      c3FM:
          call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
      c3FL:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c3FK::I64;
          I64[Sp - 24] = c3FN_str;
          Sp = Sp - 24;
          call unpackCString#_entry() args: 32, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:39.791703 UTC

$fShowFoo2_entry() //  [R1]
        { info_tbl: [(c3FO,
                      label: $fShowFoo2_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3FO:
          if ((Sp + -24) < SpLim) goto c3FP; else goto c3FQ;
      c3FP:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3FQ:
          (_c3FK::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
          if (_c3FK::I64 == 0) goto c3FM; else goto c3FL;
      c3FM:
          call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
      c3FL:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _c3FK::I64;
          I64[Sp - 24] = c3FN_str;
          Sp = Sp - 24;
          call unpackCString#_entry() args: 32, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:18:39.794763 UTC

[section "data" {
     $fShowFoo2_closure:
         const $fShowFoo2_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     c3FN_str:
         I8[] [70,111,111,32]
 },
 $fShowFoo2_entry() //  [R1]
         { info_tbl: [(c3FO,
                       label: $fShowFoo2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3FO:
           if ((Sp + -24) < SpLim) goto c3FP; else goto c3FQ;
       c3FP:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3FQ:
           (_c3FK::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c3FK::I64 == 0) goto c3FM; else goto c3FL;
       c3FM:
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c3FL:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c3FK::I64;
           I64[Sp - 24] = c3FN_str;
           Sp = Sp - 24;
           call unpackCString#_entry() args: 32, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:18:39.798593 UTC

[section "data" {
     $fShowFoo2_closure:
         const $fShowFoo2_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     c3FN_str:
         I8[] [70,111,111,32]
 },
 $fShowFoo2_entry() //  [R1]
         { info_tbl: [(c3FO,
                       label: $fShowFoo2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3FO:
           if ((Sp + -24) < SpLim) goto c3FP; else goto c3FQ;
       c3FP:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3FQ:
           (_c3FK::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c3FK::I64 == 0) goto c3FM; else goto c3FL;
       c3FM:
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c3FL:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c3FK::I64;
           I64[Sp - 24] = c3FN_str;
           Sp = Sp - 24;
           call unpackCString#_entry() args: 32, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:18:39.825231 UTC

[section "data" {
     $w$cshowsPrec_closure:
         const $w$cshowsPrec_info;
         const 0;
 },
 sat_s3E2_entry() //  [R1]
         { info_tbl: [(c3Hj,
                       label: sat_s3E2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c3Hj:
           _s3E2::P64 = R1;
           goto c3He;
       c3He:
           if ((old + 0) - <highSp> < SpLim) goto c3Hp; else goto c3Hq;
       c3Hp:
           R1 = _s3E2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3Hq:
           _s3DT::P64 = P64[_s3E2::P64 + 16];
           _s3DU::P64 = P64[_s3E2::P64 + 24];
           I64[(young<c3Hg> + 8)] = c3Hg;
           R1 = _s3DT::P64;
           if (R1 & 7 != 0) goto c3Hg; else goto c3Hh;
       c3Hh:
           call (I64[I64[R1]])(R1) returns to c3Hg, args: 8, res: 8, upd: 8;
       c3Hg:
           _s3DX::P64 = R1;
           _s3DY::I64 = I64[_s3DX::P64 + 7];
           I64[(young<c3Hm> + 8)] = c3Hm;
           I64[(young<c3Hm> + 32)] = 11;
           I64[(young<c3Hm> + 24)] = _s3DY::I64;
           P64[(young<c3Hm> + 16)] = _s3DU::P64;
           call $wshowSignedInt_entry() returns to c3Hm, args: 32, res: 16, upd: 8;
       c3Hm:
           _s3E0::P64 = R1;
           _s3E1::P64 = P64[(young<c3Hm> + 16)];
           Hp = Hp + 24;
           if (Hp > HpLim) goto c3Hu; else goto c3Ht;
       c3Hu:
           HpAlloc = 24;
           goto c3Hs;
       c3Hs:
           R1 = _s3E0::P64;
           P64[(young<c3Hm> + 16)] = _s3E1::P64;
           call stg_gc_pp(R1) returns to c3Hm, args: 16, res: 16, upd: 8;
       c3Ht:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _s3E0::P64;
           P64[Hp] = _s3E1::P64;
           _c3Ho::P64 = Hp - 14;
           R1 = _c3Ho::P64;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s3E9_entry() //  [R1]
         { info_tbl: [(c3HH,
                       label: sat_s3E9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c3HH:
           _s3E9::P64 = R1;
           goto c3HC;
       c3HC:
           if ((old + 0) - <highSp> < SpLim) goto c3HO; else goto c3HP;
       c3HO:
           R1 = _s3E9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3HP:
           _s3DT::P64 = P64[_s3E9::P64 + 16];
           _s3DU::P64 = P64[_s3E9::P64 + 24];
           I64[(young<c3HE> + 8)] = c3HE;
           R1 = _s3DT::P64;
           if (R1 & 7 != 0) goto c3HE; else goto c3HF;
       c3HF:
           call (I64[I64[R1]])(R1) returns to c3HE, args: 8, res: 8, upd: 8;
       c3HE:
           _s3E3::P64 = R1;
           Hp = Hp + 24;
           if (Hp > HpLim) goto c3HS; else goto c3HR;
       c3HS:
           HpAlloc = 24;
           goto c3HQ;
       c3HQ:
           R1 = _s3E3::P64;
           call stg_gc_unpt_r1(R1) returns to c3HE, args: 8, res: 8, upd: 8;
       c3HR:
           _s3E4::I64 = I64[_s3E3::P64 + 7];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = shows8_closure;
           P64[Hp] = _s3DU::P64;
           _c3HK::P64 = Hp - 14;
           I64[(young<c3HL> + 8)] = c3HL;
           I64[(young<c3HL> + 32)] = 11;
           I64[(young<c3HL> + 24)] = _s3E4::I64;
           P64[(young<c3HL> + 16)] = _c3HK::P64;
           call $wshowSignedInt_entry() returns to c3HL, args: 32, res: 16, upd: 8;
       c3HL:
           _s3E7::P64 = R1;
           _s3E8::P64 = P64[(young<c3HL> + 16)];
           Hp = Hp + 24;
           if (Hp > HpLim) goto c3HV; else goto c3HU;
       c3HV:
           HpAlloc = 24;
           goto c3HT;
       c3HT:
           R1 = _s3E7::P64;
           P64[(young<c3HL> + 16)] = _s3E8::P64;
           call stg_gc_pp(R1) returns to c3HL, args: 16, res: 16, upd: 8;
       c3HU:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _s3E7::P64;
           P64[Hp] = _s3E8::P64;
           _c3HN::P64 = Hp - 14;
           R1 = _c3HN::P64;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s3Ea_entry() //  [R1]
         { info_tbl: [(c3HW,
                       label: sat_s3Ea_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c3HW:
           _s3Ea::P64 = R1;
           goto c3Hy;
       c3Hy:
           if ((old + 0) - <highSp> < SpLim) goto c3HX; else goto c3HY;
       c3HY:
           Hp = Hp + 32;
           if (Hp > HpLim) goto c3I0; else goto c3HZ;
       c3I0:
           HpAlloc = 32;
           goto c3HX;
       c3HX:
           R1 = _s3Ea::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3HZ:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _s3Ea::P64;
           _s3DT::P64 = P64[_s3Ea::P64 + 16];
           _s3DU::P64 = P64[_s3Ea::P64 + 24];
           I64[Hp - 24] = sat_s3E9_info;
           P64[Hp - 8] = _s3DT::P64;
           P64[Hp] = _s3DU::P64;
           _c3HA::P64 = Hp - 24;
           P64[(old + 40)] = $fShowFoo2_closure;
           P64[(old + 32)] = _c3HA::P64;
           call ++_entry() args: 40, res: 0, upd: 24;
     }
 },
 $w$cshowsPrec_entry() //  []
         { info_tbl: [(c3I1,
                       label: $w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 32 updfr_space: Just 8
         }
     {offset
       c3I1:
           _s3DS::I64 = I64[(old + 32)];
           _s3DT::P64 = P64[(old + 24)];
           _s3DU::P64 = P64[(old + 16)];
           goto c3H5;
       c3H5:
           if ((old + 0) - <highSp> < SpLim) goto c3I2; else goto c3I3;
       c3I3:
           goto c3H4;
       c3H4:
           Hp = Hp + 56;
           if (Hp > HpLim) goto c3I5; else goto c3I4;
       c3I5:
           HpAlloc = 56;
           goto c3I2;
       c3I2:
           R1 = $w$cshowsPrec_closure;
           I64[(old + 32)] = _s3DS::I64;
           P64[(old + 24)] = _s3DT::P64;
           P64[(old + 16)] = _s3DU::P64;
           call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
       c3I4:
           _c3H7::I64 = %MO_S_Ge_W64(_s3DS::I64, 11);
           _s3DV::I64 = _c3H7::I64;
           if (_s3DV::I64 >= 1) goto c3Ib; else goto c3Ic;
       c3Ib:
           goto c3I9;
       c3I9:
           I64[Hp - 48] = sat_s3Ea_info;
           P64[Hp - 32] = _s3DT::P64;
           P64[Hp - 24] = _s3DU::P64;
           _c3Hw::P64 = Hp - 48;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = shows9_closure;
           P64[Hp] = _c3Hw::P64;
           _c3I8::P64 = Hp - 14;
           R1 = _c3I8::P64;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
       c3Ic:
           goto c3I7;
       c3I7:
           I64[Hp - 48] = sat_s3E2_info;
           P64[Hp - 32] = _s3DT::P64;
           P64[Hp - 24] = _s3DU::P64;
           _c3Hc::P64 = Hp - 48;
           Hp = Hp - 24;
           P64[(old + 24)] = $fShowFoo2_closure;
           P64[(old + 16)] = _c3Hc::P64;
           call ++_entry() args: 24, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:18:39.85307 UTC

{offset
  c3Hj:
      _s3E2::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3Hp; else goto c3Hq;
  c3Hp:
      R1 = _s3E2::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3Hq:
      _s3DT::P64 = P64[_s3E2::P64 + 16];
      _s3DU::P64 = P64[_s3E2::P64 + 24];
      I64[(young<c3Hg> + 8)] = c3Hg;
      R1 = _s3DT::P64;
      if (R1 & 7 != 0) goto c3Hg; else goto c3Hh;
  c3Hh:
      call (I64[I64[R1]])(R1) returns to c3Hg, args: 8, res: 8, upd: 8;
  c3Hg:
      _s3DX::P64 = R1;
      _s3DY::I64 = I64[_s3DX::P64 + 7];
      I64[(young<c3Hm> + 8)] = c3Hm;
      I64[(young<c3Hm> + 32)] = 11;
      I64[(young<c3Hm> + 24)] = _s3DY::I64;
      P64[(young<c3Hm> + 16)] = _s3DU::P64;
      call $wshowSignedInt_entry() returns to c3Hm, args: 32, res: 16, upd: 8;
  c3Hm:
      _s3E0::P64 = R1;
      _s3E1::P64 = P64[(young<c3Hm> + 16)];
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3Hu; else goto c3Ht;
  c3Hu:
      HpAlloc = 24;
      R1 = _s3E0::P64;
      P64[(young<c3Hm> + 16)] = _s3E1::P64;
      call stg_gc_pp(R1) returns to c3Hm, args: 16, res: 16, upd: 8;
  c3Ht:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _s3E0::P64;
      P64[Hp] = _s3E1::P64;
      _c3Ho::P64 = Hp - 14;
      R1 = _c3Ho::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:18:39.858662 UTC

{offset
  c3Hj:
      _s3E2::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3Hp; else goto c3Hq;
  c3Hp:
      R1 = _s3E2::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3Hq:
      _s3DT::P64 = P64[_s3E2::P64 + 16];
      _s3DU::P64 = P64[_s3E2::P64 + 24];
      I64[(young<c3Hg> + 8)] = c3Hg;
      R1 = _s3DT::P64;
      if (R1 & 7 != 0) goto c3Hg; else goto c3Hh;
  c3Hh:
      call (I64[I64[R1]])(R1) returns to c3Hg, args: 8, res: 8, upd: 8;
  c3Hg:
      _s3DX::P64 = R1;
      _s3DY::I64 = I64[_s3DX::P64 + 7];
      I64[(young<c3Hm> + 8)] = c3Hm;
      I64[(young<c3Hm> + 32)] = 11;
      I64[(young<c3Hm> + 24)] = _s3DY::I64;
      P64[(young<c3Hm> + 16)] = _s3DU::P64;
      call $wshowSignedInt_entry() returns to c3Hm, args: 32, res: 16, upd: 8;
  c3Hm:
      _s3E0::P64 = R1;
      _s3E1::P64 = P64[(young<c3Hm> + 16)];
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3Hu; else goto c3Ht;
  c3Hu:
      HpAlloc = 24;
      R1 = _s3E0::P64;
      P64[(young<c3Hm> + 16)] = _s3E1::P64;
      call stg_gc_pp(R1) returns to c3Hm, args: 16, res: 16, upd: 8;
  c3Ht:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _s3E0::P64;
      P64[Hp] = _s3E1::P64;
      _c3Ho::P64 = Hp - 14;
      R1 = _c3Ho::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:18:39.863776 UTC

sat_s3E2_entry
[c3Hg, c3Hj, c3Hm]
{offset
  c3Hj:
      _s3E2::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3Hp; else goto c3Hq;
  c3Hp:
      R1 = _s3E2::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3Hq:
      _s3DT::P64 = P64[_s3E2::P64 + 16];
      _s3DU::P64 = P64[_s3E2::P64 + 24];
      I64[(young<c3Hg> + 8)] = c3Hg;
      R1 = _s3DT::P64;
      if (R1 & 7 != 0) goto c3Hg; else goto c3Hh;
  c3Hh:
      call (I64[I64[R1]])(R1) returns to c3Hg, args: 8, res: 8, upd: 8;
  c3Hg:
      _s3DX::P64 = R1;
      _s3DY::I64 = I64[_s3DX::P64 + 7];
      I64[(young<c3Hm> + 8)] = c3Hm;
      I64[(young<c3Hm> + 32)] = 11;
      I64[(young<c3Hm> + 24)] = _s3DY::I64;
      P64[(young<c3Hm> + 16)] = _s3DU::P64;
      call $wshowSignedInt_entry() returns to c3Hm, args: 32, res: 16, upd: 8;
  c3Hm:
      _s3E0::P64 = R1;
      _s3E1::P64 = P64[(young<c3Hm> + 16)];
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3Hu; else goto c3Ht;
  c3Hu:
      HpAlloc = 24;
      R1 = _s3E0::P64;
      P64[(young<c3Hm> + 16)] = _s3E1::P64;
      call stg_gc_pp(R1) returns to c3Hm, args: 16, res: 16, upd: 8;
  c3Ht:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _s3E0::P64;
      P64[Hp] = _s3E1::P64;
      _c3Ho::P64 = Hp - 14;
      R1 = _c3Ho::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:18:39.870124 UTC

{offset
  c3Hj:
      _s3E2::P64 = R1;
      if ((Sp + 8) - 40 < SpLim) goto c3Hp; else goto c3Hq;
  c3Hp:
      R1 = _s3E2::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3Hq:
      _s3DT::P64 = P64[_s3E2::P64 + 16];
      _s3DU::P64 = P64[_s3E2::P64 + 24];
      I64[Sp - 16] = c3Hg;
      R1 = _s3DT::P64;
      P64[Sp - 8] = _s3DU::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto c3Hg; else goto c3Hh;
  c3Hh:
      call (I64[I64[R1]])(R1) returns to c3Hg, args: 8, res: 8, upd: 8;
  c3Hg:
      _s3DU::P64 = P64[Sp + 8];
      _s3DX::P64 = R1;
      _s3DY::I64 = I64[_s3DX::P64 + 7];
      I64[Sp + 8] = c3Hm;
      I64[Sp - 16] = 11;
      I64[Sp - 8] = _s3DY::I64;
      P64[Sp] = _s3DU::P64;
      Sp = Sp - 16;
      call $wshowSignedInt_entry() returns to c3Hm, args: 32, res: 16, upd: 8;
  c3Hm:
      _s3E0::P64 = R1;
      _s3E1::P64 = P64[Sp];
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3Hu; else goto c3Ht;
  c3Hu:
      HpAlloc = 24;
      R1 = _s3E0::P64;
      call stg_gc_pp(R1) returns to c3Hm, args: 16, res: 16, upd: 8;
  c3Ht:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _s3E0::P64;
      P64[Hp] = _s3E1::P64;
      _c3Ho::P64 = Hp - 14;
      R1 = _c3Ho::P64;
      Sp = Sp + 16;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:18:39.87649 UTC

{offset
  c3Hj:
      if ((Sp + -32) < SpLim) goto c3Hp; else goto c3Hq;
  c3Hp:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3Hq:
      I64[Sp - 16] = c3Hg;
      _s3DU::P64 = P64[R1 + 24];
      R1 = P64[R1 + 16];
      P64[Sp - 8] = _s3DU::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto c3Hg; else goto c3Hh;
  c3Hh:
      call (I64[I64[R1]])(R1) returns to c3Hg, args: 8, res: 8, upd: 8;
  c3Hg:
      _s3DU::P64 = P64[Sp + 8];
      I64[Sp + 8] = c3Hm;
      I64[Sp - 16] = 11;
      I64[Sp - 8] = I64[R1 + 7];
      P64[Sp] = _s3DU::P64;
      Sp = Sp - 16;
      call $wshowSignedInt_entry() returns to c3Hm, args: 32, res: 16, upd: 8;
  c3Hm:
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3Hu; else goto c3Ht;
  c3Hu:
      HpAlloc = 24;
      R1 = R1;
      call stg_gc_pp(R1) returns to c3Hm, args: 16, res: 16, upd: 8;
  c3Ht:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = R1;
      P64[Hp] = P64[Sp];
      R1 = Hp - 14;
      Sp = Sp + 16;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:18:39.880862 UTC

[(c3Hg, {}), (c3Hh, {}), (c3Hj, {}), (c3Hm, {}), (c3Hp, {}),
 (c3Hq, {}), (c3Ht, {}), (c3Hu, {})]


==================== procpoint map ====================
2016-08-04 14:18:39.88316 UTC

[(c3Hg, <procpt>), (c3Hh, reached by c3Hj), (c3Hj, <procpt>),
 (c3Hm, <procpt>), (c3Hp, reached by c3Hj), (c3Hq, reached by c3Hj),
 (c3Ht, reached by c3Hm), (c3Hu, reached by c3Hm)]


==================== Post splitting ====================
2016-08-04 14:18:39.88453 UTC

sat_s3E2_entry() //  [R1]
        { info_tbl: [(c3Hj,
                      label: sat_s3E2_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Hj:
          if ((Sp + -32) < SpLim) goto c3Hp; else goto c3Hq;
      c3Hp:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3Hq:
          I64[Sp - 16] = block_c3Hg_info;
          _s3DU::P64 = P64[R1 + 24];
          R1 = P64[R1 + 16];
          P64[Sp - 8] = _s3DU::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto u3Id; else goto c3Hh;
      u3Id:
          call block_c3Hg_entry(R1) args: 0, res: 0, upd: 0;
      c3Hh:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-04 14:18:39.887885 UTC

block_c3Hg_entry() //  [R1]
        { info_tbl: [(c3Hg,
                      label: block_c3Hg_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Hg:
          _s3DU::P64 = P64[Sp + 8];
          I64[Sp + 8] = block_c3Hm_info;
          I64[Sp - 16] = 11;
          I64[Sp - 8] = I64[R1 + 7];
          P64[Sp] = _s3DU::P64;
          Sp = Sp - 16;
          call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-04 14:18:39.889929 UTC

block_c3Hm_entry() //  [R1]
        { info_tbl: [(c3Hm,
                      label: block_c3Hm_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Hm:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c3Hu; else goto c3Ht;
      c3Hu:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
      c3Ht:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = P64[Sp];
          R1 = Hp - 14;
          Sp = Sp + 16;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:39.892362 UTC

sat_s3E2_entry() //  [R1]
        { info_tbl: [(c3Hj,
                      label: sat_s3E2_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Hj:
          if ((Sp + -32) < SpLim) goto c3Hp; else goto c3Hq;
      c3Hp:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3Hq:
          I64[Sp - 16] = block_c3Hg_info;
          _s3DU::P64 = P64[R1 + 24];
          R1 = P64[R1 + 16];
          P64[Sp - 8] = _s3DU::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto u3Id; else goto c3Hh;
      u3Id:
          call block_c3Hg_entry(R1) args: 0, res: 0, upd: 0;
      c3Hh:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:39.895266 UTC

block_c3Hg_entry() //  [R1]
        { info_tbl: [(c3Hg,
                      label: block_c3Hg_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Hg:
          _s3DU::P64 = P64[Sp + 8];
          I64[Sp + 8] = block_c3Hm_info;
          I64[Sp - 16] = 11;
          I64[Sp - 8] = I64[R1 + 7];
          P64[Sp] = _s3DU::P64;
          Sp = Sp - 16;
          call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:39.897412 UTC

block_c3Hm_entry() //  [R1]
        { info_tbl: [(c3Hm,
                      label: block_c3Hm_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Hm:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c3Hu; else goto c3Ht;
      c3Hu:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
      c3Ht:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = P64[Sp];
          R1 = Hp - 14;
          Sp = Sp + 16;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:39.899801 UTC

sat_s3E2_entry() //  [R1]
        { info_tbl: [(c3Hj,
                      label: sat_s3E2_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Hj:
          if ((Sp + -32) < SpLim) goto c3Hp; else goto c3Hq;
      c3Hp:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3Hq:
          I64[Sp - 16] = block_c3Hg_info;
          _s3DU::P64 = P64[R1 + 24];
          R1 = P64[R1 + 16];
          P64[Sp - 8] = _s3DU::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto u3Id; else goto c3Hh;
      u3Id:
          call block_c3Hg_entry(R1) args: 0, res: 0, upd: 0;
      c3Hh:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:39.902798 UTC

block_c3Hg_entry() //  [R1]
        { info_tbl: [(c3Hg,
                      label: block_c3Hg_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Hg:
          _s3DU::P64 = P64[Sp + 8];
          I64[Sp + 8] = block_c3Hm_info;
          I64[Sp - 16] = 11;
          I64[Sp - 8] = I64[R1 + 7];
          P64[Sp] = _s3DU::P64;
          Sp = Sp - 16;
          call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:39.904853 UTC

block_c3Hm_entry() //  [R1]
        { info_tbl: [(c3Hm,
                      label: block_c3Hm_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Hm:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c3Hu; else goto c3Ht;
      c3Hu:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
      c3Ht:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = P64[Sp];
          R1 = Hp - 14;
          Sp = Sp + 16;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:39.907829 UTC

{offset
  c3HH:
      _s3E9::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3HO; else goto c3HP;
  c3HO:
      R1 = _s3E9::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3HP:
      _s3DT::P64 = P64[_s3E9::P64 + 16];
      _s3DU::P64 = P64[_s3E9::P64 + 24];
      I64[(young<c3HE> + 8)] = c3HE;
      R1 = _s3DT::P64;
      if (R1 & 7 != 0) goto c3HE; else goto c3HF;
  c3HF:
      call (I64[I64[R1]])(R1) returns to c3HE, args: 8, res: 8, upd: 8;
  c3HE:
      _s3E3::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3HS; else goto c3HR;
  c3HS:
      HpAlloc = 24;
      R1 = _s3E3::P64;
      call stg_gc_unpt_r1(R1) returns to c3HE, args: 8, res: 8, upd: 8;
  c3HR:
      _s3E4::I64 = I64[_s3E3::P64 + 7];
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows8_closure;
      P64[Hp] = _s3DU::P64;
      _c3HK::P64 = Hp - 14;
      I64[(young<c3HL> + 8)] = c3HL;
      I64[(young<c3HL> + 32)] = 11;
      I64[(young<c3HL> + 24)] = _s3E4::I64;
      P64[(young<c3HL> + 16)] = _c3HK::P64;
      call $wshowSignedInt_entry() returns to c3HL, args: 32, res: 16, upd: 8;
  c3HL:
      _s3E7::P64 = R1;
      _s3E8::P64 = P64[(young<c3HL> + 16)];
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3HV; else goto c3HU;
  c3HV:
      HpAlloc = 24;
      R1 = _s3E7::P64;
      P64[(young<c3HL> + 16)] = _s3E8::P64;
      call stg_gc_pp(R1) returns to c3HL, args: 16, res: 16, upd: 8;
  c3HU:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _s3E7::P64;
      P64[Hp] = _s3E8::P64;
      _c3HN::P64 = Hp - 14;
      R1 = _c3HN::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:18:39.914537 UTC

{offset
  c3HH:
      _s3E9::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3HO; else goto c3HP;
  c3HO:
      R1 = _s3E9::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3HP:
      _s3DT::P64 = P64[_s3E9::P64 + 16];
      _s3DU::P64 = P64[_s3E9::P64 + 24];
      I64[(young<c3HE> + 8)] = c3HE;
      R1 = _s3DT::P64;
      if (R1 & 7 != 0) goto c3HE; else goto c3HF;
  c3HF:
      call (I64[I64[R1]])(R1) returns to c3HE, args: 8, res: 8, upd: 8;
  c3HE:
      _s3E3::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3HS; else goto c3HR;
  c3HS:
      HpAlloc = 24;
      R1 = _s3E3::P64;
      call stg_gc_unpt_r1(R1) returns to c3HE, args: 8, res: 8, upd: 8;
  c3HR:
      _s3E4::I64 = I64[_s3E3::P64 + 7];
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows8_closure;
      P64[Hp] = _s3DU::P64;
      _c3HK::P64 = Hp - 14;
      I64[(young<c3HL> + 8)] = c3HL;
      I64[(young<c3HL> + 32)] = 11;
      I64[(young<c3HL> + 24)] = _s3E4::I64;
      P64[(young<c3HL> + 16)] = _c3HK::P64;
      call $wshowSignedInt_entry() returns to c3HL, args: 32, res: 16, upd: 8;
  c3HL:
      _s3E7::P64 = R1;
      _s3E8::P64 = P64[(young<c3HL> + 16)];
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3HV; else goto c3HU;
  c3HV:
      HpAlloc = 24;
      R1 = _s3E7::P64;
      P64[(young<c3HL> + 16)] = _s3E8::P64;
      call stg_gc_pp(R1) returns to c3HL, args: 16, res: 16, upd: 8;
  c3HU:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _s3E7::P64;
      P64[Hp] = _s3E8::P64;
      _c3HN::P64 = Hp - 14;
      R1 = _c3HN::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:18:39.920672 UTC

sat_s3E9_entry
[c3HE, c3HH, c3HL]
{offset
  c3HH:
      _s3E9::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3HO; else goto c3HP;
  c3HO:
      R1 = _s3E9::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3HP:
      _s3DT::P64 = P64[_s3E9::P64 + 16];
      _s3DU::P64 = P64[_s3E9::P64 + 24];
      I64[(young<c3HE> + 8)] = c3HE;
      R1 = _s3DT::P64;
      if (R1 & 7 != 0) goto c3HE; else goto c3HF;
  c3HF:
      call (I64[I64[R1]])(R1) returns to c3HE, args: 8, res: 8, upd: 8;
  c3HE:
      _s3E3::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3HS; else goto c3HR;
  c3HS:
      HpAlloc = 24;
      R1 = _s3E3::P64;
      call stg_gc_unpt_r1(R1) returns to c3HE, args: 8, res: 8, upd: 8;
  c3HR:
      _s3E4::I64 = I64[_s3E3::P64 + 7];
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows8_closure;
      P64[Hp] = _s3DU::P64;
      _c3HK::P64 = Hp - 14;
      I64[(young<c3HL> + 8)] = c3HL;
      I64[(young<c3HL> + 32)] = 11;
      I64[(young<c3HL> + 24)] = _s3E4::I64;
      P64[(young<c3HL> + 16)] = _c3HK::P64;
      call $wshowSignedInt_entry() returns to c3HL, args: 32, res: 16, upd: 8;
  c3HL:
      _s3E7::P64 = R1;
      _s3E8::P64 = P64[(young<c3HL> + 16)];
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3HV; else goto c3HU;
  c3HV:
      HpAlloc = 24;
      R1 = _s3E7::P64;
      P64[(young<c3HL> + 16)] = _s3E8::P64;
      call stg_gc_pp(R1) returns to c3HL, args: 16, res: 16, upd: 8;
  c3HU:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _s3E7::P64;
      P64[Hp] = _s3E8::P64;
      _c3HN::P64 = Hp - 14;
      R1 = _c3HN::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:18:39.928291 UTC

{offset
  c3HH:
      _s3E9::P64 = R1;
      if ((Sp + 8) - 40 < SpLim) goto c3HO; else goto c3HP;
  c3HO:
      R1 = _s3E9::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3HP:
      _s3DT::P64 = P64[_s3E9::P64 + 16];
      _s3DU::P64 = P64[_s3E9::P64 + 24];
      I64[Sp - 16] = c3HE;
      R1 = _s3DT::P64;
      P64[Sp - 8] = _s3DU::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto c3HE; else goto c3HF;
  c3HF:
      call (I64[I64[R1]])(R1) returns to c3HE, args: 8, res: 8, upd: 8;
  c3HE:
      _s3DU::P64 = P64[Sp + 8];
      _s3E3::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3HS; else goto c3HR;
  c3HS:
      HpAlloc = 24;
      R1 = _s3E3::P64;
      call stg_gc_unpt_r1(R1) returns to c3HE, args: 8, res: 8, upd: 8;
  c3HR:
      _s3E4::I64 = I64[_s3E3::P64 + 7];
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows8_closure;
      P64[Hp] = _s3DU::P64;
      _c3HK::P64 = Hp - 14;
      I64[Sp + 8] = c3HL;
      I64[Sp - 16] = 11;
      I64[Sp - 8] = _s3E4::I64;
      P64[Sp] = _c3HK::P64;
      Sp = Sp - 16;
      call $wshowSignedInt_entry() returns to c3HL, args: 32, res: 16, upd: 8;
  c3HL:
      _s3E7::P64 = R1;
      _s3E8::P64 = P64[Sp];
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3HV; else goto c3HU;
  c3HV:
      HpAlloc = 24;
      R1 = _s3E7::P64;
      call stg_gc_pp(R1) returns to c3HL, args: 16, res: 16, upd: 8;
  c3HU:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _s3E7::P64;
      P64[Hp] = _s3E8::P64;
      _c3HN::P64 = Hp - 14;
      R1 = _c3HN::P64;
      Sp = Sp + 16;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:18:39.935856 UTC

{offset
  c3HH:
      if ((Sp + -32) < SpLim) goto c3HO; else goto c3HP;
  c3HO:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3HP:
      I64[Sp - 16] = c3HE;
      _s3DU::P64 = P64[R1 + 24];
      R1 = P64[R1 + 16];
      P64[Sp - 8] = _s3DU::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto c3HE; else goto c3HF;
  c3HF:
      call (I64[I64[R1]])(R1) returns to c3HE, args: 8, res: 8, upd: 8;
  c3HE:
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3HS; else goto c3HR;
  c3HS:
      HpAlloc = 24;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to c3HE, args: 8, res: 8, upd: 8;
  c3HR:
      _s3E4::I64 = I64[R1 + 7];
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows8_closure;
      P64[Hp] = P64[Sp + 8];
      I64[Sp + 8] = c3HL;
      I64[Sp - 16] = 11;
      I64[Sp - 8] = _s3E4::I64;
      P64[Sp] = Hp - 14;
      Sp = Sp - 16;
      call $wshowSignedInt_entry() returns to c3HL, args: 32, res: 16, upd: 8;
  c3HL:
      Hp = Hp + 24;
      if (Hp > HpLim) goto c3HV; else goto c3HU;
  c3HV:
      HpAlloc = 24;
      R1 = R1;
      call stg_gc_pp(R1) returns to c3HL, args: 16, res: 16, upd: 8;
  c3HU:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = R1;
      P64[Hp] = P64[Sp];
      R1 = Hp - 14;
      Sp = Sp + 16;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:18:39.942019 UTC

[(c3HE, {}), (c3HF, {}), (c3HH, {}), (c3HL, {}), (c3HO, {}),
 (c3HP, {}), (c3HR, {}), (c3HS, {}), (c3HU, {}), (c3HV, {})]


==================== procpoint map ====================
2016-08-04 14:18:39.943376 UTC

[(c3HE, <procpt>), (c3HF, reached by c3HH), (c3HH, <procpt>),
 (c3HL, <procpt>), (c3HO, reached by c3HH), (c3HP, reached by c3HH),
 (c3HR, reached by c3HE), (c3HS, reached by c3HE),
 (c3HU, reached by c3HL), (c3HV, reached by c3HL)]


==================== Post splitting ====================
2016-08-04 14:18:39.944875 UTC

sat_s3E9_entry() //  [R1]
        { info_tbl: [(c3HH,
                      label: sat_s3E9_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3HH:
          if ((Sp + -32) < SpLim) goto c3HO; else goto c3HP;
      c3HO:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3HP:
          I64[Sp - 16] = block_c3HE_info;
          _s3DU::P64 = P64[R1 + 24];
          R1 = P64[R1 + 16];
          P64[Sp - 8] = _s3DU::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto u3Ie; else goto c3HF;
      u3Ie:
          call block_c3HE_entry(R1) args: 0, res: 0, upd: 0;
      c3HF:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-04 14:18:39.948262 UTC

block_c3HE_entry() //  [R1]
        { info_tbl: [(c3HE,
                      label: block_c3HE_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3HE:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c3HS; else goto c3HR;
      c3HS:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c3HR:
          _s3E4::I64 = I64[R1 + 7];
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = shows8_closure;
          P64[Hp] = P64[Sp + 8];
          I64[Sp + 8] = block_c3HL_info;
          I64[Sp - 16] = 11;
          I64[Sp - 8] = _s3E4::I64;
          P64[Sp] = Hp - 14;
          Sp = Sp - 16;
          call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-04 14:18:39.95127 UTC

block_c3HL_entry() //  [R1]
        { info_tbl: [(c3HL,
                      label: block_c3HL_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3HL:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c3HV; else goto c3HU;
      c3HV:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
      c3HU:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = P64[Sp];
          R1 = Hp - 14;
          Sp = Sp + 16;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:39.953682 UTC

sat_s3E9_entry() //  [R1]
        { info_tbl: [(c3HH,
                      label: sat_s3E9_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3HH:
          if ((Sp + -32) < SpLim) goto c3HO; else goto c3HP;
      c3HO:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3HP:
          I64[Sp - 16] = block_c3HE_info;
          _s3DU::P64 = P64[R1 + 24];
          R1 = P64[R1 + 16];
          P64[Sp - 8] = _s3DU::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto u3Ie; else goto c3HF;
      u3Ie:
          call block_c3HE_entry(R1) args: 0, res: 0, upd: 0;
      c3HF:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:39.956684 UTC

block_c3HE_entry() //  [R1]
        { info_tbl: [(c3HE,
                      label: block_c3HE_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3HE:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c3HS; else goto c3HR;
      c3HS:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c3HR:
          _s3E4::I64 = I64[R1 + 7];
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = shows8_closure;
          P64[Hp] = P64[Sp + 8];
          I64[Sp + 8] = block_c3HL_info;
          I64[Sp - 16] = 11;
          I64[Sp - 8] = _s3E4::I64;
          P64[Sp] = Hp - 14;
          Sp = Sp - 16;
          call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:39.959655 UTC

block_c3HL_entry() //  [R1]
        { info_tbl: [(c3HL,
                      label: block_c3HL_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3HL:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c3HV; else goto c3HU;
      c3HV:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
      c3HU:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = P64[Sp];
          R1 = Hp - 14;
          Sp = Sp + 16;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:39.962073 UTC

sat_s3E9_entry() //  [R1]
        { info_tbl: [(c3HH,
                      label: sat_s3E9_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3HH:
          if ((Sp + -32) < SpLim) goto c3HO; else goto c3HP;
      c3HO:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3HP:
          I64[Sp - 16] = block_c3HE_info;
          _s3DU::P64 = P64[R1 + 24];
          R1 = P64[R1 + 16];
          P64[Sp - 8] = _s3DU::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto u3Ie; else goto c3HF;
      u3Ie:
          call block_c3HE_entry(R1) args: 0, res: 0, upd: 0;
      c3HF:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:39.965039 UTC

block_c3HE_entry() //  [R1]
        { info_tbl: [(c3HE,
                      label: block_c3HE_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3HE:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c3HS; else goto c3HR;
      c3HS:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c3HR:
          _s3E4::I64 = I64[R1 + 7];
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = shows8_closure;
          P64[Hp] = P64[Sp + 8];
          I64[Sp + 8] = block_c3HL_info;
          I64[Sp - 16] = 11;
          I64[Sp - 8] = _s3E4::I64;
          P64[Sp] = Hp - 14;
          Sp = Sp - 16;
          call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:39.96807 UTC

block_c3HL_entry() //  [R1]
        { info_tbl: [(c3HL,
                      label: block_c3HL_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3HL:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c3HV; else goto c3HU;
      c3HV:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
      c3HU:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = P64[Sp];
          R1 = Hp - 14;
          Sp = Sp + 16;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:39.970823 UTC

{offset
  c3HW:
      _s3Ea::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3HX; else goto c3HY;
  c3HY:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c3I0; else goto c3HZ;
  c3I0:
      HpAlloc = 32;
      goto c3HX;
  c3HX:
      R1 = _s3Ea::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3HZ:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s3Ea::P64;
      _s3DT::P64 = P64[_s3Ea::P64 + 16];
      _s3DU::P64 = P64[_s3Ea::P64 + 24];
      I64[Hp - 24] = sat_s3E9_info;
      P64[Hp - 8] = _s3DT::P64;
      P64[Hp] = _s3DU::P64;
      _c3HA::P64 = Hp - 24;
      P64[(old + 40)] = $fShowFoo2_closure;
      P64[(old + 32)] = _c3HA::P64;
      call ++_entry() args: 40, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2016-08-04 14:18:39.974222 UTC

{offset
  c3HW:
      _s3Ea::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3HX; else goto c3HY;
  c3HY:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c3I0; else goto c3HZ;
  c3I0:
      HpAlloc = 32;
      goto c3HX;
  c3HX:
      R1 = _s3Ea::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3HZ:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s3Ea::P64;
      _s3DT::P64 = P64[_s3Ea::P64 + 16];
      _s3DU::P64 = P64[_s3Ea::P64 + 24];
      I64[Hp - 24] = sat_s3E9_info;
      P64[Hp - 8] = _s3DT::P64;
      P64[Hp] = _s3DU::P64;
      _c3HA::P64 = Hp - 24;
      P64[(old + 40)] = $fShowFoo2_closure;
      P64[(old + 32)] = _c3HA::P64;
      call ++_entry() args: 40, res: 0, upd: 24;
}


==================== Proc points ====================
2016-08-04 14:18:39.97734 UTC

sat_s3Ea_entry
[c3HW]
{offset
  c3HW:
      _s3Ea::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c3HX; else goto c3HY;
  c3HY:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c3I0; else goto c3HZ;
  c3I0:
      HpAlloc = 32;
      goto c3HX;
  c3HX:
      R1 = _s3Ea::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3HZ:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _s3Ea::P64;
      _s3DT::P64 = P64[_s3Ea::P64 + 16];
      _s3DU::P64 = P64[_s3Ea::P64 + 24];
      I64[Hp - 24] = sat_s3E9_info;
      P64[Hp - 8] = _s3DT::P64;
      P64[Hp] = _s3DU::P64;
      _c3HA::P64 = Hp - 24;
      P64[(old + 40)] = $fShowFoo2_closure;
      P64[(old + 32)] = _c3HA::P64;
      call ++_entry() args: 40, res: 0, upd: 24;
}


==================== Layout Stack ====================
2016-08-04 14:18:39.981073 UTC

{offset
  c3HW:
      _s3Ea::P64 = R1;
      if ((Sp + 8) - 40 < SpLim) goto c3HX; else goto c3HY;
  c3HY:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c3I0; else goto c3HZ;
  c3I0:
      HpAlloc = 32;
      goto c3HX;
  c3HX:
      R1 = _s3Ea::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3HZ:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _s3Ea::P64;
      _s3DT::P64 = P64[_s3Ea::P64 + 16];
      _s3DU::P64 = P64[_s3Ea::P64 + 24];
      I64[Hp - 24] = sat_s3E9_info;
      P64[Hp - 8] = _s3DT::P64;
      P64[Hp] = _s3DU::P64;
      _c3HA::P64 = Hp - 24;
      P64[Sp - 32] = $fShowFoo2_closure;
      P64[Sp - 24] = _c3HA::P64;
      Sp = Sp - 32;
      call ++_entry() args: 40, res: 0, upd: 24;
}


==================== Sink assignments ====================
2016-08-04 14:18:39.984791 UTC

{offset
  c3HW:
      _s3Ea::P64 = R1;
      if ((Sp + -32) < SpLim) goto c3HX; else goto c3HY;
  c3HY:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c3I0; else goto c3HZ;
  c3I0:
      HpAlloc = 32;
      goto c3HX;
  c3HX:
      R1 = _s3Ea::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c3HZ:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _s3Ea::P64;
      _s3DT::P64 = P64[_s3Ea::P64 + 16];
      _s3DU::P64 = P64[_s3Ea::P64 + 24];
      I64[Hp - 24] = sat_s3E9_info;
      P64[Hp - 8] = _s3DT::P64;
      P64[Hp] = _s3DU::P64;
      P64[Sp - 32] = $fShowFoo2_closure;
      P64[Sp - 24] = Hp - 24;
      Sp = Sp - 32;
      call ++_entry() args: 40, res: 0, upd: 24;
}


==================== CAFEnv ====================
2016-08-04 14:18:39.987865 UTC

[(c3HW, {$fShowFoo2_closure, sat_s3E9_closure}), (c3HX, {}),
 (c3HY, {$fShowFoo2_closure, sat_s3E9_closure}),
 (c3HZ, {$fShowFoo2_closure, sat_s3E9_closure}), (c3I0, {})]


==================== procpoint map ====================
2016-08-04 14:18:39.989185 UTC

[(c3HW, <procpt>), (c3HX, reached by c3HW),
 (c3HY, reached by c3HW), (c3HZ, reached by c3HW),
 (c3I0, reached by c3HW)]


==================== Post splitting ====================
2016-08-04 14:18:39.990276 UTC

sat_s3Ea_entry() //  [R1]
        { info_tbl: [(c3HW,
                      label: sat_s3Ea_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3HW:
          _s3Ea::P64 = R1;
          if ((Sp + -32) < SpLim) goto c3HX; else goto c3HY;
      c3HY:
          Hp = Hp + 32;
          if (Hp > HpLim) goto c3I0; else goto c3HZ;
      c3I0:
          HpAlloc = 32;
          goto c3HX;
      c3HX:
          R1 = _s3Ea::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3HZ:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s3Ea::P64;
          _s3DT::P64 = P64[_s3Ea::P64 + 16];
          _s3DU::P64 = P64[_s3Ea::P64 + 24];
          I64[Hp - 24] = sat_s3E9_info;
          P64[Hp - 8] = _s3DT::P64;
          P64[Hp] = _s3DU::P64;
          P64[Sp - 32] = $fShowFoo2_closure;
          P64[Sp - 24] = Hp - 24;
          Sp = Sp - 32;
          call ++_entry() args: 40, res: 0, upd: 24;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:39.994169 UTC

sat_s3Ea_entry() //  [R1]
        { info_tbl: [(c3HW,
                      label: sat_s3Ea_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3HW:
          _s3Ea::P64 = R1;
          if ((Sp + -32) < SpLim) goto c3HX; else goto c3HY;
      c3HY:
          Hp = Hp + 32;
          if (Hp > HpLim) goto c3I0; else goto c3HZ;
      c3I0:
          HpAlloc = 32;
          goto c3HX;
      c3HX:
          R1 = _s3Ea::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3HZ:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s3Ea::P64;
          _s3DT::P64 = P64[_s3Ea::P64 + 16];
          _s3DU::P64 = P64[_s3Ea::P64 + 24];
          I64[Hp - 24] = sat_s3E9_info;
          P64[Hp - 8] = _s3DT::P64;
          P64[Hp] = _s3DU::P64;
          P64[Sp - 32] = $fShowFoo2_closure;
          P64[Sp - 24] = Hp - 24;
          Sp = Sp - 32;
          call ++_entry() args: 40, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:39.998679 UTC

sat_s3Ea_entry() //  [R1]
        { info_tbl: [(c3HW,
                      label: sat_s3Ea_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3HW:
          _s3Ea::P64 = R1;
          if ((Sp + -32) < SpLim) goto c3HX; else goto c3HY;
      c3HY:
          Hp = Hp + 32;
          if (Hp > HpLim) goto c3I0; else goto c3HZ;
      c3I0:
          HpAlloc = 32;
          goto c3HX;
      c3HX:
          R1 = _s3Ea::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c3HZ:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _s3Ea::P64;
          _s3DT::P64 = P64[_s3Ea::P64 + 16];
          _s3DU::P64 = P64[_s3Ea::P64 + 24];
          I64[Hp - 24] = sat_s3E9_info;
          P64[Hp - 8] = _s3DT::P64;
          P64[Hp] = _s3DU::P64;
          P64[Sp - 32] = $fShowFoo2_closure;
          P64[Sp - 24] = Hp - 24;
          Sp = Sp - 32;
          call ++_entry() args: 40, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.002823 UTC

{offset
  c3I1:
      _s3DS::I64 = I64[(old + 32)];
      _s3DT::P64 = P64[(old + 24)];
      _s3DU::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3I2; else goto c3I3;
  c3I3:
      Hp = Hp + 56;
      if (Hp > HpLim) goto c3I5; else goto c3I4;
  c3I5:
      HpAlloc = 56;
      goto c3I2;
  c3I2:
      R1 = $w$cshowsPrec_closure;
      I64[(old + 32)] = _s3DS::I64;
      P64[(old + 24)] = _s3DT::P64;
      P64[(old + 16)] = _s3DU::P64;
      call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
  c3I4:
      _c3H7::I64 = %MO_S_Ge_W64(_s3DS::I64, 11);
      _s3DV::I64 = _c3H7::I64;
      if (_s3DV::I64 >= 1) goto c3Ib; else goto c3Ic;
  c3Ib:
      I64[Hp - 48] = sat_s3Ea_info;
      P64[Hp - 32] = _s3DT::P64;
      P64[Hp - 24] = _s3DU::P64;
      _c3Hw::P64 = Hp - 48;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows9_closure;
      P64[Hp] = _c3Hw::P64;
      _c3I8::P64 = Hp - 14;
      R1 = _c3I8::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
  c3Ic:
      I64[Hp - 48] = sat_s3E2_info;
      P64[Hp - 32] = _s3DT::P64;
      P64[Hp - 24] = _s3DU::P64;
      _c3Hc::P64 = Hp - 48;
      Hp = Hp - 24;
      P64[(old + 24)] = $fShowFoo2_closure;
      P64[(old + 16)] = _c3Hc::P64;
      call ++_entry() args: 24, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:18:40.008432 UTC

{offset
  c3I1:
      _s3DS::I64 = I64[(old + 32)];
      _s3DT::P64 = P64[(old + 24)];
      _s3DU::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3I2; else goto c3I3;
  c3I3:
      Hp = Hp + 56;
      if (Hp > HpLim) goto c3I5; else goto c3I4;
  c3I5:
      HpAlloc = 56;
      goto c3I2;
  c3I2:
      R1 = $w$cshowsPrec_closure;
      I64[(old + 32)] = _s3DS::I64;
      P64[(old + 24)] = _s3DT::P64;
      P64[(old + 16)] = _s3DU::P64;
      call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
  c3I4:
      _c3H7::I64 = %MO_S_Ge_W64(_s3DS::I64, 11);
      _s3DV::I64 = _c3H7::I64;
      if (_s3DV::I64 >= 1) goto c3Ib; else goto c3Ic;
  c3Ib:
      I64[Hp - 48] = sat_s3Ea_info;
      P64[Hp - 32] = _s3DT::P64;
      P64[Hp - 24] = _s3DU::P64;
      _c3Hw::P64 = Hp - 48;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows9_closure;
      P64[Hp] = _c3Hw::P64;
      _c3I8::P64 = Hp - 14;
      R1 = _c3I8::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
  c3Ic:
      I64[Hp - 48] = sat_s3E2_info;
      P64[Hp - 32] = _s3DT::P64;
      P64[Hp - 24] = _s3DU::P64;
      _c3Hc::P64 = Hp - 48;
      Hp = Hp - 24;
      P64[(old + 24)] = $fShowFoo2_closure;
      P64[(old + 16)] = _c3Hc::P64;
      call ++_entry() args: 24, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:18:40.013575 UTC

$w$cshowsPrec_entry
[c3I1]
{offset
  c3I1:
      _s3DS::I64 = I64[(old + 32)];
      _s3DT::P64 = P64[(old + 24)];
      _s3DU::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3I2; else goto c3I3;
  c3I3:
      Hp = Hp + 56;
      if (Hp > HpLim) goto c3I5; else goto c3I4;
  c3I5:
      HpAlloc = 56;
      goto c3I2;
  c3I2:
      R1 = $w$cshowsPrec_closure;
      I64[(old + 32)] = _s3DS::I64;
      P64[(old + 24)] = _s3DT::P64;
      P64[(old + 16)] = _s3DU::P64;
      call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
  c3I4:
      _c3H7::I64 = %MO_S_Ge_W64(_s3DS::I64, 11);
      _s3DV::I64 = _c3H7::I64;
      if (_s3DV::I64 >= 1) goto c3Ib; else goto c3Ic;
  c3Ib:
      I64[Hp - 48] = sat_s3Ea_info;
      P64[Hp - 32] = _s3DT::P64;
      P64[Hp - 24] = _s3DU::P64;
      _c3Hw::P64 = Hp - 48;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows9_closure;
      P64[Hp] = _c3Hw::P64;
      _c3I8::P64 = Hp - 14;
      R1 = _c3I8::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
  c3Ic:
      I64[Hp - 48] = sat_s3E2_info;
      P64[Hp - 32] = _s3DT::P64;
      P64[Hp - 24] = _s3DU::P64;
      _c3Hc::P64 = Hp - 48;
      Hp = Hp - 24;
      P64[(old + 24)] = $fShowFoo2_closure;
      P64[(old + 16)] = _c3Hc::P64;
      call ++_entry() args: 24, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:18:40.019712 UTC

{offset
  c3I1:
      _s3DS::I64 = I64[Sp];
      _s3DT::P64 = P64[Sp + 8];
      _s3DU::P64 = P64[Sp + 16];
      goto c3I3;
  c3I3:
      Hp = Hp + 56;
      if (Hp > HpLim) goto c3I5; else goto c3I4;
  c3I5:
      HpAlloc = 56;
      goto c3I2;
  c3I2:
      R1 = $w$cshowsPrec_closure;
      call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
  c3I4:
      _c3H7::I64 = %MO_S_Ge_W64(_s3DS::I64, 11);
      _s3DV::I64 = _c3H7::I64;
      if (_s3DV::I64 >= 1) goto c3Ib; else goto c3Ic;
  c3Ib:
      I64[Hp - 48] = sat_s3Ea_info;
      P64[Hp - 32] = _s3DT::P64;
      P64[Hp - 24] = _s3DU::P64;
      _c3Hw::P64 = Hp - 48;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows9_closure;
      P64[Hp] = _c3Hw::P64;
      _c3I8::P64 = Hp - 14;
      R1 = _c3I8::P64;
      Sp = Sp + 24;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
  c3Ic:
      I64[Hp - 48] = sat_s3E2_info;
      P64[Hp - 32] = _s3DT::P64;
      P64[Hp - 24] = _s3DU::P64;
      _c3Hc::P64 = Hp - 48;
      Hp = Hp - 24;
      P64[Sp + 8] = $fShowFoo2_closure;
      P64[Sp + 16] = _c3Hc::P64;
      Sp = Sp + 8;
      call ++_entry() args: 24, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:18:40.025374 UTC

{offset
  c3I1:
      goto c3I3;
  c3I3:
      Hp = Hp + 56;
      if (Hp > HpLim) goto c3I5; else goto c3I4;
  c3I5:
      HpAlloc = 56;
      goto c3I2;
  c3I2:
      R1 = $w$cshowsPrec_closure;
      call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
  c3I4:
      _s3DT::P64 = P64[Sp + 8];
      _s3DU::P64 = P64[Sp + 16];
      if (%MO_S_Ge_W64(I64[Sp], 11)) goto c3Ib; else goto c3Ic;
  c3Ib:
      I64[Hp - 48] = sat_s3Ea_info;
      P64[Hp - 32] = _s3DT::P64;
      P64[Hp - 24] = _s3DU::P64;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = shows9_closure;
      P64[Hp] = Hp - 48;
      R1 = Hp - 14;
      Sp = Sp + 24;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
  c3Ic:
      I64[Hp - 48] = sat_s3E2_info;
      P64[Hp - 32] = _s3DT::P64;
      P64[Hp - 24] = _s3DU::P64;
      _c3Hc::P64 = Hp - 48;
      Hp = Hp - 24;
      P64[Sp + 8] = $fShowFoo2_closure;
      P64[Sp + 16] = _c3Hc::P64;
      Sp = Sp + 8;
      call ++_entry() args: 24, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:18:40.0295 UTC

[(c3I1,
  {$fShowFoo2_closure, $w$cshowsPrec_closure, sat_s3E2_closure,
   sat_s3Ea_closure}),
 (c3I2, {$w$cshowsPrec_closure}),
 (c3I3,
  {$fShowFoo2_closure, $w$cshowsPrec_closure, sat_s3E2_closure,
   sat_s3Ea_closure}),
 (c3I4, {$fShowFoo2_closure, sat_s3E2_closure, sat_s3Ea_closure}),
 (c3I5, {$w$cshowsPrec_closure}), (c3Ib, {sat_s3Ea_closure}),
 (c3Ic, {$fShowFoo2_closure, sat_s3E2_closure})]


==================== procpoint map ====================
2016-08-04 14:18:40.031614 UTC

[(c3I1, <procpt>), (c3I2, reached by c3I1),
 (c3I3, reached by c3I1), (c3I4, reached by c3I1),
 (c3I5, reached by c3I1), (c3Ib, reached by c3I1),
 (c3Ic, reached by c3I1)]


==================== Post splitting ====================
2016-08-04 14:18:40.03287 UTC

$w$cshowsPrec_entry() //  []
        { info_tbl: [(c3I1,
                      label: $w$cshowsPrec_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3I1:
          goto c3I3;
      c3I3:
          Hp = Hp + 56;
          if (Hp > HpLim) goto c3I5; else goto c3I4;
      c3I5:
          HpAlloc = 56;
          goto c3I2;
      c3I2:
          R1 = $w$cshowsPrec_closure;
          call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
      c3I4:
          _s3DT::P64 = P64[Sp + 8];
          _s3DU::P64 = P64[Sp + 16];
          if (%MO_S_Ge_W64(I64[Sp], 11)) goto c3Ib; else goto c3Ic;
      c3Ib:
          I64[Hp - 48] = sat_s3Ea_info;
          P64[Hp - 32] = _s3DT::P64;
          P64[Hp - 24] = _s3DU::P64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = shows9_closure;
          P64[Hp] = Hp - 48;
          R1 = Hp - 14;
          Sp = Sp + 24;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
      c3Ic:
          I64[Hp - 48] = sat_s3E2_info;
          P64[Hp - 32] = _s3DT::P64;
          P64[Hp - 24] = _s3DU::P64;
          _c3Hc::P64 = Hp - 48;
          Hp = Hp - 24;
          P64[Sp + 8] = $fShowFoo2_closure;
          P64[Sp + 16] = _c3Hc::P64;
          Sp = Sp + 8;
          call ++_entry() args: 24, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:40.037963 UTC

$w$cshowsPrec_entry() //  []
        { info_tbl: [(c3I1,
                      label: $w$cshowsPrec_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3I1:
          goto c3I3;
      c3I3:
          Hp = Hp + 56;
          if (Hp > HpLim) goto c3I5; else goto c3I4;
      c3I5:
          HpAlloc = 56;
          goto c3I2;
      c3I2:
          R1 = $w$cshowsPrec_closure;
          call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
      c3I4:
          _s3DT::P64 = P64[Sp + 8];
          _s3DU::P64 = P64[Sp + 16];
          if (%MO_S_Ge_W64(I64[Sp], 11)) goto c3Ib; else goto c3Ic;
      c3Ib:
          I64[Hp - 48] = sat_s3Ea_info;
          P64[Hp - 32] = _s3DT::P64;
          P64[Hp - 24] = _s3DU::P64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = shows9_closure;
          P64[Hp] = Hp - 48;
          R1 = Hp - 14;
          Sp = Sp + 24;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
      c3Ic:
          I64[Hp - 48] = sat_s3E2_info;
          P64[Hp - 32] = _s3DT::P64;
          P64[Hp - 24] = _s3DU::P64;
          _c3Hc::P64 = Hp - 48;
          Hp = Hp - 24;
          P64[Sp + 8] = $fShowFoo2_closure;
          P64[Sp + 16] = _c3Hc::P64;
          Sp = Sp + 8;
          call ++_entry() args: 24, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.042786 UTC

$w$cshowsPrec_entry() //  []
        { info_tbl: [(c3I1,
                      label: $w$cshowsPrec_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3I1:
          Hp = Hp + 56;
          if (Hp > HpLim) goto c3I5; else goto c3I4;
      c3I5:
          HpAlloc = 56;
          R1 = $w$cshowsPrec_closure;
          call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
      c3I4:
          _s3DT::P64 = P64[Sp + 8];
          _s3DU::P64 = P64[Sp + 16];
          if (%MO_S_Ge_W64(I64[Sp], 11)) goto c3Ib; else goto c3Ic;
      c3Ib:
          I64[Hp - 48] = sat_s3Ea_info;
          P64[Hp - 32] = _s3DT::P64;
          P64[Hp - 24] = _s3DU::P64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = shows9_closure;
          P64[Hp] = Hp - 48;
          R1 = Hp - 14;
          Sp = Sp + 24;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
      c3Ic:
          I64[Hp - 48] = sat_s3E2_info;
          P64[Hp - 32] = _s3DT::P64;
          P64[Hp - 24] = _s3DU::P64;
          _c3Hc::P64 = Hp - 48;
          Hp = Hp - 24;
          P64[Sp + 8] = $fShowFoo2_closure;
          P64[Sp + 16] = _c3Hc::P64;
          Sp = Sp + 8;
          call ++_entry() args: 24, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:18:40.047528 UTC

[section "data" {
     $w$cshowsPrec_closure:
         const $w$cshowsPrec_info;
         const 0;
 },
 sat_s3E2_entry() //  [R1]
         { info_tbl: [(c3Hj,
                       label: sat_s3E2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Hj:
           if ((Sp + -32) < SpLim) goto c3Hp; else goto c3Hq;
       c3Hp:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3Hq:
           I64[Sp - 16] = block_c3Hg_info;
           _s3DU::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 8] = _s3DU::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u3Id; else goto c3Hh;
       u3Id:
           call block_c3Hg_entry(R1) args: 0, res: 0, upd: 0;
       c3Hh:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3Hg_entry() //  [R1]
         { info_tbl: [(c3Hg,
                       label: block_c3Hg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Hg:
           _s3DU::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c3Hm_info;
           I64[Sp - 16] = 11;
           I64[Sp - 8] = I64[R1 + 7];
           P64[Sp] = _s3DU::P64;
           Sp = Sp - 16;
           call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
     }
 },
 block_c3Hm_entry() //  [R1]
         { info_tbl: [(c3Hm,
                       label: block_c3Hm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Hm:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c3Hu; else goto c3Ht;
       c3Hu:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
       c3Ht:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp];
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s3E9_entry() //  [R1]
         { info_tbl: [(c3HH,
                       label: sat_s3E9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3HH:
           if ((Sp + -32) < SpLim) goto c3HO; else goto c3HP;
       c3HO:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3HP:
           I64[Sp - 16] = block_c3HE_info;
           _s3DU::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 8] = _s3DU::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u3Ie; else goto c3HF;
       u3Ie:
           call block_c3HE_entry(R1) args: 0, res: 0, upd: 0;
       c3HF:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3HE_entry() //  [R1]
         { info_tbl: [(c3HE,
                       label: block_c3HE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3HE:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c3HS; else goto c3HR;
       c3HS:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c3HR:
           _s3E4::I64 = I64[R1 + 7];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = shows8_closure;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c3HL_info;
           I64[Sp - 16] = 11;
           I64[Sp - 8] = _s3E4::I64;
           P64[Sp] = Hp - 14;
           Sp = Sp - 16;
           call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
     }
 },
 block_c3HL_entry() //  [R1]
         { info_tbl: [(c3HL,
                       label: block_c3HL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3HL:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c3HV; else goto c3HU;
       c3HV:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
       c3HU:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp];
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s3Ea_entry() //  [R1]
         { info_tbl: [(c3HW,
                       label: sat_s3Ea_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3HW:
           _s3Ea::P64 = R1;
           if ((Sp + -32) < SpLim) goto c3HX; else goto c3HY;
       c3HY:
           Hp = Hp + 32;
           if (Hp > HpLim) goto c3I0; else goto c3HZ;
       c3I0:
           HpAlloc = 32;
           goto c3HX;
       c3HX:
           R1 = _s3Ea::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3HZ:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s3Ea::P64;
           _s3DT::P64 = P64[_s3Ea::P64 + 16];
           _s3DU::P64 = P64[_s3Ea::P64 + 24];
           I64[Hp - 24] = sat_s3E9_info;
           P64[Hp - 8] = _s3DT::P64;
           P64[Hp] = _s3DU::P64;
           P64[Sp - 32] = $fShowFoo2_closure;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call ++_entry() args: 40, res: 0, upd: 24;
     }
 },
 $w$cshowsPrec_entry() //  []
         { info_tbl: [(c3I1,
                       label: $w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3I1:
           Hp = Hp + 56;
           if (Hp > HpLim) goto c3I5; else goto c3I4;
       c3I5:
           HpAlloc = 56;
           R1 = $w$cshowsPrec_closure;
           call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
       c3I4:
           _s3DT::P64 = P64[Sp + 8];
           _s3DU::P64 = P64[Sp + 16];
           if (%MO_S_Ge_W64(I64[Sp], 11)) goto c3Ib; else goto c3Ic;
       c3Ib:
           I64[Hp - 48] = sat_s3Ea_info;
           P64[Hp - 32] = _s3DT::P64;
           P64[Hp - 24] = _s3DU::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = shows9_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c3Ic:
           I64[Hp - 48] = sat_s3E2_info;
           P64[Hp - 32] = _s3DT::P64;
           P64[Hp - 24] = _s3DU::P64;
           _c3Hc::P64 = Hp - 48;
           Hp = Hp - 24;
           P64[Sp + 8] = $fShowFoo2_closure;
           P64[Sp + 16] = _c3Hc::P64;
           Sp = Sp + 8;
           call ++_entry() args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:18:40.069226 UTC

[section "data" {
     $w$cshowsPrec_closure:
         const $w$cshowsPrec_info;
         const 0;
 },
 sat_s3E2_entry() //  [R1]
         { info_tbl: [(c3Hj,
                       label: sat_s3E2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Hj:
           if ((Sp + -32) < SpLim) goto c3Hp; else goto c3Hq;
       c3Hp:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3Hq:
           I64[Sp - 16] = block_c3Hg_info;
           _s3DU::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 8] = _s3DU::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u3Id; else goto c3Hh;
       u3Id:
           call block_c3Hg_entry(R1) args: 0, res: 0, upd: 0;
       c3Hh:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3Hg_entry() //  [R1]
         { info_tbl: [(c3Hg,
                       label: block_c3Hg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Hg:
           _s3DU::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c3Hm_info;
           I64[Sp - 16] = 11;
           I64[Sp - 8] = I64[R1 + 7];
           P64[Sp] = _s3DU::P64;
           Sp = Sp - 16;
           call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
     }
 },
 block_c3Hm_entry() //  [R1]
         { info_tbl: [(c3Hm,
                       label: block_c3Hm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Hm:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c3Hu; else goto c3Ht;
       c3Hu:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
       c3Ht:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp];
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s3E9_entry() //  [R1]
         { info_tbl: [(c3HH,
                       label: sat_s3E9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3HH:
           if ((Sp + -32) < SpLim) goto c3HO; else goto c3HP;
       c3HO:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3HP:
           I64[Sp - 16] = block_c3HE_info;
           _s3DU::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 8] = _s3DU::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u3Ie; else goto c3HF;
       u3Ie:
           call block_c3HE_entry(R1) args: 0, res: 0, upd: 0;
       c3HF:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3HE_entry() //  [R1]
         { info_tbl: [(c3HE,
                       label: block_c3HE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3HE:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c3HS; else goto c3HR;
       c3HS:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c3HR:
           _s3E4::I64 = I64[R1 + 7];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = shows8_closure;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c3HL_info;
           I64[Sp - 16] = 11;
           I64[Sp - 8] = _s3E4::I64;
           P64[Sp] = Hp - 14;
           Sp = Sp - 16;
           call $wshowSignedInt_entry() args: 32, res: 16, upd: 8;
     }
 },
 block_c3HL_entry() //  [R1]
         { info_tbl: [(c3HL,
                       label: block_c3HL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3HL:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c3HV; else goto c3HU;
       c3HV:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_pp(R1) args: 16, res: 16, upd: 8;
       c3HU:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp];
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s3Ea_entry() //  [R1]
         { info_tbl: [(c3HW,
                       label: sat_s3Ea_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3HW:
           _s3Ea::P64 = R1;
           if ((Sp + -32) < SpLim) goto c3HX; else goto c3HY;
       c3HY:
           Hp = Hp + 32;
           if (Hp > HpLim) goto c3I0; else goto c3HZ;
       c3I0:
           HpAlloc = 32;
           goto c3HX;
       c3HX:
           R1 = _s3Ea::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c3HZ:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s3Ea::P64;
           _s3DT::P64 = P64[_s3Ea::P64 + 16];
           _s3DU::P64 = P64[_s3Ea::P64 + 24];
           I64[Hp - 24] = sat_s3E9_info;
           P64[Hp - 8] = _s3DT::P64;
           P64[Hp] = _s3DU::P64;
           P64[Sp - 32] = $fShowFoo2_closure;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call ++_entry() args: 40, res: 0, upd: 24;
     }
 },
 $w$cshowsPrec_entry() //  []
         { info_tbl: [(c3I1,
                       label: $w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3I1:
           Hp = Hp + 56;
           if (Hp > HpLim) goto c3I5; else goto c3I4;
       c3I5:
           HpAlloc = 56;
           R1 = $w$cshowsPrec_closure;
           call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
       c3I4:
           _s3DT::P64 = P64[Sp + 8];
           _s3DU::P64 = P64[Sp + 16];
           if (%MO_S_Ge_W64(I64[Sp], 11)) goto c3Ib; else goto c3Ic;
       c3Ib:
           I64[Hp - 48] = sat_s3Ea_info;
           P64[Hp - 32] = _s3DT::P64;
           P64[Hp - 24] = _s3DU::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = shows9_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c3Ic:
           I64[Hp - 48] = sat_s3E2_info;
           P64[Hp - 32] = _s3DT::P64;
           P64[Hp - 24] = _s3DU::P64;
           _c3Hc::P64 = Hp - 48;
           Hp = Hp - 24;
           P64[Sp + 8] = $fShowFoo2_closure;
           P64[Sp + 16] = _c3Hc::P64;
           Sp = Sp + 8;
           call ++_entry() args: 24, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:18:40.27383 UTC

[section "data" {
     $fShowFoo_$cshowsPrec_closure:
         const $fShowFoo_$cshowsPrec_info;
         const 0;
 },
 $fShowFoo_$cshowsPrec_entry() //  []
         { info_tbl: [(c3Uw,
                       label: $fShowFoo_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 32 updfr_space: Just 8
         }
     {offset
       c3Uw:
           _s3Eb::P64 = P64[(old + 32)];
           _s3Ec::P64 = P64[(old + 24)];
           _s3Ed::P64 = P64[(old + 16)];
           goto c3Ur;
       c3Ur:
           if ((old + 0) - <highSp> < SpLim) goto c3UA; else goto c3UB;
       c3UA:
           R1 = $fShowFoo_$cshowsPrec_closure;
           P64[(old + 32)] = _s3Eb::P64;
           P64[(old + 24)] = _s3Ec::P64;
           P64[(old + 16)] = _s3Ed::P64;
           call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
       c3UB:
           goto c3Uq;
       c3Uq:
           I64[(young<c3Ut> + 8)] = c3Ut;
           R1 = _s3Eb::P64;
           if (R1 & 7 != 0) goto c3Ut; else goto c3Uu;
       c3Uu:
           call (I64[I64[R1]])(R1) returns to c3Ut, args: 8, res: 8, upd: 8;
       c3Ut:
           _s3Ee::P64 = R1;
           _s3Ef::I64 = I64[_s3Ee::P64 + 7];
           I64[(young<c3Uz> + 8)] = c3Uz;
           R1 = _s3Ec::P64;
           if (R1 & 7 != 0) goto c3Uz; else goto c3UD;
       c3UD:
           call (I64[I64[R1]])(R1) returns to c3Uz, args: 8, res: 8, upd: 8;
       c3Uz:
           _s3Eg::P64 = R1;
           _s3Eh::P64 = P64[_s3Eg::P64 + 7];
           I64[(old + 32)] = _s3Ef::I64;
           P64[(old + 24)] = _s3Eh::P64;
           P64[(old + 16)] = _s3Ed::P64;
           call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.280764 UTC

{offset
  c3Uw:
      _s3Eb::P64 = P64[(old + 32)];
      _s3Ec::P64 = P64[(old + 24)];
      _s3Ed::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3UA; else goto c3UB;
  c3UA:
      R1 = $fShowFoo_$cshowsPrec_closure;
      P64[(old + 32)] = _s3Eb::P64;
      P64[(old + 24)] = _s3Ec::P64;
      P64[(old + 16)] = _s3Ed::P64;
      call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
  c3UB:
      I64[(young<c3Ut> + 8)] = c3Ut;
      R1 = _s3Eb::P64;
      if (R1 & 7 != 0) goto c3Ut; else goto c3Uu;
  c3Uu:
      call (I64[I64[R1]])(R1) returns to c3Ut, args: 8, res: 8, upd: 8;
  c3Ut:
      _s3Ee::P64 = R1;
      _s3Ef::I64 = I64[_s3Ee::P64 + 7];
      I64[(young<c3Uz> + 8)] = c3Uz;
      R1 = _s3Ec::P64;
      if (R1 & 7 != 0) goto c3Uz; else goto c3UD;
  c3UD:
      call (I64[I64[R1]])(R1) returns to c3Uz, args: 8, res: 8, upd: 8;
  c3Uz:
      _s3Eg::P64 = R1;
      _s3Eh::P64 = P64[_s3Eg::P64 + 7];
      I64[(old + 32)] = _s3Ef::I64;
      P64[(old + 24)] = _s3Eh::P64;
      P64[(old + 16)] = _s3Ed::P64;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:18:40.285599 UTC

{offset
  c3Uw:
      _s3Eb::P64 = P64[(old + 32)];
      _s3Ec::P64 = P64[(old + 24)];
      _s3Ed::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3UA; else goto c3UB;
  c3UA:
      R1 = $fShowFoo_$cshowsPrec_closure;
      P64[(old + 32)] = _s3Eb::P64;
      P64[(old + 24)] = _s3Ec::P64;
      P64[(old + 16)] = _s3Ed::P64;
      call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
  c3UB:
      I64[(young<c3Ut> + 8)] = c3Ut;
      R1 = _s3Eb::P64;
      if (R1 & 7 != 0) goto c3Ut; else goto c3Uu;
  c3Uu:
      call (I64[I64[R1]])(R1) returns to c3Ut, args: 8, res: 8, upd: 8;
  c3Ut:
      _s3Ee::P64 = R1;
      _s3Ef::I64 = I64[_s3Ee::P64 + 7];
      I64[(young<c3Uz> + 8)] = c3Uz;
      R1 = _s3Ec::P64;
      if (R1 & 7 != 0) goto c3Uz; else goto c3UD;
  c3UD:
      call (I64[I64[R1]])(R1) returns to c3Uz, args: 8, res: 8, upd: 8;
  c3Uz:
      _s3Eg::P64 = R1;
      _s3Eh::P64 = P64[_s3Eg::P64 + 7];
      I64[(old + 32)] = _s3Ef::I64;
      P64[(old + 24)] = _s3Eh::P64;
      P64[(old + 16)] = _s3Ed::P64;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:18:40.290024 UTC

$fShowFoo_$cshowsPrec_entry
[c3Ut, c3Uw, c3Uz]
{offset
  c3Uw:
      _s3Eb::P64 = P64[(old + 32)];
      _s3Ec::P64 = P64[(old + 24)];
      _s3Ed::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3UA; else goto c3UB;
  c3UA:
      R1 = $fShowFoo_$cshowsPrec_closure;
      P64[(old + 32)] = _s3Eb::P64;
      P64[(old + 24)] = _s3Ec::P64;
      P64[(old + 16)] = _s3Ed::P64;
      call (stg_gc_fun)(R1) args: 32, res: 0, upd: 8;
  c3UB:
      I64[(young<c3Ut> + 8)] = c3Ut;
      R1 = _s3Eb::P64;
      if (R1 & 7 != 0) goto c3Ut; else goto c3Uu;
  c3Uu:
      call (I64[I64[R1]])(R1) returns to c3Ut, args: 8, res: 8, upd: 8;
  c3Ut:
      _s3Ee::P64 = R1;
      _s3Ef::I64 = I64[_s3Ee::P64 + 7];
      I64[(young<c3Uz> + 8)] = c3Uz;
      R1 = _s3Ec::P64;
      if (R1 & 7 != 0) goto c3Uz; else goto c3UD;
  c3UD:
      call (I64[I64[R1]])(R1) returns to c3Uz, args: 8, res: 8, upd: 8;
  c3Uz:
      _s3Eg::P64 = R1;
      _s3Eh::P64 = P64[_s3Eg::P64 + 7];
      I64[(old + 32)] = _s3Ef::I64;
      P64[(old + 24)] = _s3Eh::P64;
      P64[(old + 16)] = _s3Ed::P64;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:18:40.296423 UTC

{offset
  c3Uw:
      _s3Eb::P64 = P64[Sp];
      _s3Ec::P64 = P64[Sp + 8];
      _s3Ed::P64 = P64[Sp + 16];
      goto c3UB;
  c3UB:
      I64[Sp] = c3Ut;
      R1 = _s3Eb::P64;
      if (R1 & 7 != 0) goto c3Ut; else goto c3Uu;
  c3Uu:
      call (I64[I64[R1]])(R1) returns to c3Ut, args: 8, res: 8, upd: 8;
  c3Ut:
      _s3Ec::P64 = P64[Sp + 8];
      _s3Ed::P64 = P64[Sp + 16];
      _s3Ee::P64 = R1;
      _s3Ef::I64 = I64[_s3Ee::P64 + 7];
      I64[Sp] = c3Uz;
      R1 = _s3Ec::P64;
      I64[Sp + 8] = _s3Ef::I64;
      if (R1 & 7 != 0) goto c3Uz; else goto c3UD;
  c3UD:
      call (I64[I64[R1]])(R1) returns to c3Uz, args: 8, res: 8, upd: 8;
  c3Uz:
      _s3Ed::P64 = P64[Sp + 16];
      _s3Ef::I64 = I64[Sp + 8];
      _s3Eg::P64 = R1;
      _s3Eh::P64 = P64[_s3Eg::P64 + 7];
      I64[Sp] = _s3Ef::I64;
      P64[Sp + 8] = _s3Eh::P64;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:18:40.301036 UTC

{offset
  c3Uw:
      goto c3UB;
  c3UB:
      _s3Eb::P64 = P64[Sp];
      I64[Sp] = c3Ut;
      R1 = _s3Eb::P64;
      if (R1 & 7 != 0) goto c3Ut; else goto c3Uu;
  c3Uu:
      call (I64[I64[R1]])(R1) returns to c3Ut, args: 8, res: 8, upd: 8;
  c3Ut:
      I64[Sp] = c3Uz;
      _s3Ef::I64 = I64[R1 + 7];
      R1 = P64[Sp + 8];
      I64[Sp + 8] = _s3Ef::I64;
      if (R1 & 7 != 0) goto c3Uz; else goto c3UD;
  c3UD:
      call (I64[I64[R1]])(R1) returns to c3Uz, args: 8, res: 8, upd: 8;
  c3Uz:
      I64[Sp] = I64[Sp + 8];
      P64[Sp + 8] = P64[R1 + 7];
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:18:40.303928 UTC

[(c3Ut, {$w$cshowsPrec_closure}), (c3Uu, {$w$cshowsPrec_closure}),
 (c3Uw, {$w$cshowsPrec_closure}), (c3Uz, {$w$cshowsPrec_closure}),
 (c3UB, {$w$cshowsPrec_closure}), (c3UD, {$w$cshowsPrec_closure})]


==================== procpoint map ====================
2016-08-04 14:18:40.305244 UTC

[(c3Ut, <procpt>), (c3Uu, reached by c3Uw), (c3Uw, <procpt>),
 (c3Uz, <procpt>), (c3UB, reached by c3Uw), (c3UD, reached by c3Ut)]


==================== Post splitting ====================
2016-08-04 14:18:40.306422 UTC

$fShowFoo_$cshowsPrec_entry() //  []
        { info_tbl: [(c3Uw,
                      label: $fShowFoo_$cshowsPrec_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Uw:
          goto c3UB;
      c3UB:
          _s3Eb::P64 = P64[Sp];
          I64[Sp] = block_c3Ut_info;
          R1 = _s3Eb::P64;
          if (R1 & 7 != 0) goto u3UJ; else goto c3Uu;
      u3UJ:
          call block_c3Ut_entry(R1) args: 0, res: 0, upd: 0;
      c3Uu:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-04 14:18:40.30885 UTC

block_c3Ut_entry() //  [R1]
        { info_tbl: [(c3Ut,
                      label: block_c3Ut_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Ut:
          I64[Sp] = block_c3Uz_info;
          _s3Ef::I64 = I64[R1 + 7];
          R1 = P64[Sp + 8];
          I64[Sp + 8] = _s3Ef::I64;
          if (R1 & 7 != 0) goto u3UI; else goto c3UD;
      u3UI:
          call block_c3Uz_entry(R1) args: 0, res: 0, upd: 0;
      c3UD:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-04 14:18:40.311149 UTC

block_c3Uz_entry() //  [R1]
        { info_tbl: [(c3Uz,
                      label: block_c3Uz_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Uz:
          I64[Sp] = I64[Sp + 8];
          P64[Sp + 8] = P64[R1 + 7];
          call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:40.312728 UTC

$fShowFoo_$cshowsPrec_entry() //  []
        { info_tbl: [(c3Uw,
                      label: $fShowFoo_$cshowsPrec_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Uw:
          goto c3UB;
      c3UB:
          _s3Eb::P64 = P64[Sp];
          I64[Sp] = block_c3Ut_info;
          R1 = _s3Eb::P64;
          if (R1 & 7 != 0) goto u3UJ; else goto c3Uu;
      u3UJ:
          call block_c3Ut_entry(R1) args: 0, res: 0, upd: 0;
      c3Uu:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:40.314922 UTC

block_c3Ut_entry() //  [R1]
        { info_tbl: [(c3Ut,
                      label: block_c3Ut_info
                      rep:StackRep [False, False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Ut:
          I64[Sp] = block_c3Uz_info;
          _s3Ef::I64 = I64[R1 + 7];
          R1 = P64[Sp + 8];
          I64[Sp + 8] = _s3Ef::I64;
          if (R1 & 7 != 0) goto u3UI; else goto c3UD;
      u3UI:
          call block_c3Uz_entry(R1) args: 0, res: 0, upd: 0;
      c3UD:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:40.317273 UTC

block_c3Uz_entry() //  [R1]
        { info_tbl: [(c3Uz,
                      label: block_c3Uz_info
                      rep:StackRep [True, False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Uz:
          I64[Sp] = I64[Sp + 8];
          P64[Sp + 8] = P64[R1 + 7];
          call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.318908 UTC

$fShowFoo_$cshowsPrec_entry() //  []
        { info_tbl: [(c3Uw,
                      label: $fShowFoo_$cshowsPrec_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Uw:
          _s3Eb::P64 = P64[Sp];
          I64[Sp] = block_c3Ut_info;
          R1 = _s3Eb::P64;
          if (R1 & 7 != 0) goto u3UJ; else goto c3Uu;
      u3UJ:
          call block_c3Ut_entry(R1) args: 0, res: 0, upd: 0;
      c3Uu:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.321114 UTC

block_c3Ut_entry() //  [R1]
        { info_tbl: [(c3Ut,
                      label: block_c3Ut_info
                      rep:StackRep [False, False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Ut:
          I64[Sp] = block_c3Uz_info;
          _s3Ef::I64 = I64[R1 + 7];
          R1 = P64[Sp + 8];
          I64[Sp + 8] = _s3Ef::I64;
          if (R1 & 7 != 0) goto u3UI; else goto c3UD;
      u3UI:
          call block_c3Uz_entry(R1) args: 0, res: 0, upd: 0;
      c3UD:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.323448 UTC

block_c3Uz_entry() //  [R1]
        { info_tbl: [(c3Uz,
                      label: block_c3Uz_info
                      rep:StackRep [True, False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Uz:
          I64[Sp] = I64[Sp + 8];
          P64[Sp + 8] = P64[R1 + 7];
          call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:18:40.325077 UTC

[section "data" {
     $fShowFoo_$cshowsPrec_closure:
         const $fShowFoo_$cshowsPrec_info;
         const 0;
 },
 $fShowFoo_$cshowsPrec_entry() //  []
         { info_tbl: [(c3Uw,
                       label: $fShowFoo_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Uw:
           _s3Eb::P64 = P64[Sp];
           I64[Sp] = block_c3Ut_info;
           R1 = _s3Eb::P64;
           if (R1 & 7 != 0) goto u3UJ; else goto c3Uu;
       u3UJ:
           call block_c3Ut_entry(R1) args: 0, res: 0, upd: 0;
       c3Uu:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3Ut_entry() //  [R1]
         { info_tbl: [(c3Ut,
                       label: block_c3Ut_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Ut:
           I64[Sp] = block_c3Uz_info;
           _s3Ef::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s3Ef::I64;
           if (R1 & 7 != 0) goto u3UI; else goto c3UD;
       u3UI:
           call block_c3Uz_entry(R1) args: 0, res: 0, upd: 0;
       c3UD:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3Uz_entry() //  [R1]
         { info_tbl: [(c3Uz,
                       label: block_c3Uz_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Uz:
           I64[Sp] = I64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 7];
           call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:18:40.330591 UTC

[section "data" {
     $fShowFoo_$cshowsPrec_closure:
         const $fShowFoo_$cshowsPrec_info;
         const 0;
 },
 $fShowFoo_$cshowsPrec_entry() //  []
         { info_tbl: [(c3Uw,
                       label: $fShowFoo_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Uw:
           _s3Eb::P64 = P64[Sp];
           I64[Sp] = block_c3Ut_info;
           R1 = _s3Eb::P64;
           if (R1 & 7 != 0) goto u3UJ; else goto c3Uu;
       u3UJ:
           call block_c3Ut_entry(R1) args: 0, res: 0, upd: 0;
       c3Uu:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3Ut_entry() //  [R1]
         { info_tbl: [(c3Ut,
                       label: block_c3Ut_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Ut:
           I64[Sp] = block_c3Uz_info;
           _s3Ef::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s3Ef::I64;
           if (R1 & 7 != 0) goto u3UI; else goto c3UD;
       u3UI:
           call block_c3Uz_entry(R1) args: 0, res: 0, upd: 0;
       c3UD:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3Uz_entry() //  [R1]
         { info_tbl: [(c3Uz,
                       label: block_c3Uz_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Uz:
           I64[Sp] = I64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 7];
           call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:18:40.370507 UTC

[section "data" {
     $fShowFoo1_closure:
         const $fShowFoo1_info;
         const 0;
 },
 $fShowFoo1_entry() //  []
         { info_tbl: [(c3Wx,
                       label: $fShowFoo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 24 updfr_space: Just 8
         }
     {offset
       c3Wx:
           _s3Ei::P64 = P64[(old + 24)];
           _s3Ej::P64 = P64[(old + 16)];
           goto c3Ws;
       c3Ws:
           if ((old + 0) - <highSp> < SpLim) goto c3Wy; else goto c3Wz;
       c3Wy:
           R1 = $fShowFoo1_closure;
           P64[(old + 24)] = _s3Ei::P64;
           P64[(old + 16)] = _s3Ej::P64;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
       c3Wz:
           goto c3Wr;
       c3Wr:
           I64[(young<c3Wu> + 8)] = c3Wu;
           R1 = _s3Ei::P64;
           if (R1 & 7 != 0) goto c3Wu; else goto c3Wv;
       c3Wv:
           call (I64[I64[R1]])(R1) returns to c3Wu, args: 8, res: 8, upd: 8;
       c3Wu:
           _s3Ek::P64 = R1;
           _s3El::P64 = P64[_s3Ek::P64 + 7];
           I64[(old + 32)] = 0;
           P64[(old + 24)] = _s3El::P64;
           P64[(old + 16)] = _s3Ej::P64;
           call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.375801 UTC

{offset
  c3Wx:
      _s3Ei::P64 = P64[(old + 24)];
      _s3Ej::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3Wy; else goto c3Wz;
  c3Wy:
      R1 = $fShowFoo1_closure;
      P64[(old + 24)] = _s3Ei::P64;
      P64[(old + 16)] = _s3Ej::P64;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3Wz:
      I64[(young<c3Wu> + 8)] = c3Wu;
      R1 = _s3Ei::P64;
      if (R1 & 7 != 0) goto c3Wu; else goto c3Wv;
  c3Wv:
      call (I64[I64[R1]])(R1) returns to c3Wu, args: 8, res: 8, upd: 8;
  c3Wu:
      _s3Ek::P64 = R1;
      _s3El::P64 = P64[_s3Ek::P64 + 7];
      I64[(old + 32)] = 0;
      P64[(old + 24)] = _s3El::P64;
      P64[(old + 16)] = _s3Ej::P64;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:18:40.379281 UTC

{offset
  c3Wx:
      _s3Ei::P64 = P64[(old + 24)];
      _s3Ej::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3Wy; else goto c3Wz;
  c3Wy:
      R1 = $fShowFoo1_closure;
      P64[(old + 24)] = _s3Ei::P64;
      P64[(old + 16)] = _s3Ej::P64;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3Wz:
      I64[(young<c3Wu> + 8)] = c3Wu;
      R1 = _s3Ei::P64;
      if (R1 & 7 != 0) goto c3Wu; else goto c3Wv;
  c3Wv:
      call (I64[I64[R1]])(R1) returns to c3Wu, args: 8, res: 8, upd: 8;
  c3Wu:
      _s3Ek::P64 = R1;
      _s3El::P64 = P64[_s3Ek::P64 + 7];
      I64[(old + 32)] = 0;
      P64[(old + 24)] = _s3El::P64;
      P64[(old + 16)] = _s3Ej::P64;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:18:40.382487 UTC

$fShowFoo1_entry
[c3Wu, c3Wx]
{offset
  c3Wx:
      _s3Ei::P64 = P64[(old + 24)];
      _s3Ej::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3Wy; else goto c3Wz;
  c3Wy:
      R1 = $fShowFoo1_closure;
      P64[(old + 24)] = _s3Ei::P64;
      P64[(old + 16)] = _s3Ej::P64;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3Wz:
      I64[(young<c3Wu> + 8)] = c3Wu;
      R1 = _s3Ei::P64;
      if (R1 & 7 != 0) goto c3Wu; else goto c3Wv;
  c3Wv:
      call (I64[I64[R1]])(R1) returns to c3Wu, args: 8, res: 8, upd: 8;
  c3Wu:
      _s3Ek::P64 = R1;
      _s3El::P64 = P64[_s3Ek::P64 + 7];
      I64[(old + 32)] = 0;
      P64[(old + 24)] = _s3El::P64;
      P64[(old + 16)] = _s3Ej::P64;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:18:40.386465 UTC

{offset
  c3Wx:
      _s3Ei::P64 = P64[Sp];
      _s3Ej::P64 = P64[Sp + 8];
      if ((Sp + 24) - 32 < SpLim) goto c3Wy; else goto c3Wz;
  c3Wy:
      R1 = $fShowFoo1_closure;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3Wz:
      I64[Sp] = c3Wu;
      R1 = _s3Ei::P64;
      if (R1 & 7 != 0) goto c3Wu; else goto c3Wv;
  c3Wv:
      call (I64[I64[R1]])(R1) returns to c3Wu, args: 8, res: 8, upd: 8;
  c3Wu:
      _s3Ej::P64 = P64[Sp + 8];
      _s3Ek::P64 = R1;
      _s3El::P64 = P64[_s3Ek::P64 + 7];
      I64[Sp - 8] = 0;
      P64[Sp] = _s3El::P64;
      Sp = Sp - 8;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:18:40.389833 UTC

{offset
  c3Wx:
      if ((Sp + -8) < SpLim) goto c3Wy; else goto c3Wz;
  c3Wy:
      R1 = $fShowFoo1_closure;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3Wz:
      _s3Ei::P64 = P64[Sp];
      I64[Sp] = c3Wu;
      R1 = _s3Ei::P64;
      if (R1 & 7 != 0) goto c3Wu; else goto c3Wv;
  c3Wv:
      call (I64[I64[R1]])(R1) returns to c3Wu, args: 8, res: 8, upd: 8;
  c3Wu:
      I64[Sp - 8] = 0;
      P64[Sp] = P64[R1 + 7];
      Sp = Sp - 8;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:18:40.392209 UTC

[(c3Wu, {$w$cshowsPrec_closure}), (c3Wv, {$w$cshowsPrec_closure}),
 (c3Wx, {$fShowFoo1_closure, $w$cshowsPrec_closure}),
 (c3Wy, {$fShowFoo1_closure}), (c3Wz, {$w$cshowsPrec_closure})]


==================== procpoint map ====================
2016-08-04 14:18:40.393447 UTC

[(c3Wu, <procpt>), (c3Wv, reached by c3Wx), (c3Wx, <procpt>),
 (c3Wy, reached by c3Wx), (c3Wz, reached by c3Wx)]


==================== Post splitting ====================
2016-08-04 14:18:40.39453 UTC

$fShowFoo1_entry() //  []
        { info_tbl: [(c3Wx,
                      label: $fShowFoo1_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Wx:
          if ((Sp + -8) < SpLim) goto c3Wy; else goto c3Wz;
      c3Wy:
          R1 = $fShowFoo1_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
      c3Wz:
          _s3Ei::P64 = P64[Sp];
          I64[Sp] = block_c3Wu_info;
          R1 = _s3Ei::P64;
          if (R1 & 7 != 0) goto u3WD; else goto c3Wv;
      u3WD:
          call block_c3Wu_entry(R1) args: 0, res: 0, upd: 0;
      c3Wv:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-04 14:18:40.397398 UTC

block_c3Wu_entry() //  [R1]
        { info_tbl: [(c3Wu,
                      label: block_c3Wu_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Wu:
          I64[Sp - 8] = 0;
          P64[Sp] = P64[R1 + 7];
          Sp = Sp - 8;
          call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:40.399027 UTC

$fShowFoo1_entry() //  []
        { info_tbl: [(c3Wx,
                      label: $fShowFoo1_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Wx:
          if ((Sp + -8) < SpLim) goto c3Wy; else goto c3Wz;
      c3Wy:
          R1 = $fShowFoo1_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
      c3Wz:
          _s3Ei::P64 = P64[Sp];
          I64[Sp] = block_c3Wu_info;
          R1 = _s3Ei::P64;
          if (R1 & 7 != 0) goto u3WD; else goto c3Wv;
      u3WD:
          call block_c3Wu_entry(R1) args: 0, res: 0, upd: 0;
      c3Wv:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:40.401655 UTC

block_c3Wu_entry() //  [R1]
        { info_tbl: [(c3Wu,
                      label: block_c3Wu_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Wu:
          I64[Sp - 8] = 0;
          P64[Sp] = P64[R1 + 7];
          Sp = Sp - 8;
          call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.403283 UTC

$fShowFoo1_entry() //  []
        { info_tbl: [(c3Wx,
                      label: $fShowFoo1_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Wx:
          if ((Sp + -8) < SpLim) goto c3Wy; else goto c3Wz;
      c3Wy:
          R1 = $fShowFoo1_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
      c3Wz:
          _s3Ei::P64 = P64[Sp];
          I64[Sp] = block_c3Wu_info;
          R1 = _s3Ei::P64;
          if (R1 & 7 != 0) goto u3WD; else goto c3Wv;
      u3WD:
          call block_c3Wu_entry(R1) args: 0, res: 0, upd: 0;
      c3Wv:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.405949 UTC

block_c3Wu_entry() //  [R1]
        { info_tbl: [(c3Wu,
                      label: block_c3Wu_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3Wu:
          I64[Sp - 8] = 0;
          P64[Sp] = P64[R1 + 7];
          Sp = Sp - 8;
          call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:18:40.40848 UTC

[section "data" {
     $fShowFoo1_closure:
         const $fShowFoo1_info;
         const 0;
 },
 $fShowFoo1_entry() //  []
         { info_tbl: [(c3Wx,
                       label: $fShowFoo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Wx:
           if ((Sp + -8) < SpLim) goto c3Wy; else goto c3Wz;
       c3Wy:
           R1 = $fShowFoo1_closure;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
       c3Wz:
           _s3Ei::P64 = P64[Sp];
           I64[Sp] = block_c3Wu_info;
           R1 = _s3Ei::P64;
           if (R1 & 7 != 0) goto u3WD; else goto c3Wv;
       u3WD:
           call block_c3Wu_entry(R1) args: 0, res: 0, upd: 0;
       c3Wv:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3Wu_entry() //  [R1]
         { info_tbl: [(c3Wu,
                       label: block_c3Wu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Wu:
           I64[Sp - 8] = 0;
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 8;
           call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:18:40.412686 UTC

[section "data" {
     $fShowFoo1_closure:
         const $fShowFoo1_info;
         const 0;
 },
 $fShowFoo1_entry() //  []
         { info_tbl: [(c3Wx,
                       label: $fShowFoo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Wx:
           if ((Sp + -8) < SpLim) goto c3Wy; else goto c3Wz;
       c3Wy:
           R1 = $fShowFoo1_closure;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
       c3Wz:
           _s3Ei::P64 = P64[Sp];
           I64[Sp] = block_c3Wu_info;
           R1 = _s3Ei::P64;
           if (R1 & 7 != 0) goto u3WD; else goto c3Wv;
       u3WD:
           call block_c3Wu_entry(R1) args: 0, res: 0, upd: 0;
       c3Wv:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3Wu_entry() //  [R1]
         { info_tbl: [(c3Wu,
                       label: block_c3Wu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3Wu:
           I64[Sp - 8] = 0;
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 8;
           call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:18:40.441811 UTC

[section "data" {
     $fShowFoo_$cshowList_closure:
         const $fShowFoo_$cshowList_info;
         const 0;
 },
 $fShowFoo_$cshowList_entry() //  []
         { info_tbl: [(c3XY,
                       label: $fShowFoo_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 24 updfr_space: Just 8
         }
     {offset
       c3XY:
           _B2::P64 = P64[(old + 24)];
           _B1::P64 = P64[(old + 16)];
           goto c3XW;
       c3XW:
           if ((old + 0) - <highSp> < SpLim) goto c3XZ; else goto c3Y0;
       c3XZ:
           R1 = $fShowFoo_$cshowList_closure;
           P64[(old + 24)] = _B2::P64;
           P64[(old + 16)] = _B1::P64;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
       c3Y0:
           goto c3XV;
       c3XV:
           P64[(old + 32)] = $fShowFoo1_closure+2;
           P64[(old + 24)] = _B2::P64;
           P64[(old + 16)] = _B1::P64;
           call showList___entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.445814 UTC

{offset
  c3XY:
      _B2::P64 = P64[(old + 24)];
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3XZ; else goto c3Y0;
  c3XZ:
      R1 = $fShowFoo_$cshowList_closure;
      P64[(old + 24)] = _B2::P64;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3Y0:
      P64[(old + 32)] = $fShowFoo1_closure+2;
      P64[(old + 24)] = _B2::P64;
      P64[(old + 16)] = _B1::P64;
      call showList___entry() args: 32, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:18:40.448279 UTC

{offset
  c3XY:
      _B2::P64 = P64[(old + 24)];
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3XZ; else goto c3Y0;
  c3XZ:
      R1 = $fShowFoo_$cshowList_closure;
      P64[(old + 24)] = _B2::P64;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3Y0:
      P64[(old + 32)] = $fShowFoo1_closure+2;
      P64[(old + 24)] = _B2::P64;
      P64[(old + 16)] = _B1::P64;
      call showList___entry() args: 32, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:18:40.450523 UTC

$fShowFoo_$cshowList_entry
[c3XY]
{offset
  c3XY:
      _B2::P64 = P64[(old + 24)];
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3XZ; else goto c3Y0;
  c3XZ:
      R1 = $fShowFoo_$cshowList_closure;
      P64[(old + 24)] = _B2::P64;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3Y0:
      P64[(old + 32)] = $fShowFoo1_closure+2;
      P64[(old + 24)] = _B2::P64;
      P64[(old + 16)] = _B1::P64;
      call showList___entry() args: 32, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:18:40.453302 UTC

{offset
  c3XY:
      _B2::P64 = P64[Sp];
      _B1::P64 = P64[Sp + 8];
      if ((Sp + 24) - 32 < SpLim) goto c3XZ; else goto c3Y0;
  c3XZ:
      R1 = $fShowFoo_$cshowList_closure;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3Y0:
      P64[Sp - 8] = $fShowFoo1_closure+2;
      Sp = Sp - 8;
      call showList___entry() args: 32, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:18:40.455313 UTC

{offset
  c3XY:
      if ((Sp + -8) < SpLim) goto c3XZ; else goto c3Y0;
  c3XZ:
      R1 = $fShowFoo_$cshowList_closure;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c3Y0:
      P64[Sp - 8] = $fShowFoo1_closure+2;
      Sp = Sp - 8;
      call showList___entry() args: 32, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:18:40.456829 UTC

[(c3XY, {$fShowFoo1_closure, $fShowFoo_$cshowList_closure}),
 (c3XZ, {$fShowFoo_$cshowList_closure}),
 (c3Y0, {$fShowFoo1_closure})]


==================== procpoint map ====================
2016-08-04 14:18:40.457854 UTC

[(c3XY, <procpt>), (c3XZ, reached by c3XY),
 (c3Y0, reached by c3XY)]


==================== Post splitting ====================
2016-08-04 14:18:40.458745 UTC

$fShowFoo_$cshowList_entry() //  []
        { info_tbl: [(c3XY,
                      label: $fShowFoo_$cshowList_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3XY:
          if ((Sp + -8) < SpLim) goto c3XZ; else goto c3Y0;
      c3XZ:
          R1 = $fShowFoo_$cshowList_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
      c3Y0:
          P64[Sp - 8] = $fShowFoo1_closure+2;
          Sp = Sp - 8;
          call showList___entry() args: 32, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:40.460907 UTC

$fShowFoo_$cshowList_entry() //  []
        { info_tbl: [(c3XY,
                      label: $fShowFoo_$cshowList_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3XY:
          if ((Sp + -8) < SpLim) goto c3XZ; else goto c3Y0;
      c3XZ:
          R1 = $fShowFoo_$cshowList_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
      c3Y0:
          P64[Sp - 8] = $fShowFoo1_closure+2;
          Sp = Sp - 8;
          call showList___entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.463832 UTC

$fShowFoo_$cshowList_entry() //  []
        { info_tbl: [(c3XY,
                      label: $fShowFoo_$cshowList_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3XY:
          if ((Sp + -8) < SpLim) goto c3XZ; else goto c3Y0;
      c3XZ:
          R1 = $fShowFoo_$cshowList_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
      c3Y0:
          P64[Sp - 8] = $fShowFoo1_closure+2;
          Sp = Sp - 8;
          call showList___entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:18:40.465919 UTC

[section "data" {
     $fShowFoo_$cshowList_closure:
         const $fShowFoo_$cshowList_info;
         const 0;
 },
 $fShowFoo_$cshowList_entry() //  []
         { info_tbl: [(c3XY,
                       label: $fShowFoo_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3XY:
           if ((Sp + -8) < SpLim) goto c3XZ; else goto c3Y0;
       c3XZ:
           R1 = $fShowFoo_$cshowList_closure;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
       c3Y0:
           P64[Sp - 8] = $fShowFoo1_closure+2;
           Sp = Sp - 8;
           call showList___entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:18:40.468425 UTC

[section "data" {
     $fShowFoo_$cshowList_closure:
         const $fShowFoo_$cshowList_info;
         const 0;
 },
 $fShowFoo_$cshowList_entry() //  []
         { info_tbl: [(c3XY,
                       label: $fShowFoo_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3XY:
           if ((Sp + -8) < SpLim) goto c3XZ; else goto c3Y0;
       c3XZ:
           R1 = $fShowFoo_$cshowList_closure;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
       c3Y0:
           P64[Sp - 8] = $fShowFoo1_closure+2;
           Sp = Sp - 8;
           call showList___entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:18:40.483829 UTC

[section "data" {
     $fShowFoo_$cshow_closure:
         const $fShowFoo_$cshow_info;
         const 0;
 },
 $fShowFoo_$cshow_entry() //  []
         { info_tbl: [(c3YI,
                       label: $fShowFoo_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 16 updfr_space: Just 8
         }
     {offset
       c3YI:
           _s3Em::P64 = P64[(old + 16)];
           goto c3YD;
       c3YD:
           if ((old + 0) - <highSp> < SpLim) goto c3YJ; else goto c3YK;
       c3YJ:
           R1 = $fShowFoo_$cshow_closure;
           P64[(old + 16)] = _s3Em::P64;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c3YK:
           goto c3YC;
       c3YC:
           I64[(young<c3YF> + 8)] = c3YF;
           R1 = _s3Em::P64;
           if (R1 & 7 != 0) goto c3YF; else goto c3YG;
       c3YG:
           call (I64[I64[R1]])(R1) returns to c3YF, args: 8, res: 8, upd: 8;
       c3YF:
           _s3En::P64 = R1;
           _s3Eo::P64 = P64[_s3En::P64 + 7];
           I64[(old + 32)] = 0;
           P64[(old + 24)] = _s3Eo::P64;
           P64[(old + 16)] = []_closure+1;
           call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.488754 UTC

{offset
  c3YI:
      _s3Em::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3YJ; else goto c3YK;
  c3YJ:
      R1 = $fShowFoo_$cshow_closure;
      P64[(old + 16)] = _s3Em::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c3YK:
      I64[(young<c3YF> + 8)] = c3YF;
      R1 = _s3Em::P64;
      if (R1 & 7 != 0) goto c3YF; else goto c3YG;
  c3YG:
      call (I64[I64[R1]])(R1) returns to c3YF, args: 8, res: 8, upd: 8;
  c3YF:
      _s3En::P64 = R1;
      _s3Eo::P64 = P64[_s3En::P64 + 7];
      I64[(old + 32)] = 0;
      P64[(old + 24)] = _s3Eo::P64;
      P64[(old + 16)] = []_closure+1;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:18:40.491958 UTC

{offset
  c3YI:
      _s3Em::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3YJ; else goto c3YK;
  c3YJ:
      R1 = $fShowFoo_$cshow_closure;
      P64[(old + 16)] = _s3Em::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c3YK:
      I64[(young<c3YF> + 8)] = c3YF;
      R1 = _s3Em::P64;
      if (R1 & 7 != 0) goto c3YF; else goto c3YG;
  c3YG:
      call (I64[I64[R1]])(R1) returns to c3YF, args: 8, res: 8, upd: 8;
  c3YF:
      _s3En::P64 = R1;
      _s3Eo::P64 = P64[_s3En::P64 + 7];
      I64[(old + 32)] = 0;
      P64[(old + 24)] = _s3Eo::P64;
      P64[(old + 16)] = []_closure+1;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:18:40.494866 UTC

$fShowFoo_$cshow_entry
[c3YF, c3YI]
{offset
  c3YI:
      _s3Em::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c3YJ; else goto c3YK;
  c3YJ:
      R1 = $fShowFoo_$cshow_closure;
      P64[(old + 16)] = _s3Em::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c3YK:
      I64[(young<c3YF> + 8)] = c3YF;
      R1 = _s3Em::P64;
      if (R1 & 7 != 0) goto c3YF; else goto c3YG;
  c3YG:
      call (I64[I64[R1]])(R1) returns to c3YF, args: 8, res: 8, upd: 8;
  c3YF:
      _s3En::P64 = R1;
      _s3Eo::P64 = P64[_s3En::P64 + 7];
      I64[(old + 32)] = 0;
      P64[(old + 24)] = _s3Eo::P64;
      P64[(old + 16)] = []_closure+1;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:18:40.498539 UTC

{offset
  c3YI:
      _s3Em::P64 = P64[Sp];
      if ((Sp + 16) - 32 < SpLim) goto c3YJ; else goto c3YK;
  c3YJ:
      R1 = $fShowFoo_$cshow_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c3YK:
      I64[Sp] = c3YF;
      R1 = _s3Em::P64;
      if (R1 & 7 != 0) goto c3YF; else goto c3YG;
  c3YG:
      call (I64[I64[R1]])(R1) returns to c3YF, args: 8, res: 8, upd: 8;
  c3YF:
      _s3En::P64 = R1;
      _s3Eo::P64 = P64[_s3En::P64 + 7];
      I64[Sp - 16] = 0;
      P64[Sp - 8] = _s3Eo::P64;
      P64[Sp] = []_closure+1;
      Sp = Sp - 16;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:18:40.501798 UTC

{offset
  c3YI:
      if ((Sp + -16) < SpLim) goto c3YJ; else goto c3YK;
  c3YJ:
      R1 = $fShowFoo_$cshow_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c3YK:
      _s3Em::P64 = P64[Sp];
      I64[Sp] = c3YF;
      R1 = _s3Em::P64;
      if (R1 & 7 != 0) goto c3YF; else goto c3YG;
  c3YG:
      call (I64[I64[R1]])(R1) returns to c3YF, args: 8, res: 8, upd: 8;
  c3YF:
      I64[Sp - 16] = 0;
      P64[Sp - 8] = P64[R1 + 7];
      P64[Sp] = []_closure+1;
      Sp = Sp - 16;
      call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:18:40.504266 UTC

[(c3YF, {$w$cshowsPrec_closure}), (c3YG, {$w$cshowsPrec_closure}),
 (c3YI, {$w$cshowsPrec_closure, $fShowFoo_$cshow_closure}),
 (c3YJ, {$fShowFoo_$cshow_closure}),
 (c3YK, {$w$cshowsPrec_closure})]


==================== procpoint map ====================
2016-08-04 14:18:40.505526 UTC

[(c3YF, <procpt>), (c3YG, reached by c3YI), (c3YI, <procpt>),
 (c3YJ, reached by c3YI), (c3YK, reached by c3YI)]


==================== Post splitting ====================
2016-08-04 14:18:40.506617 UTC

$fShowFoo_$cshow_entry() //  []
        { info_tbl: [(c3YI,
                      label: $fShowFoo_$cshow_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3YI:
          if ((Sp + -16) < SpLim) goto c3YJ; else goto c3YK;
      c3YJ:
          R1 = $fShowFoo_$cshow_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c3YK:
          _s3Em::P64 = P64[Sp];
          I64[Sp] = block_c3YF_info;
          R1 = _s3Em::P64;
          if (R1 & 7 != 0) goto u3YO; else goto c3YG;
      u3YO:
          call block_c3YF_entry(R1) args: 0, res: 0, upd: 0;
      c3YG:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-04 14:18:40.509407 UTC

block_c3YF_entry() //  [R1]
        { info_tbl: [(c3YF,
                      label: block_c3YF_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3YF:
          I64[Sp - 16] = 0;
          P64[Sp - 8] = P64[R1 + 7];
          P64[Sp] = []_closure+1;
          Sp = Sp - 16;
          call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:40.511208 UTC

$fShowFoo_$cshow_entry() //  []
        { info_tbl: [(c3YI,
                      label: $fShowFoo_$cshow_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3YI:
          if ((Sp + -16) < SpLim) goto c3YJ; else goto c3YK;
      c3YJ:
          R1 = $fShowFoo_$cshow_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c3YK:
          _s3Em::P64 = P64[Sp];
          I64[Sp] = block_c3YF_info;
          R1 = _s3Em::P64;
          if (R1 & 7 != 0) goto u3YO; else goto c3YG;
      u3YO:
          call block_c3YF_entry(R1) args: 0, res: 0, upd: 0;
      c3YG:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:40.513789 UTC

block_c3YF_entry() //  [R1]
        { info_tbl: [(c3YF,
                      label: block_c3YF_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3YF:
          I64[Sp - 16] = 0;
          P64[Sp - 8] = P64[R1 + 7];
          P64[Sp] = []_closure+1;
          Sp = Sp - 16;
          call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.515548 UTC

$fShowFoo_$cshow_entry() //  []
        { info_tbl: [(c3YI,
                      label: $fShowFoo_$cshow_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3YI:
          if ((Sp + -16) < SpLim) goto c3YJ; else goto c3YK;
      c3YJ:
          R1 = $fShowFoo_$cshow_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c3YK:
          _s3Em::P64 = P64[Sp];
          I64[Sp] = block_c3YF_info;
          R1 = _s3Em::P64;
          if (R1 & 7 != 0) goto u3YO; else goto c3YG;
      u3YO:
          call block_c3YF_entry(R1) args: 0, res: 0, upd: 0;
      c3YG:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.519117 UTC

block_c3YF_entry() //  [R1]
        { info_tbl: [(c3YF,
                      label: block_c3YF_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c3YF:
          I64[Sp - 16] = 0;
          P64[Sp - 8] = P64[R1 + 7];
          P64[Sp] = []_closure+1;
          Sp = Sp - 16;
          call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:18:40.52089 UTC

[section "data" {
     $fShowFoo_$cshow_closure:
         const $fShowFoo_$cshow_info;
         const 0;
 },
 $fShowFoo_$cshow_entry() //  []
         { info_tbl: [(c3YI,
                       label: $fShowFoo_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3YI:
           if ((Sp + -16) < SpLim) goto c3YJ; else goto c3YK;
       c3YJ:
           R1 = $fShowFoo_$cshow_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c3YK:
           _s3Em::P64 = P64[Sp];
           I64[Sp] = block_c3YF_info;
           R1 = _s3Em::P64;
           if (R1 & 7 != 0) goto u3YO; else goto c3YG;
       u3YO:
           call block_c3YF_entry(R1) args: 0, res: 0, upd: 0;
       c3YG:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3YF_entry() //  [R1]
         { info_tbl: [(c3YF,
                       label: block_c3YF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3YF:
           I64[Sp - 16] = 0;
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp] = []_closure+1;
           Sp = Sp - 16;
           call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:18:40.525259 UTC

[section "data" {
     $fShowFoo_$cshow_closure:
         const $fShowFoo_$cshow_info;
         const 0;
 },
 $fShowFoo_$cshow_entry() //  []
         { info_tbl: [(c3YI,
                       label: $fShowFoo_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3YI:
           if ((Sp + -16) < SpLim) goto c3YJ; else goto c3YK;
       c3YJ:
           R1 = $fShowFoo_$cshow_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c3YK:
           _s3Em::P64 = P64[Sp];
           I64[Sp] = block_c3YF_info;
           R1 = _s3Em::P64;
           if (R1 & 7 != 0) goto u3YO; else goto c3YG;
       u3YO:
           call block_c3YF_entry(R1) args: 0, res: 0, upd: 0;
       c3YG:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c3YF_entry() //  [R1]
         { info_tbl: [(c3YF,
                       label: block_c3YF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c3YF:
           I64[Sp - 16] = 0;
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp] = []_closure+1;
           Sp = Sp - 16;
           call $w$cshowsPrec_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:18:40.556128 UTC

[section "data" {
     $fShowFoo_closure:
         const D:Show_static_info;
         const $fShowFoo_$cshowsPrec_closure+3;
         const $fShowFoo_$cshow_closure+1;
         const $fShowFoo_$cshowList_closure+2;
         const 0;
 }]


==================== Post CPS Cmm ====================
2016-08-04 14:18:40.557307 UTC

[section "data" {
     $fShowFoo_closure:
         const D:Show_static_info;
         const $fShowFoo_$cshowsPrec_closure+3;
         const $fShowFoo_$cshow_closure+1;
         const $fShowFoo_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2016-08-04 14:18:40.558353 UTC

[section "data" {
     $fShowFoo_closure:
         const D:Show_static_info;
         const $fShowFoo_$cshowsPrec_closure+3;
         const $fShowFoo_$cshow_closure+1;
         const $fShowFoo_$cshowList_closure+2;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:18:40.561881 UTC

[section "data" {
     mkfoo_rn1_closure:
         const mkfoo_rn1_info;
 },
 mkfoo_rn1_entry() //  []
         { info_tbl: [(c40i,
                       label: mkfoo_rn1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 16 updfr_space: Just 8
         }
     {offset
       c40i:
           _B1::P64 = P64[(old + 16)];
           goto c40f;
       c40f:
           if ((old + 0) - <highSp> < SpLim) goto c40j; else goto c40k;
       c40k:
           goto c40e;
       c40e:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c40m; else goto c40l;
       c40m:
           HpAlloc = 16;
           goto c40j;
       c40j:
           R1 = mkfoo_rn1_closure;
           P64[(old + 16)] = _B1::P64;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c40l:
           I64[Hp - 8] = Foo_con_info;
           P64[Hp] = _B1::P64;
           _c40h::P64 = Hp - 7;
           R1 = _c40h::P64;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.566265 UTC

{offset
  c40i:
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c40j; else goto c40k;
  c40k:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c40m; else goto c40l;
  c40m:
      HpAlloc = 16;
      goto c40j;
  c40j:
      R1 = mkfoo_rn1_closure;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c40l:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c40h::P64 = Hp - 7;
      R1 = _c40h::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:18:40.56899 UTC

{offset
  c40i:
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c40j; else goto c40k;
  c40k:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c40m; else goto c40l;
  c40m:
      HpAlloc = 16;
      goto c40j;
  c40j:
      R1 = mkfoo_rn1_closure;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c40l:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c40h::P64 = Hp - 7;
      R1 = _c40h::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:18:40.572341 UTC

mkfoo_rn1_entry
[c40i]
{offset
  c40i:
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c40j; else goto c40k;
  c40k:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c40m; else goto c40l;
  c40m:
      HpAlloc = 16;
      goto c40j;
  c40j:
      R1 = mkfoo_rn1_closure;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c40l:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c40h::P64 = Hp - 7;
      R1 = _c40h::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:18:40.575422 UTC

{offset
  c40i:
      _B1::P64 = P64[Sp];
      goto c40k;
  c40k:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c40m; else goto c40l;
  c40m:
      HpAlloc = 16;
      goto c40j;
  c40j:
      R1 = mkfoo_rn1_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c40l:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c40h::P64 = Hp - 7;
      R1 = _c40h::P64;
      Sp = Sp + 8;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:18:40.578175 UTC

{offset
  c40i:
      goto c40k;
  c40k:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c40m; else goto c40l;
  c40m:
      HpAlloc = 16;
      goto c40j;
  c40j:
      R1 = mkfoo_rn1_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c40l:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = P64[Sp];
      R1 = Hp - 7;
      Sp = Sp + 8;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:18:40.580133 UTC

[(c40i, {}), (c40j, {}), (c40k, {}), (c40l, {}), (c40m, {})]


==================== procpoint map ====================
2016-08-04 14:18:40.581117 UTC

[(c40i, <procpt>), (c40j, reached by c40i),
 (c40k, reached by c40i), (c40l, reached by c40i),
 (c40m, reached by c40i)]


==================== Post splitting ====================
2016-08-04 14:18:40.582212 UTC

mkfoo_rn1_entry() //  []
        { info_tbl: [(c40i,
                      label: mkfoo_rn1_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c40i:
          goto c40k;
      c40k:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c40m; else goto c40l;
      c40m:
          HpAlloc = 16;
          goto c40j;
      c40j:
          R1 = mkfoo_rn1_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c40l:
          I64[Hp - 8] = Foo_con_info;
          P64[Hp] = P64[Sp];
          R1 = Hp - 7;
          Sp = Sp + 8;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:40.584995 UTC

mkfoo_rn1_entry() //  []
        { info_tbl: [(c40i,
                      label: mkfoo_rn1_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c40i:
          goto c40k;
      c40k:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c40m; else goto c40l;
      c40m:
          HpAlloc = 16;
          goto c40j;
      c40j:
          R1 = mkfoo_rn1_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c40l:
          I64[Hp - 8] = Foo_con_info;
          P64[Hp] = P64[Sp];
          R1 = Hp - 7;
          Sp = Sp + 8;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.587562 UTC

mkfoo_rn1_entry() //  []
        { info_tbl: [(c40i,
                      label: mkfoo_rn1_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c40i:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c40m; else goto c40l;
      c40m:
          HpAlloc = 16;
          R1 = mkfoo_rn1_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c40l:
          I64[Hp - 8] = Foo_con_info;
          P64[Hp] = P64[Sp];
          R1 = Hp - 7;
          Sp = Sp + 8;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:18:40.590045 UTC

[section "data" {
     mkfoo_rn1_closure:
         const mkfoo_rn1_info;
 },
 mkfoo_rn1_entry() //  []
         { info_tbl: [(c40i,
                       label: mkfoo_rn1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c40i:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c40m; else goto c40l;
       c40m:
           HpAlloc = 16;
           R1 = mkfoo_rn1_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c40l:
           I64[Hp - 8] = Foo_con_info;
           P64[Hp] = P64[Sp];
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:18:40.592785 UTC

[section "data" {
     mkfoo_rn1_closure:
         const mkfoo_rn1_info;
 },
 mkfoo_rn1_entry() //  []
         { info_tbl: [(c40i,
                       label: mkfoo_rn1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c40i:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c40m; else goto c40l;
       c40m:
           HpAlloc = 16;
           R1 = mkfoo_rn1_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c40l:
           I64[Hp - 8] = Foo_con_info;
           P64[Hp] = P64[Sp];
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:18:40.614569 UTC

[section "data" {
     a_r3Dy_closure:
         const a_r3Dy_info;
 },
 a_r3Dy_entry() //  []
         { info_tbl: [(c41D,
                       label: a_r3Dy_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 24 updfr_space: Just 8
         }
     {offset
       c41D:
           _s3Ep::P64 = P64[(old + 24)];
           _s3Eq::P64 = P64[(old + 16)];
           goto c41z;
       c41z:
           if ((old + 0) - <highSp> < SpLim) goto c41H; else goto c41I;
       c41H:
           R1 = a_r3Dy_closure;
           P64[(old + 24)] = _s3Ep::P64;
           P64[(old + 16)] = _s3Eq::P64;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
       c41I:
           goto c41y;
       c41y:
           I64[(young<c41B> + 8)] = c41B;
           P64[(young<c41B> + 16)] = _s3Eq::P64;
           call mkfoo_rn1_entry() returns to c41B, args: 16, res: 8, upd: 8;
       c41B:
           _s3Es::P64 = R1;
           _s3Et::P64 = P64[_s3Es::P64 + 7];
           I64[(young<c41G> + 8)] = c41G;
           R1 = _s3Ep::P64;
           if (R1 & 7 != 0) goto c41G; else goto c41K;
       c41K:
           call (I64[I64[R1]])(R1) returns to c41G, args: 8, res: 8, upd: 8;
       c41G:
           _s3Eu::P64 = R1;
           _s3Ev::P64 = P64[_s3Eu::P64 + 7];
           P64[_s3Ev::P64 + 8] = _s3Es::P64;
           _c41P::I64 = dirty_MUT_VAR;
           _c41Q::I64 = BaseReg;
           _c41R::P64 = _s3Ev::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] (_c41P::I64)(_c41Q::I64, _c41R::P64);
           R1 = ()_closure+1;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.621777 UTC

{offset
  c41D:
      _s3Ep::P64 = P64[(old + 24)];
      _s3Eq::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c41H; else goto c41I;
  c41H:
      R1 = a_r3Dy_closure;
      P64[(old + 24)] = _s3Ep::P64;
      P64[(old + 16)] = _s3Eq::P64;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c41I:
      I64[(young<c41B> + 8)] = c41B;
      P64[(young<c41B> + 16)] = _s3Eq::P64;
      call mkfoo_rn1_entry() returns to c41B, args: 16, res: 8, upd: 8;
  c41B:
      _s3Es::P64 = R1;
      _s3Et::P64 = P64[_s3Es::P64 + 7];
      I64[(young<c41G> + 8)] = c41G;
      R1 = _s3Ep::P64;
      if (R1 & 7 != 0) goto c41G; else goto c41K;
  c41K:
      call (I64[I64[R1]])(R1) returns to c41G, args: 8, res: 8, upd: 8;
  c41G:
      _s3Eu::P64 = R1;
      _s3Ev::P64 = P64[_s3Eu::P64 + 7];
      P64[_s3Ev::P64 + 8] = _s3Es::P64;
      _c41P::I64 = dirty_MUT_VAR;
      _c41Q::I64 = BaseReg;
      _c41R::P64 = _s3Ev::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_c41P::I64)(_c41Q::I64, _c41R::P64);
      R1 = ()_closure+1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:18:40.627507 UTC

{offset
  c41D:
      _s3Ep::P64 = P64[(old + 24)];
      _s3Eq::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c41H; else goto c41I;
  c41H:
      R1 = a_r3Dy_closure;
      P64[(old + 24)] = _s3Ep::P64;
      P64[(old + 16)] = _s3Eq::P64;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c41I:
      I64[(young<c41B> + 8)] = c41B;
      P64[(young<c41B> + 16)] = _s3Eq::P64;
      call mkfoo_rn1_entry() returns to c41B, args: 16, res: 8, upd: 8;
  c41B:
      _s3Es::P64 = R1;
      _s3Et::P64 = P64[_s3Es::P64 + 7];
      I64[(young<c41G> + 8)] = c41G;
      R1 = _s3Ep::P64;
      if (R1 & 7 != 0) goto c41G; else goto c41K;
  c41K:
      call (I64[I64[R1]])(R1) returns to c41G, args: 8, res: 8, upd: 8;
  c41G:
      _s3Eu::P64 = R1;
      _s3Ev::P64 = P64[_s3Eu::P64 + 7];
      P64[_s3Ev::P64 + 8] = _s3Es::P64;
      _c41P::I64 = dirty_MUT_VAR;
      _c41Q::I64 = BaseReg;
      _c41R::P64 = _s3Ev::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_c41P::I64)(_c41Q::I64, _c41R::P64);
      R1 = ()_closure+1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:18:40.631975 UTC

a_r3Dy_entry
[c41B, c41D, c41G]
{offset
  c41D:
      _s3Ep::P64 = P64[(old + 24)];
      _s3Eq::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c41H; else goto c41I;
  c41H:
      R1 = a_r3Dy_closure;
      P64[(old + 24)] = _s3Ep::P64;
      P64[(old + 16)] = _s3Eq::P64;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c41I:
      I64[(young<c41B> + 8)] = c41B;
      P64[(young<c41B> + 16)] = _s3Eq::P64;
      call mkfoo_rn1_entry() returns to c41B, args: 16, res: 8, upd: 8;
  c41B:
      _s3Es::P64 = R1;
      _s3Et::P64 = P64[_s3Es::P64 + 7];
      I64[(young<c41G> + 8)] = c41G;
      R1 = _s3Ep::P64;
      if (R1 & 7 != 0) goto c41G; else goto c41K;
  c41K:
      call (I64[I64[R1]])(R1) returns to c41G, args: 8, res: 8, upd: 8;
  c41G:
      _s3Eu::P64 = R1;
      _s3Ev::P64 = P64[_s3Eu::P64 + 7];
      P64[_s3Ev::P64 + 8] = _s3Es::P64;
      _c41P::I64 = dirty_MUT_VAR;
      _c41Q::I64 = BaseReg;
      _c41R::P64 = _s3Ev::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_c41P::I64)(_c41Q::I64, _c41R::P64);
      R1 = ()_closure+1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:18:40.637566 UTC

{offset
  c41D:
      _s3Ep::P64 = P64[Sp];
      _s3Eq::P64 = P64[Sp + 8];
      if ((Sp + 24) - 40 < SpLim) goto c41H; else goto c41I;
  c41H:
      R1 = a_r3Dy_closure;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c41I:
      I64[Sp - 8] = c41B;
      P64[Sp - 16] = _s3Eq::P64;
      Sp = Sp - 16;
      call mkfoo_rn1_entry() returns to c41B, args: 16, res: 8, upd: 8;
  c41B:
      _s3Ep::P64 = P64[Sp + 8];
      _s3Es::P64 = R1;
      _s3Et::P64 = P64[_s3Es::P64 + 7];
      I64[Sp + 8] = c41G;
      R1 = _s3Ep::P64;
      P64[Sp + 16] = _s3Es::P64;
      Sp = Sp + 8;
      if (R1 & 7 != 0) goto c41G; else goto c41K;
  c41K:
      call (I64[I64[R1]])(R1) returns to c41G, args: 8, res: 8, upd: 8;
  c41G:
      _s3Es::P64 = P64[Sp + 8];
      _s3Eu::P64 = R1;
      _s3Ev::P64 = P64[_s3Eu::P64 + 7];
      P64[_s3Ev::P64 + 8] = _s3Es::P64;
      _c41P::I64 = dirty_MUT_VAR;
      _c41Q::I64 = BaseReg;
      _c41R::P64 = _s3Ev::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_c41P::I64)(_c41Q::I64, _c41R::P64);
      R1 = ()_closure+1;
      Sp = Sp + 16;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:18:40.643103 UTC

{offset
  c41D:
      if ((Sp + -16) < SpLim) goto c41H; else goto c41I;
  c41H:
      R1 = a_r3Dy_closure;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c41I:
      I64[Sp - 8] = c41B;
      P64[Sp - 16] = P64[Sp + 8];
      Sp = Sp - 16;
      call mkfoo_rn1_entry() returns to c41B, args: 16, res: 8, upd: 8;
  c41B:
      _s3Ep::P64 = P64[Sp + 8];
      I64[Sp + 8] = c41G;
      _s3Es::P64 = R1;
      R1 = _s3Ep::P64;
      P64[Sp + 16] = _s3Es::P64;
      Sp = Sp + 8;
      if (R1 & 7 != 0) goto c41G; else goto c41K;
  c41K:
      call (I64[I64[R1]])(R1) returns to c41G, args: 8, res: 8, upd: 8;
  c41G:
      _s3Ev::P64 = P64[R1 + 7];
      P64[_s3Ev::P64 + 8] = P64[Sp + 8];
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s3Ev::P64);
      R1 = ()_closure+1;
      Sp = Sp + 16;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:18:40.646882 UTC

[(c41B, {}), (c41D, {}), (c41G, {}), (c41H, {}), (c41I, {}),
 (c41K, {})]


==================== procpoint map ====================
2016-08-04 14:18:40.647952 UTC

[(c41B, <procpt>), (c41D, <procpt>), (c41G, <procpt>),
 (c41H, reached by c41D), (c41I, reached by c41D),
 (c41K, reached by c41B)]


==================== Post splitting ====================
2016-08-04 14:18:40.649117 UTC

a_r3Dy_entry() //  [R1]
        { info_tbl: [(c41D,
                      label: a_r3Dy_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c41D:
          if ((Sp + -16) < SpLim) goto c41H; else goto c41I;
      c41H:
          R1 = a_r3Dy_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
      c41I:
          I64[Sp - 8] = block_c41B_info;
          P64[Sp - 16] = P64[Sp + 8];
          Sp = Sp - 16;
          call mkfoo_rn1_entry() args: 16, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-04 14:18:40.65168 UTC

block_c41B_entry() //  [R1]
        { info_tbl: [(c41B,
                      label: block_c41B_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c41B:
          _s3Ep::P64 = P64[Sp + 8];
          I64[Sp + 8] = block_c41G_info;
          _s3Es::P64 = R1;
          R1 = _s3Ep::P64;
          P64[Sp + 16] = _s3Es::P64;
          Sp = Sp + 8;
          if (R1 & 7 != 0) goto u41S; else goto c41K;
      u41S:
          call block_c41G_entry(R1) args: 0, res: 0, upd: 0;
      c41K:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-04 14:18:40.654143 UTC

block_c41G_entry() //  [R1]
        { info_tbl: [(c41G,
                      label: block_c41G_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c41G:
          _s3Ev::P64 = P64[R1 + 7];
          P64[_s3Ev::P64 + 8] = P64[Sp + 8];
          call "ccall" arg hints:  [PtrHint,
                                    PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s3Ev::P64);
          R1 = ()_closure+1;
          Sp = Sp + 16;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:40.656287 UTC

a_r3Dy_entry() //  [R1]
        { info_tbl: [(c41D,
                      label: a_r3Dy_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c41D:
          if ((Sp + -16) < SpLim) goto c41H; else goto c41I;
      c41H:
          R1 = a_r3Dy_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
      c41I:
          I64[Sp - 8] = block_c41B_info;
          P64[Sp - 16] = P64[Sp + 8];
          Sp = Sp - 16;
          call mkfoo_rn1_entry() args: 16, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:40.658516 UTC

block_c41B_entry() //  [R1]
        { info_tbl: [(c41B,
                      label: block_c41B_info
                      rep:StackRep [False, True])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c41B:
          _s3Ep::P64 = P64[Sp + 8];
          I64[Sp + 8] = block_c41G_info;
          _s3Es::P64 = R1;
          R1 = _s3Ep::P64;
          P64[Sp + 16] = _s3Es::P64;
          Sp = Sp + 8;
          if (R1 & 7 != 0) goto u41S; else goto c41K;
      u41S:
          call block_c41G_entry(R1) args: 0, res: 0, upd: 0;
      c41K:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:40.660966 UTC

block_c41G_entry() //  [R1]
        { info_tbl: [(c41G,
                      label: block_c41G_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c41G:
          _s3Ev::P64 = P64[R1 + 7];
          P64[_s3Ev::P64 + 8] = P64[Sp + 8];
          call "ccall" arg hints:  [PtrHint,
                                    PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s3Ev::P64);
          R1 = ()_closure+1;
          Sp = Sp + 16;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.66309 UTC

a_r3Dy_entry() //  [R1]
        { info_tbl: [(c41D,
                      label: a_r3Dy_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c41D:
          if ((Sp + -16) < SpLim) goto c41H; else goto c41I;
      c41H:
          R1 = a_r3Dy_closure;
          call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
      c41I:
          I64[Sp - 8] = block_c41B_info;
          P64[Sp - 16] = P64[Sp + 8];
          Sp = Sp - 16;
          call mkfoo_rn1_entry() args: 16, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.665433 UTC

block_c41B_entry() //  [R1]
        { info_tbl: [(c41B,
                      label: block_c41B_info
                      rep:StackRep [False, True])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c41B:
          _s3Ep::P64 = P64[Sp + 8];
          I64[Sp + 8] = block_c41G_info;
          _s3Es::P64 = R1;
          R1 = _s3Ep::P64;
          P64[Sp + 16] = _s3Es::P64;
          Sp = Sp + 8;
          if (R1 & 7 != 0) goto u41S; else goto c41K;
      u41S:
          call block_c41G_entry(R1) args: 0, res: 0, upd: 0;
      c41K:
          call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.667957 UTC

block_c41G_entry() //  [R1]
        { info_tbl: [(c41G,
                      label: block_c41G_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c41G:
          _s3Ev::P64 = P64[R1 + 7];
          P64[_s3Ev::P64 + 8] = P64[Sp + 8];
          call "ccall" arg hints:  [PtrHint,
                                    PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s3Ev::P64);
          R1 = ()_closure+1;
          Sp = Sp + 16;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:18:40.670096 UTC

[section "data" {
     a_r3Dy_closure:
         const a_r3Dy_info;
 },
 a_r3Dy_entry() //  [R1]
         { info_tbl: [(c41D,
                       label: a_r3Dy_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c41D:
           if ((Sp + -16) < SpLim) goto c41H; else goto c41I;
       c41H:
           R1 = a_r3Dy_closure;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
       c41I:
           I64[Sp - 8] = block_c41B_info;
           P64[Sp - 16] = P64[Sp + 8];
           Sp = Sp - 16;
           call mkfoo_rn1_entry() args: 16, res: 8, upd: 8;
     }
 },
 block_c41B_entry() //  [R1]
         { info_tbl: [(c41B,
                       label: block_c41B_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c41B:
           _s3Ep::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c41G_info;
           _s3Es::P64 = R1;
           R1 = _s3Ep::P64;
           P64[Sp + 16] = _s3Es::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u41S; else goto c41K;
       u41S:
           call block_c41G_entry(R1) args: 0, res: 0, upd: 0;
       c41K:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c41G_entry() //  [R1]
         { info_tbl: [(c41G,
                       label: block_c41G_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c41G:
           _s3Ev::P64 = P64[R1 + 7];
           P64[_s3Ev::P64 + 8] = P64[Sp + 8];
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s3Ev::P64);
           R1 = ()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:18:40.676408 UTC

[section "data" {
     a_r3Dy_closure:
         const a_r3Dy_info;
 },
 a_r3Dy_entry() //  [R1]
         { info_tbl: [(c41D,
                       label: a_r3Dy_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c41D:
           if ((Sp + -16) < SpLim) goto c41H; else goto c41I;
       c41H:
           R1 = a_r3Dy_closure;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
       c41I:
           I64[Sp - 8] = block_c41B_info;
           P64[Sp - 16] = P64[Sp + 8];
           Sp = Sp - 16;
           call mkfoo_rn1_entry() args: 16, res: 8, upd: 8;
     }
 },
 block_c41B_entry() //  [R1]
         { info_tbl: [(c41B,
                       label: block_c41B_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c41B:
           _s3Ep::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c41G_info;
           _s3Es::P64 = R1;
           R1 = _s3Ep::P64;
           P64[Sp + 16] = _s3Es::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u41S; else goto c41K;
       u41S:
           call block_c41G_entry(R1) args: 0, res: 0, upd: 0;
       c41K:
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c41G_entry() //  [R1]
         { info_tbl: [(c41G,
                       label: block_c41G_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c41G:
           _s3Ev::P64 = P64[R1 + 7];
           P64[_s3Ev::P64 + 8] = P64[Sp + 8];
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s3Ev::P64);
           R1 = ()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:18:40.724596 UTC

[section "data" {
     dowrite_closure:
         const dowrite_info;
 },
 dowrite_entry() //  []
         { info_tbl: [(c44j,
                       label: dowrite_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 24 updfr_space: Just 8
         }
     {offset
       c44j:
           _B3::P64 = P64[(old + 24)];
           _B2::P64 = P64[(old + 16)];
           goto c44h;
       c44h:
           if ((old + 0) - <highSp> < SpLim) goto c44k; else goto c44l;
       c44k:
           R1 = dowrite_closure;
           P64[(old + 24)] = _B3::P64;
           P64[(old + 16)] = _B2::P64;
           call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
       c44l:
           goto c44g;
       c44g:
           P64[(old + 24)] = _B3::P64;
           P64[(old + 16)] = _B2::P64;
           call a_r3Dy_entry() args: 24, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.728442 UTC

{offset
  c44j:
      _B3::P64 = P64[(old + 24)];
      _B2::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c44k; else goto c44l;
  c44k:
      R1 = dowrite_closure;
      P64[(old + 24)] = _B3::P64;
      P64[(old + 16)] = _B2::P64;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c44l:
      P64[(old + 24)] = _B3::P64;
      P64[(old + 16)] = _B2::P64;
      call a_r3Dy_entry() args: 24, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:18:40.731602 UTC

{offset
  c44j:
      _B3::P64 = P64[(old + 24)];
      _B2::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c44k; else goto c44l;
  c44k:
      R1 = dowrite_closure;
      P64[(old + 24)] = _B3::P64;
      P64[(old + 16)] = _B2::P64;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c44l:
      P64[(old + 24)] = _B3::P64;
      P64[(old + 16)] = _B2::P64;
      call a_r3Dy_entry() args: 24, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:18:40.733738 UTC

dowrite_entry
[c44j]
{offset
  c44j:
      _B3::P64 = P64[(old + 24)];
      _B2::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c44k; else goto c44l;
  c44k:
      R1 = dowrite_closure;
      P64[(old + 24)] = _B3::P64;
      P64[(old + 16)] = _B2::P64;
      call (stg_gc_fun)(R1) args: 24, res: 0, upd: 8;
  c44l:
      P64[(old + 24)] = _B3::P64;
      P64[(old + 16)] = _B2::P64;
      call a_r3Dy_entry() args: 24, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:18:40.736407 UTC

{offset
  c44j:
      _B3::P64 = P64[Sp];
      _B2::P64 = P64[Sp + 8];
      goto c44l;
  c44l:
      call a_r3Dy_entry() args: 24, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:18:40.737683 UTC

{offset
  c44j:
      goto c44l;
  c44l:
      call a_r3Dy_entry() args: 24, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:18:40.738553 UTC

[(c44j, {}), (c44l, {})]


==================== procpoint map ====================
2016-08-04 14:18:40.739302 UTC

[(c44j, <procpt>), (c44l, reached by c44j)]


==================== Post splitting ====================
2016-08-04 14:18:40.740092 UTC

dowrite_entry() //  []
        { info_tbl: [(c44j,
                      label: dowrite_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44j:
          goto c44l;
      c44l:
          call a_r3Dy_entry() args: 24, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:40.741594 UTC

dowrite_entry() //  []
        { info_tbl: [(c44j,
                      label: dowrite_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44j:
          goto c44l;
      c44l:
          call a_r3Dy_entry() args: 24, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.742984 UTC

dowrite_entry() //  []
        { info_tbl: [(c44j,
                      label: dowrite_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44j:
          call a_r3Dy_entry() args: 24, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:18:40.744347 UTC

[section "data" {
     dowrite_closure:
         const dowrite_info;
 },
 dowrite_entry() //  []
         { info_tbl: [(c44j,
                       label: dowrite_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44j:
           call a_r3Dy_entry() args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:18:40.745944 UTC

[section "data" {
     dowrite_closure:
         const dowrite_info;
 },
 dowrite_entry() //  []
         { info_tbl: [(c44j,
                       label: dowrite_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44j:
           call a_r3Dy_entry() args: 24, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:18:40.752553 UTC

[section "data" {
     main2_closure:
         const I#_static_info;
         const 4;
 }]


==================== Post CPS Cmm ====================
2016-08-04 14:18:40.753433 UTC

[section "data" {
     main2_closure:
         const I#_static_info;
         const 4;
 }]


==================== Output Cmm ====================
2016-08-04 14:18:40.754264 UTC

[section "data" {
     main2_closure:
         const I#_static_info;
         const 4;
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:18:40.756678 UTC

[section "data" {
     main4_closure:
         const I#_static_info;
         const 3;
 }]


==================== Post CPS Cmm ====================
2016-08-04 14:18:40.757566 UTC

[section "data" {
     main4_closure:
         const I#_static_info;
         const 3;
 }]


==================== Output Cmm ====================
2016-08-04 14:18:40.758406 UTC

[section "data" {
     main4_closure:
         const I#_static_info;
         const 3;
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:18:40.761563 UTC

[section "data" {
     main3_closure:
         const Foo_static_info;
         const main4_closure+1;
         const 1;
 }]


==================== Post CPS Cmm ====================
2016-08-04 14:18:40.762508 UTC

[section "data" {
     main3_closure:
         const Foo_static_info;
         const main4_closure+1;
         const 1;
 }]


==================== Output Cmm ====================
2016-08-04 14:18:40.763401 UTC

[section "data" {
     main3_closure:
         const Foo_static_info;
         const main4_closure+1;
         const 1;
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:18:40.766125 UTC

[section "data" {
     main1_closure:
         const main1_info;
         const 0;
 },
 sat_s3ED_entry() //  [R1]
         { info_tbl: [(c44E,
                       label: sat_s3ED_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c44E:
           _s3ED::P64 = R1;
           goto c44C;
       c44C:
           if ((old + 0) - <highSp> < SpLim) goto c44F; else goto c44G;
       c44F:
           R1 = _s3ED::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c44G:
           goto c44B;
       c44B:
           _s3EC::P64 = P64[_s3ED::P64 + 7];
           P64[(old + 24)] = _s3EC::P64;
           P64[(old + 16)] = main2_closure+1;
           call dowrite_entry() args: 24, res: 0, upd: 8;
     }
 },
 sat_s3EE_entry() //  [R1]
         { info_tbl: [(c44H,
                       label: sat_s3EE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c44H:
           _s3EE::P64 = R1;
           goto c44w;
       c44w:
           if ((old + 0) - <highSp> < SpLim) goto c44I; else goto c44J;
       c44J:
           goto c44v;
       c44v:
           Hp = Hp + 32;
           if (Hp > HpLim) goto c44L; else goto c44K;
       c44L:
           HpAlloc = 32;
           goto c44I;
       c44I:
           R1 = _s3EE::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c44K:
           _s3EA::P64 = P64[_s3EE::P64 + 7];
           I64[Hp - 24] = STRef_con_info;
           P64[Hp - 16] = _s3EA::P64;
           _c44y::P64 = Hp - 23;
           I64[Hp - 8] = sat_s3ED_info;
           P64[Hp] = _c44y::P64;
           _c44z::P64 = Hp - 7;
           R1 = _c44z::P64;
           P64[(old + 16)] = childHandler1_closure+2;
           call stg_catch#(R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_s3EL_entry() //  [R1]
         { info_tbl: [(c44S,
                       label: sat_s3EL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c44S:
           _s3EL::P64 = R1;
           goto c44Q;
       c44Q:
           if ((old + 0) - <highSp> < SpLim) goto c44T; else goto c44U;
       c44T:
           R1 = _s3EL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44U:
           _s3EK::P64 = P64[_s3EL::P64 + 16];
           P64[(old + 16)] = _s3EK::P64;
           call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
     }
 },
 main1_entry() //  []
         { info_tbl: [(c44V,
                       label: main1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c44V:
           goto c44p;
       c44p:
           if ((old + 0) - <highSp> < SpLim) goto c44W; else goto c44X;
       c44W:
           R1 = main1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c44X:
           goto c44o;
       c44o:
           I64[(young<c44r> + 8)] = c44r;
           R1 = main3_closure+1;
           call stg_newMutVar#(R1) returns to c44r, args: 8, res: 8, upd: 8;
       c44r:
           _s3EA::P64 = R1;
           Hp = Hp + 16;
           if (Hp > HpLim) goto c450; else goto c44Z;
       c450:
           HpAlloc = 16;
           goto c44Y;
       c44Y:
           R1 = _s3EA::P64;
           call stg_gc_unpt_r1(R1) returns to c44r, args: 8, res: 8, upd: 8;
       c44Z:
           I64[Hp - 8] = sat_s3EE_info;
           P64[Hp] = _s3EA::P64;
           _c44t::P64 = Hp - 7;
           I64[(young<c44M> + 8)] = c44M;
           R1 = _c44t::P64;
           call stg_fork#(R1) returns to c44M, args: 8, res: 8, upd: 8;
       c44M:
           _s3EH::P64 = R1;
           Hp = Hp + 24;
           if (Hp > HpLim) goto c453; else goto c452;
       c453:
           HpAlloc = 24;
           goto c451;
       c451:
           R1 = _s3EH::P64;
           call stg_gc_unpt_r1(R1) returns to c44M, args: 8, res: 8, upd: 8;
       c452:
           _s3EK::P64 = P64[_s3EA::P64 + 8];
           _s3EK::P64 = _s3EK::P64;
           I64[Hp - 16] = sat_s3EL_info;
           P64[Hp] = _s3EK::P64;
           _c44O::P64 = Hp - 16;
           P64[(old + 32)] = stdout_closure;
           P64[(old + 24)] = _c44O::P64;
           P64[(old + 16)] = True_closure+2;
           call hPutStr2_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.781567 UTC

{offset
  c44E:
      _s3ED::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c44F; else goto c44G;
  c44F:
      R1 = _s3ED::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c44G:
      _s3EC::P64 = P64[_s3ED::P64 + 7];
      P64[(old + 24)] = _s3EC::P64;
      P64[(old + 16)] = main2_closure+1;
      call dowrite_entry() args: 24, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:18:40.783602 UTC

{offset
  c44E:
      _s3ED::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c44F; else goto c44G;
  c44F:
      R1 = _s3ED::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c44G:
      _s3EC::P64 = P64[_s3ED::P64 + 7];
      P64[(old + 24)] = _s3EC::P64;
      P64[(old + 16)] = main2_closure+1;
      call dowrite_entry() args: 24, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:18:40.785412 UTC

sat_s3ED_entry
[c44E]
{offset
  c44E:
      _s3ED::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c44F; else goto c44G;
  c44F:
      R1 = _s3ED::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c44G:
      _s3EC::P64 = P64[_s3ED::P64 + 7];
      P64[(old + 24)] = _s3EC::P64;
      P64[(old + 16)] = main2_closure+1;
      call dowrite_entry() args: 24, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:18:40.787722 UTC

{offset
  c44E:
      _s3ED::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto c44F; else goto c44G;
  c44F:
      R1 = _s3ED::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c44G:
      _s3EC::P64 = P64[_s3ED::P64 + 7];
      P64[Sp - 16] = _s3EC::P64;
      P64[Sp - 8] = main2_closure+1;
      Sp = Sp - 16;
      call dowrite_entry() args: 24, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:18:40.789979 UTC

{offset
  c44E:
      if ((Sp + -16) < SpLim) goto c44F; else goto c44G;
  c44F:
      R1 = R1;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c44G:
      P64[Sp - 16] = P64[R1 + 7];
      P64[Sp - 8] = main2_closure+1;
      Sp = Sp - 16;
      call dowrite_entry() args: 24, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:18:40.791648 UTC

[(c44E, {}), (c44F, {}), (c44G, {})]


==================== procpoint map ====================
2016-08-04 14:18:40.792513 UTC

[(c44E, <procpt>), (c44F, reached by c44E),
 (c44G, reached by c44E)]


==================== Post splitting ====================
2016-08-04 14:18:40.793401 UTC

sat_s3ED_entry() //  [R1]
        { info_tbl: [(c44E,
                      label: sat_s3ED_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44E:
          if ((Sp + -16) < SpLim) goto c44F; else goto c44G;
      c44F:
          R1 = R1;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c44G:
          P64[Sp - 16] = P64[R1 + 7];
          P64[Sp - 8] = main2_closure+1;
          Sp = Sp - 16;
          call dowrite_entry() args: 24, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:40.795815 UTC

sat_s3ED_entry() //  [R1]
        { info_tbl: [(c44E,
                      label: sat_s3ED_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44E:
          if ((Sp + -16) < SpLim) goto c44F; else goto c44G;
      c44F:
          R1 = R1;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c44G:
          P64[Sp - 16] = P64[R1 + 7];
          P64[Sp - 8] = main2_closure+1;
          Sp = Sp - 16;
          call dowrite_entry() args: 24, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.798105 UTC

sat_s3ED_entry() //  [R1]
        { info_tbl: [(c44E,
                      label: sat_s3ED_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44E:
          if ((Sp + -16) < SpLim) goto c44F; else goto c44G;
      c44F:
          R1 = R1;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c44G:
          P64[Sp - 16] = P64[R1 + 7];
          P64[Sp - 8] = main2_closure+1;
          Sp = Sp - 16;
          call dowrite_entry() args: 24, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.800696 UTC

{offset
  c44H:
      _s3EE::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c44I; else goto c44J;
  c44J:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c44L; else goto c44K;
  c44L:
      HpAlloc = 32;
      goto c44I;
  c44I:
      R1 = _s3EE::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c44K:
      _s3EA::P64 = P64[_s3EE::P64 + 7];
      I64[Hp - 24] = STRef_con_info;
      P64[Hp - 16] = _s3EA::P64;
      _c44y::P64 = Hp - 23;
      I64[Hp - 8] = sat_s3ED_info;
      P64[Hp] = _c44y::P64;
      _c44z::P64 = Hp - 7;
      R1 = _c44z::P64;
      P64[(old + 16)] = childHandler1_closure+2;
      call stg_catch#(R1) args: 16, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:18:40.80392 UTC

{offset
  c44H:
      _s3EE::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c44I; else goto c44J;
  c44J:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c44L; else goto c44K;
  c44L:
      HpAlloc = 32;
      goto c44I;
  c44I:
      R1 = _s3EE::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c44K:
      _s3EA::P64 = P64[_s3EE::P64 + 7];
      I64[Hp - 24] = STRef_con_info;
      P64[Hp - 16] = _s3EA::P64;
      _c44y::P64 = Hp - 23;
      I64[Hp - 8] = sat_s3ED_info;
      P64[Hp] = _c44y::P64;
      _c44z::P64 = Hp - 7;
      R1 = _c44z::P64;
      P64[(old + 16)] = childHandler1_closure+2;
      call stg_catch#(R1) args: 16, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:18:40.806824 UTC

sat_s3EE_entry
[c44H]
{offset
  c44H:
      _s3EE::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c44I; else goto c44J;
  c44J:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c44L; else goto c44K;
  c44L:
      HpAlloc = 32;
      goto c44I;
  c44I:
      R1 = _s3EE::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c44K:
      _s3EA::P64 = P64[_s3EE::P64 + 7];
      I64[Hp - 24] = STRef_con_info;
      P64[Hp - 16] = _s3EA::P64;
      _c44y::P64 = Hp - 23;
      I64[Hp - 8] = sat_s3ED_info;
      P64[Hp] = _c44y::P64;
      _c44z::P64 = Hp - 7;
      R1 = _c44z::P64;
      P64[(old + 16)] = childHandler1_closure+2;
      call stg_catch#(R1) args: 16, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:18:40.810347 UTC

{offset
  c44H:
      _s3EE::P64 = R1;
      if ((Sp + 8) - 16 < SpLim) goto c44I; else goto c44J;
  c44J:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c44L; else goto c44K;
  c44L:
      HpAlloc = 32;
      goto c44I;
  c44I:
      R1 = _s3EE::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c44K:
      _s3EA::P64 = P64[_s3EE::P64 + 7];
      I64[Hp - 24] = STRef_con_info;
      P64[Hp - 16] = _s3EA::P64;
      _c44y::P64 = Hp - 23;
      I64[Hp - 8] = sat_s3ED_info;
      P64[Hp] = _c44y::P64;
      _c44z::P64 = Hp - 7;
      R1 = _c44z::P64;
      P64[Sp - 8] = childHandler1_closure+2;
      Sp = Sp - 8;
      call stg_catch#(R1) args: 16, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:18:40.81484 UTC

{offset
  c44H:
      _s3EE::P64 = R1;
      if ((Sp + -8) < SpLim) goto c44I; else goto c44J;
  c44J:
      Hp = Hp + 32;
      if (Hp > HpLim) goto c44L; else goto c44K;
  c44L:
      HpAlloc = 32;
      goto c44I;
  c44I:
      R1 = _s3EE::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c44K:
      _s3EA::P64 = P64[_s3EE::P64 + 7];
      I64[Hp - 24] = STRef_con_info;
      P64[Hp - 16] = _s3EA::P64;
      I64[Hp - 8] = sat_s3ED_info;
      P64[Hp] = Hp - 23;
      R1 = Hp - 7;
      P64[Sp - 8] = childHandler1_closure+2;
      Sp = Sp - 8;
      call stg_catch#(R1) args: 16, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:18:40.817674 UTC

[(c44H, {childHandler1_closure, sat_s3ED_closure}), (c44I, {}),
 (c44J, {childHandler1_closure, sat_s3ED_closure}),
 (c44K, {childHandler1_closure, sat_s3ED_closure}), (c44L, {})]


==================== procpoint map ====================
2016-08-04 14:18:40.81894 UTC

[(c44H, <procpt>), (c44I, reached by c44H),
 (c44J, reached by c44H), (c44K, reached by c44H),
 (c44L, reached by c44H)]


==================== Post splitting ====================
2016-08-04 14:18:40.820014 UTC

sat_s3EE_entry() //  [R1]
        { info_tbl: [(c44H,
                      label: sat_s3EE_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44H:
          _s3EE::P64 = R1;
          if ((Sp + -8) < SpLim) goto c44I; else goto c44J;
      c44J:
          Hp = Hp + 32;
          if (Hp > HpLim) goto c44L; else goto c44K;
      c44L:
          HpAlloc = 32;
          goto c44I;
      c44I:
          R1 = _s3EE::P64;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c44K:
          _s3EA::P64 = P64[_s3EE::P64 + 7];
          I64[Hp - 24] = STRef_con_info;
          P64[Hp - 16] = _s3EA::P64;
          I64[Hp - 8] = sat_s3ED_info;
          P64[Hp] = Hp - 23;
          R1 = Hp - 7;
          P64[Sp - 8] = childHandler1_closure+2;
          Sp = Sp - 8;
          call stg_catch#(R1) args: 16, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:40.823623 UTC

sat_s3EE_entry() //  [R1]
        { info_tbl: [(c44H,
                      label: sat_s3EE_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44H:
          _s3EE::P64 = R1;
          if ((Sp + -8) < SpLim) goto c44I; else goto c44J;
      c44J:
          Hp = Hp + 32;
          if (Hp > HpLim) goto c44L; else goto c44K;
      c44L:
          HpAlloc = 32;
          goto c44I;
      c44I:
          R1 = _s3EE::P64;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c44K:
          _s3EA::P64 = P64[_s3EE::P64 + 7];
          I64[Hp - 24] = STRef_con_info;
          P64[Hp - 16] = _s3EA::P64;
          I64[Hp - 8] = sat_s3ED_info;
          P64[Hp] = Hp - 23;
          R1 = Hp - 7;
          P64[Sp - 8] = childHandler1_closure+2;
          Sp = Sp - 8;
          call stg_catch#(R1) args: 16, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.827019 UTC

sat_s3EE_entry() //  [R1]
        { info_tbl: [(c44H,
                      label: sat_s3EE_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44H:
          _s3EE::P64 = R1;
          if ((Sp + -8) < SpLim) goto c44I; else goto c44J;
      c44J:
          Hp = Hp + 32;
          if (Hp > HpLim) goto c44L; else goto c44K;
      c44L:
          HpAlloc = 32;
          goto c44I;
      c44I:
          R1 = _s3EE::P64;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c44K:
          _s3EA::P64 = P64[_s3EE::P64 + 7];
          I64[Hp - 24] = STRef_con_info;
          P64[Hp - 16] = _s3EA::P64;
          I64[Hp - 8] = sat_s3ED_info;
          P64[Hp] = Hp - 23;
          R1 = Hp - 7;
          P64[Sp - 8] = childHandler1_closure+2;
          Sp = Sp - 8;
          call stg_catch#(R1) args: 16, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.830644 UTC

{offset
  c44S:
      _s3EL::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c44T; else goto c44U;
  c44T:
      R1 = _s3EL::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c44U:
      _s3EK::P64 = P64[_s3EL::P64 + 16];
      P64[(old + 16)] = _s3EK::P64;
      call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:18:40.832549 UTC

{offset
  c44S:
      _s3EL::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c44T; else goto c44U;
  c44T:
      R1 = _s3EL::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c44U:
      _s3EK::P64 = P64[_s3EL::P64 + 16];
      P64[(old + 16)] = _s3EK::P64;
      call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:18:40.834217 UTC

sat_s3EL_entry
[c44S]
{offset
  c44S:
      _s3EL::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto c44T; else goto c44U;
  c44T:
      R1 = _s3EL::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c44U:
      _s3EK::P64 = P64[_s3EL::P64 + 16];
      P64[(old + 16)] = _s3EK::P64;
      call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:18:40.836353 UTC

{offset
  c44S:
      _s3EL::P64 = R1;
      if ((Sp + 8) - 16 < SpLim) goto c44T; else goto c44U;
  c44T:
      R1 = _s3EL::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c44U:
      _s3EK::P64 = P64[_s3EL::P64 + 16];
      P64[Sp - 8] = _s3EK::P64;
      Sp = Sp - 8;
      call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:18:40.83843 UTC

{offset
  c44S:
      if ((Sp + -8) < SpLim) goto c44T; else goto c44U;
  c44T:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  c44U:
      P64[Sp - 8] = P64[R1 + 16];
      Sp = Sp - 8;
      call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:18:40.839907 UTC

[(c44S, {$fShowFoo_$cshow_closure}), (c44T, {}),
 (c44U, {$fShowFoo_$cshow_closure})]


==================== procpoint map ====================
2016-08-04 14:18:40.840837 UTC

[(c44S, <procpt>), (c44T, reached by c44S),
 (c44U, reached by c44S)]


==================== Post splitting ====================
2016-08-04 14:18:40.841759 UTC

sat_s3EL_entry() //  [R1]
        { info_tbl: [(c44S,
                      label: sat_s3EL_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44S:
          if ((Sp + -8) < SpLim) goto c44T; else goto c44U;
      c44T:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c44U:
          P64[Sp - 8] = P64[R1 + 16];
          Sp = Sp - 8;
          call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:40.843952 UTC

sat_s3EL_entry() //  [R1]
        { info_tbl: [(c44S,
                      label: sat_s3EL_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44S:
          if ((Sp + -8) < SpLim) goto c44T; else goto c44U;
      c44T:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c44U:
          P64[Sp - 8] = P64[R1 + 16];
          Sp = Sp - 8;
          call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.845963 UTC

sat_s3EL_entry() //  [R1]
        { info_tbl: [(c44S,
                      label: sat_s3EL_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44S:
          if ((Sp + -8) < SpLim) goto c44T; else goto c44U;
      c44T:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      c44U:
          P64[Sp - 8] = P64[R1 + 16];
          Sp = Sp - 8;
          call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.848497 UTC

{offset
  c44V:
      if ((old + 0) - <highSp> < SpLim) goto c44W; else goto c44X;
  c44W:
      R1 = main1_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c44X:
      I64[(young<c44r> + 8)] = c44r;
      R1 = main3_closure+1;
      call stg_newMutVar#(R1) returns to c44r, args: 8, res: 8, upd: 8;
  c44r:
      _s3EA::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto c450; else goto c44Z;
  c450:
      HpAlloc = 16;
      R1 = _s3EA::P64;
      call stg_gc_unpt_r1(R1) returns to c44r, args: 8, res: 8, upd: 8;
  c44Z:
      I64[Hp - 8] = sat_s3EE_info;
      P64[Hp] = _s3EA::P64;
      _c44t::P64 = Hp - 7;
      I64[(young<c44M> + 8)] = c44M;
      R1 = _c44t::P64;
      call stg_fork#(R1) returns to c44M, args: 8, res: 8, upd: 8;
  c44M:
      _s3EH::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c453; else goto c452;
  c453:
      HpAlloc = 24;
      R1 = _s3EH::P64;
      call stg_gc_unpt_r1(R1) returns to c44M, args: 8, res: 8, upd: 8;
  c452:
      _s3EK::P64 = P64[_s3EA::P64 + 8];
      _s3EK::P64 = _s3EK::P64;
      I64[Hp - 16] = sat_s3EL_info;
      P64[Hp] = _s3EK::P64;
      _c44O::P64 = Hp - 16;
      P64[(old + 32)] = stdout_closure;
      P64[(old + 24)] = _c44O::P64;
      P64[(old + 16)] = True_closure+2;
      call hPutStr2_entry() args: 32, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:18:40.853888 UTC

{offset
  c44V:
      if ((old + 0) - <highSp> < SpLim) goto c44W; else goto c44X;
  c44W:
      R1 = main1_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c44X:
      I64[(young<c44r> + 8)] = c44r;
      R1 = main3_closure+1;
      call stg_newMutVar#(R1) returns to c44r, args: 8, res: 8, upd: 8;
  c44r:
      _s3EA::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto c450; else goto c44Z;
  c450:
      HpAlloc = 16;
      R1 = _s3EA::P64;
      call stg_gc_unpt_r1(R1) returns to c44r, args: 8, res: 8, upd: 8;
  c44Z:
      I64[Hp - 8] = sat_s3EE_info;
      P64[Hp] = _s3EA::P64;
      _c44t::P64 = Hp - 7;
      I64[(young<c44M> + 8)] = c44M;
      R1 = _c44t::P64;
      call stg_fork#(R1) returns to c44M, args: 8, res: 8, upd: 8;
  c44M:
      _s3EH::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c453; else goto c452;
  c453:
      HpAlloc = 24;
      R1 = _s3EH::P64;
      call stg_gc_unpt_r1(R1) returns to c44M, args: 8, res: 8, upd: 8;
  c452:
      _s3EK::P64 = P64[_s3EA::P64 + 8];
      _s3EK::P64 = _s3EK::P64;
      I64[Hp - 16] = sat_s3EL_info;
      P64[Hp] = _s3EK::P64;
      _c44O::P64 = Hp - 16;
      P64[(old + 32)] = stdout_closure;
      P64[(old + 24)] = _c44O::P64;
      P64[(old + 16)] = True_closure+2;
      call hPutStr2_entry() args: 32, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:18:40.858851 UTC

main1_entry
[c44r, c44M, c44V]
{offset
  c44V:
      if ((old + 0) - <highSp> < SpLim) goto c44W; else goto c44X;
  c44W:
      R1 = main1_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c44X:
      I64[(young<c44r> + 8)] = c44r;
      R1 = main3_closure+1;
      call stg_newMutVar#(R1) returns to c44r, args: 8, res: 8, upd: 8;
  c44r:
      _s3EA::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto c450; else goto c44Z;
  c450:
      HpAlloc = 16;
      R1 = _s3EA::P64;
      call stg_gc_unpt_r1(R1) returns to c44r, args: 8, res: 8, upd: 8;
  c44Z:
      I64[Hp - 8] = sat_s3EE_info;
      P64[Hp] = _s3EA::P64;
      _c44t::P64 = Hp - 7;
      I64[(young<c44M> + 8)] = c44M;
      R1 = _c44t::P64;
      call stg_fork#(R1) returns to c44M, args: 8, res: 8, upd: 8;
  c44M:
      _s3EH::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c453; else goto c452;
  c453:
      HpAlloc = 24;
      R1 = _s3EH::P64;
      call stg_gc_unpt_r1(R1) returns to c44M, args: 8, res: 8, upd: 8;
  c452:
      _s3EK::P64 = P64[_s3EA::P64 + 8];
      _s3EK::P64 = _s3EK::P64;
      I64[Hp - 16] = sat_s3EL_info;
      P64[Hp] = _s3EK::P64;
      _c44O::P64 = Hp - 16;
      P64[(old + 32)] = stdout_closure;
      P64[(old + 24)] = _c44O::P64;
      P64[(old + 16)] = True_closure+2;
      call hPutStr2_entry() args: 32, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:18:40.864931 UTC

{offset
  c44V:
      if ((Sp + 8) - 32 < SpLim) goto c44W; else goto c44X;
  c44W:
      R1 = main1_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c44X:
      I64[Sp - 8] = c44r;
      R1 = main3_closure+1;
      Sp = Sp - 8;
      call stg_newMutVar#(R1) returns to c44r, args: 8, res: 8, upd: 8;
  c44r:
      _s3EA::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto c450; else goto c44Z;
  c450:
      HpAlloc = 16;
      R1 = _s3EA::P64;
      call stg_gc_unpt_r1(R1) returns to c44r, args: 8, res: 8, upd: 8;
  c44Z:
      I64[Hp - 8] = sat_s3EE_info;
      P64[Hp] = _s3EA::P64;
      _c44t::P64 = Hp - 7;
      I64[Sp - 8] = c44M;
      R1 = _c44t::P64;
      P64[Sp] = _s3EA::P64;
      Sp = Sp - 8;
      call stg_fork#(R1) returns to c44M, args: 8, res: 8, upd: 8;
  c44M:
      _s3EA::P64 = P64[Sp + 8];
      _s3EH::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto c453; else goto c452;
  c453:
      HpAlloc = 24;
      R1 = _s3EH::P64;
      call stg_gc_unpt_r1(R1) returns to c44M, args: 8, res: 8, upd: 8;
  c452:
      _s3EK::P64 = P64[_s3EA::P64 + 8];
      _s3EK::P64 = _s3EK::P64;
      I64[Hp - 16] = sat_s3EL_info;
      P64[Hp] = _s3EK::P64;
      _c44O::P64 = Hp - 16;
      P64[Sp - 8] = stdout_closure;
      P64[Sp] = _c44O::P64;
      P64[Sp + 8] = True_closure+2;
      Sp = Sp - 8;
      call hPutStr2_entry() args: 32, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:18:40.872192 UTC

{offset
  c44V:
      if ((Sp + -24) < SpLim) goto c44W; else goto c44X;
  c44W:
      R1 = main1_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c44X:
      I64[Sp - 8] = c44r;
      R1 = main3_closure+1;
      Sp = Sp - 8;
      call stg_newMutVar#(R1) returns to c44r, args: 8, res: 8, upd: 8;
  c44r:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c450; else goto c44Z;
  c450:
      HpAlloc = 16;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to c44r, args: 8, res: 8, upd: 8;
  c44Z:
      I64[Hp - 8] = sat_s3EE_info;
      P64[Hp] = R1;
      I64[Sp - 8] = c44M;
      _s3EA::P64 = R1;
      R1 = Hp - 7;
      P64[Sp] = _s3EA::P64;
      Sp = Sp - 8;
      call stg_fork#(R1) returns to c44M, args: 8, res: 8, upd: 8;
  c44M:
      Hp = Hp + 24;
      if (Hp > HpLim) goto c453; else goto c452;
  c453:
      HpAlloc = 24;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to c44M, args: 8, res: 8, upd: 8;
  c452:
      I64[Hp - 16] = sat_s3EL_info;
      P64[Hp] = P64[P64[Sp + 8] + 8];
      P64[Sp - 8] = stdout_closure;
      P64[Sp] = Hp - 16;
      P64[Sp + 8] = True_closure+2;
      Sp = Sp - 8;
      call hPutStr2_entry() args: 32, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:18:40.876874 UTC

[(c44r,
  {stdout_closure, hPutStr2_closure, sat_s3EE_closure,
   sat_s3EL_closure}),
 (c44M, {stdout_closure, hPutStr2_closure, sat_s3EL_closure}),
 (c44V,
  {stdout_closure, hPutStr2_closure, main1_closure, sat_s3EE_closure,
   sat_s3EL_closure}),
 (c44W, {main1_closure}),
 (c44X,
  {stdout_closure, hPutStr2_closure, sat_s3EE_closure,
   sat_s3EL_closure}),
 (c44Z,
  {stdout_closure, hPutStr2_closure, sat_s3EE_closure,
   sat_s3EL_closure}),
 (c450,
  {stdout_closure, hPutStr2_closure, sat_s3EE_closure,
   sat_s3EL_closure}),
 (c452, {stdout_closure, hPutStr2_closure, sat_s3EL_closure}),
 (c453, {stdout_closure, hPutStr2_closure, sat_s3EL_closure})]


==================== procpoint map ====================
2016-08-04 14:18:40.880068 UTC

[(c44r, <procpt>), (c44M, <procpt>), (c44V, <procpt>),
 (c44W, reached by c44V), (c44X, reached by c44V),
 (c44Z, reached by c44r), (c450, reached by c44r),
 (c452, reached by c44M), (c453, reached by c44M)]


==================== Post splitting ====================
2016-08-04 14:18:40.881524 UTC

main1_entry() //  []
        { info_tbl: [(c44V,
                      label: main1_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44V:
          if ((Sp + -24) < SpLim) goto c44W; else goto c44X;
      c44W:
          R1 = main1_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c44X:
          I64[Sp - 8] = block_c44r_info;
          R1 = main3_closure+1;
          Sp = Sp - 8;
          call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-04 14:18:40.884065 UTC

block_c44r_entry() //  [R1]
        { info_tbl: [(c44r,
                      label: block_c44r_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44r:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c450; else goto c44Z;
      c450:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c44Z:
          I64[Hp - 8] = sat_s3EE_info;
          P64[Hp] = R1;
          I64[Sp - 8] = block_c44M_info;
          _s3EA::P64 = R1;
          R1 = Hp - 7;
          P64[Sp] = _s3EA::P64;
          Sp = Sp - 8;
          call stg_fork#(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post splitting ====================
2016-08-04 14:18:40.886689 UTC

block_c44M_entry() //  [R1]
        { info_tbl: [(c44M,
                      label: block_c44M_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44M:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c453; else goto c452;
      c453:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c452:
          I64[Hp - 16] = sat_s3EL_info;
          P64[Hp] = P64[P64[Sp + 8] + 8];
          P64[Sp - 8] = stdout_closure;
          P64[Sp] = Hp - 16;
          P64[Sp + 8] = True_closure+2;
          Sp = Sp - 8;
          call hPutStr2_entry() args: 32, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:40.889348 UTC

main1_entry() //  []
        { info_tbl: [(c44V,
                      label: main1_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44V:
          if ((Sp + -24) < SpLim) goto c44W; else goto c44X;
      c44W:
          R1 = main1_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c44X:
          I64[Sp - 8] = block_c44r_info;
          R1 = main3_closure+1;
          Sp = Sp - 8;
          call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:40.8915 UTC

block_c44r_entry() //  [R1]
        { info_tbl: [(c44r,
                      label: block_c44r_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44r:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c450; else goto c44Z;
      c450:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c44Z:
          I64[Hp - 8] = sat_s3EE_info;
          P64[Hp] = R1;
          I64[Sp - 8] = block_c44M_info;
          _s3EA::P64 = R1;
          R1 = Hp - 7;
          P64[Sp] = _s3EA::P64;
          Sp = Sp - 8;
          call stg_fork#(R1) args: 8, res: 8, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:40.894063 UTC

block_c44M_entry() //  [R1]
        { info_tbl: [(c44M,
                      label: block_c44M_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44M:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c453; else goto c452;
      c453:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c452:
          I64[Hp - 16] = sat_s3EL_info;
          P64[Hp] = P64[P64[Sp + 8] + 8];
          P64[Sp - 8] = stdout_closure;
          P64[Sp] = Hp - 16;
          P64[Sp + 8] = True_closure+2;
          Sp = Sp - 8;
          call hPutStr2_entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.896706 UTC

main1_entry() //  []
        { info_tbl: [(c44V,
                      label: main1_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44V:
          if ((Sp + -24) < SpLim) goto c44W; else goto c44X;
      c44W:
          R1 = main1_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c44X:
          I64[Sp - 8] = block_c44r_info;
          R1 = main3_closure+1;
          Sp = Sp - 8;
          call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.898874 UTC

block_c44r_entry() //  [R1]
        { info_tbl: [(c44r,
                      label: block_c44r_info
                      rep:StackRep [])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44r:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c450; else goto c44Z;
      c450:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c44Z:
          I64[Hp - 8] = sat_s3EE_info;
          P64[Hp] = R1;
          I64[Sp - 8] = block_c44M_info;
          _s3EA::P64 = R1;
          R1 = Hp - 7;
          P64[Sp] = _s3EA::P64;
          Sp = Sp - 8;
          call stg_fork#(R1) args: 8, res: 8, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:40.901511 UTC

block_c44M_entry() //  [R1]
        { info_tbl: [(c44M,
                      label: block_c44M_info
                      rep:StackRep [False])]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c44M:
          Hp = Hp + 24;
          if (Hp > HpLim) goto c453; else goto c452;
      c453:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
      c452:
          I64[Hp - 16] = sat_s3EL_info;
          P64[Hp] = P64[P64[Sp + 8] + 8];
          P64[Sp - 8] = stdout_closure;
          P64[Sp] = Hp - 16;
          P64[Sp + 8] = True_closure+2;
          Sp = Sp - 8;
          call hPutStr2_entry() args: 32, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:18:40.904194 UTC

[section "data" {
     main1_closure:
         const main1_info;
         const 0;
 },
 sat_s3ED_entry() //  [R1]
         { info_tbl: [(c44E,
                       label: sat_s3ED_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44E:
           if ((Sp + -16) < SpLim) goto c44F; else goto c44G;
       c44F:
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c44G:
           P64[Sp - 16] = P64[R1 + 7];
           P64[Sp - 8] = main2_closure+1;
           Sp = Sp - 16;
           call dowrite_entry() args: 24, res: 0, upd: 8;
     }
 },
 sat_s3EE_entry() //  [R1]
         { info_tbl: [(c44H,
                       label: sat_s3EE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44H:
           _s3EE::P64 = R1;
           if ((Sp + -8) < SpLim) goto c44I; else goto c44J;
       c44J:
           Hp = Hp + 32;
           if (Hp > HpLim) goto c44L; else goto c44K;
       c44L:
           HpAlloc = 32;
           goto c44I;
       c44I:
           R1 = _s3EE::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c44K:
           _s3EA::P64 = P64[_s3EE::P64 + 7];
           I64[Hp - 24] = STRef_con_info;
           P64[Hp - 16] = _s3EA::P64;
           I64[Hp - 8] = sat_s3ED_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           P64[Sp - 8] = childHandler1_closure+2;
           Sp = Sp - 8;
           call stg_catch#(R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_s3EL_entry() //  [R1]
         { info_tbl: [(c44S,
                       label: sat_s3EL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44S:
           if ((Sp + -8) < SpLim) goto c44T; else goto c44U;
       c44T:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44U:
           P64[Sp - 8] = P64[R1 + 16];
           Sp = Sp - 8;
           call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
     }
 },
 main1_entry() //  []
         { info_tbl: [(c44V,
                       label: main1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44V:
           if ((Sp + -24) < SpLim) goto c44W; else goto c44X;
       c44W:
           R1 = main1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c44X:
           I64[Sp - 8] = block_c44r_info;
           R1 = main3_closure+1;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c44r_entry() //  [R1]
         { info_tbl: [(c44r,
                       label: block_c44r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44r:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c450; else goto c44Z;
       c450:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44Z:
           I64[Hp - 8] = sat_s3EE_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c44M_info;
           _s3EA::P64 = R1;
           R1 = Hp - 7;
           P64[Sp] = _s3EA::P64;
           Sp = Sp - 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c44M_entry() //  [R1]
         { info_tbl: [(c44M,
                       label: block_c44M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44M:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c453; else goto c452;
       c453:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c452:
           I64[Hp - 16] = sat_s3EL_info;
           P64[Hp] = P64[P64[Sp + 8] + 8];
           P64[Sp - 8] = stdout_closure;
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = True_closure+2;
           Sp = Sp - 8;
           call hPutStr2_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:18:40.917469 UTC

[section "data" {
     main1_closure:
         const main1_info;
         const 0;
 },
 sat_s3ED_entry() //  [R1]
         { info_tbl: [(c44E,
                       label: sat_s3ED_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44E:
           if ((Sp + -16) < SpLim) goto c44F; else goto c44G;
       c44F:
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c44G:
           P64[Sp - 16] = P64[R1 + 7];
           P64[Sp - 8] = main2_closure+1;
           Sp = Sp - 16;
           call dowrite_entry() args: 24, res: 0, upd: 8;
     }
 },
 sat_s3EE_entry() //  [R1]
         { info_tbl: [(c44H,
                       label: sat_s3EE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44H:
           _s3EE::P64 = R1;
           if ((Sp + -8) < SpLim) goto c44I; else goto c44J;
       c44J:
           Hp = Hp + 32;
           if (Hp > HpLim) goto c44L; else goto c44K;
       c44L:
           HpAlloc = 32;
           goto c44I;
       c44I:
           R1 = _s3EE::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c44K:
           _s3EA::P64 = P64[_s3EE::P64 + 7];
           I64[Hp - 24] = STRef_con_info;
           P64[Hp - 16] = _s3EA::P64;
           I64[Hp - 8] = sat_s3ED_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           P64[Sp - 8] = childHandler1_closure+2;
           Sp = Sp - 8;
           call stg_catch#(R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_s3EL_entry() //  [R1]
         { info_tbl: [(c44S,
                       label: sat_s3EL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44S:
           if ((Sp + -8) < SpLim) goto c44T; else goto c44U;
       c44T:
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44U:
           P64[Sp - 8] = P64[R1 + 16];
           Sp = Sp - 8;
           call $fShowFoo_$cshow_entry() args: 16, res: 0, upd: 8;
     }
 },
 main1_entry() //  []
         { info_tbl: [(c44V,
                       label: main1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44V:
           if ((Sp + -24) < SpLim) goto c44W; else goto c44X;
       c44W:
           R1 = main1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c44X:
           I64[Sp - 8] = block_c44r_info;
           R1 = main3_closure+1;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c44r_entry() //  [R1]
         { info_tbl: [(c44r,
                       label: block_c44r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44r:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c450; else goto c44Z;
       c450:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44Z:
           I64[Hp - 8] = sat_s3EE_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c44M_info;
           _s3EA::P64 = R1;
           R1 = Hp - 7;
           P64[Sp] = _s3EA::P64;
           Sp = Sp - 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 block_c44M_entry() //  [R1]
         { info_tbl: [(c44M,
                       label: block_c44M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44M:
           Hp = Hp + 24;
           if (Hp > HpLim) goto c453; else goto c452;
       c453:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c452:
           I64[Hp - 16] = sat_s3EL_info;
           P64[Hp] = P64[P64[Sp + 8] + 8];
           P64[Sp - 8] = stdout_closure;
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = True_closure+2;
           Sp = Sp - 8;
           call hPutStr2_entry() args: 32, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:18:41.036696 UTC

[section "data" {
     main_closure:
         const main_info;
         const 0;
 },
 main_entry() //  []
         { info_tbl: [(c4bB,
                       label: main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4bB:
           goto c4bz;
       c4bz:
           if ((old + 0) - <highSp> < SpLim) goto c4bC; else goto c4bD;
       c4bC:
           R1 = main_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4bD:
           goto c4by;
       c4by:
           call main1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:18:41.039609 UTC

{offset
  c4bB:
      if ((old + 0) - <highSp> < SpLim) goto c4bC; else goto c4bD;
  c4bC:
      R1 = main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4bD:
      call main1_entry() args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:18:41.041044 UTC

{offset
  c4bB:
      if ((old + 0) - <highSp> < SpLim) goto c4bC; else goto c4bD;
  c4bC:
      R1 = main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4bD:
      call main1_entry() args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:18:41.042334 UTC

main_entry
[c4bB]
{offset
  c4bB:
      if ((old + 0) - <highSp> < SpLim) goto c4bC; else goto c4bD;
  c4bC:
      R1 = main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4bD:
      call main1_entry() args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:18:41.043963 UTC

{offset
  c4bB:
      goto c4bD;
  c4bD:
      call main1_entry() args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:18:41.044931 UTC

{offset
  c4bB:
      goto c4bD;
  c4bD:
      call main1_entry() args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:18:41.04579 UTC

[(c4bB, {main1_closure}), (c4bD, {main1_closure})]


==================== procpoint map ====================
2016-08-04 14:18:41.046634 UTC

[(c4bB, <procpt>), (c4bD, reached by c4bB)]


==================== Post splitting ====================
2016-08-04 14:18:41.047427 UTC

main_entry() //  []
        { info_tbl: [(c4bB,
                      label: main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4bB:
          goto c4bD;
      c4bD:
          call main1_entry() args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:41.048908 UTC

main_entry() //  []
        { info_tbl: [(c4bB,
                      label: main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4bB:
          goto c4bD;
      c4bD:
          call main1_entry() args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:41.050281 UTC

main_entry() //  []
        { info_tbl: [(c4bB,
                      label: main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4bB:
          call main1_entry() args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:18:41.05166 UTC

[section "data" {
     main_closure:
         const main_info;
         const 0;
 },
 main_entry() //  []
         { info_tbl: [(c4bB,
                       label: main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bB:
           call main1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:18:41.053363 UTC

[section "data" {
     main_closure:
         const main_info;
         const 0;
 },
 main_entry() //  []
         { info_tbl: [(c4bB,
                       label: main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bB:
           call main1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:18:41.060309 UTC

[section "data" {
     main5_closure:
         const main5_info;
         const 0;
 },
 main5_entry() //  []
         { info_tbl: [(c4bJ,
                       label: main5_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4bJ:
           goto c4bH;
       c4bH:
           if ((old + 0) - <highSp> < SpLim) goto c4bK; else goto c4bL;
       c4bK:
           R1 = main5_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4bL:
           goto c4bG;
       c4bG:
           P64[(old + 16)] = main1_closure+1;
           call runMainIO1_entry() args: 16, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:18:41.063296 UTC

{offset
  c4bJ:
      if ((old + 0) - <highSp> < SpLim) goto c4bK; else goto c4bL;
  c4bK:
      R1 = main5_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4bL:
      P64[(old + 16)] = main1_closure+1;
      call runMainIO1_entry() args: 16, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:18:41.064869 UTC

{offset
  c4bJ:
      if ((old + 0) - <highSp> < SpLim) goto c4bK; else goto c4bL;
  c4bK:
      R1 = main5_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4bL:
      P64[(old + 16)] = main1_closure+1;
      call runMainIO1_entry() args: 16, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:18:41.066291 UTC

main5_entry
[c4bJ]
{offset
  c4bJ:
      if ((old + 0) - <highSp> < SpLim) goto c4bK; else goto c4bL;
  c4bK:
      R1 = main5_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4bL:
      P64[(old + 16)] = main1_closure+1;
      call runMainIO1_entry() args: 16, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:18:41.068927 UTC

{offset
  c4bJ:
      if ((Sp + 8) - 16 < SpLim) goto c4bK; else goto c4bL;
  c4bK:
      R1 = main5_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4bL:
      P64[Sp - 8] = main1_closure+1;
      Sp = Sp - 8;
      call runMainIO1_entry() args: 16, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:18:41.070682 UTC

{offset
  c4bJ:
      if ((Sp + -8) < SpLim) goto c4bK; else goto c4bL;
  c4bK:
      R1 = main5_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4bL:
      P64[Sp - 8] = main1_closure+1;
      Sp = Sp - 8;
      call runMainIO1_entry() args: 16, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:18:41.072183 UTC

[(c4bJ, {runMainIO1_closure, main1_closure, main5_closure}),
 (c4bK, {main5_closure}),
 (c4bL, {runMainIO1_closure, main1_closure})]


==================== procpoint map ====================
2016-08-04 14:18:41.073282 UTC

[(c4bJ, <procpt>), (c4bK, reached by c4bJ),
 (c4bL, reached by c4bJ)]


==================== Post splitting ====================
2016-08-04 14:18:41.074169 UTC

main5_entry() //  []
        { info_tbl: [(c4bJ,
                      label: main5_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4bJ:
          if ((Sp + -8) < SpLim) goto c4bK; else goto c4bL;
      c4bK:
          R1 = main5_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c4bL:
          P64[Sp - 8] = main1_closure+1;
          Sp = Sp - 8;
          call runMainIO1_entry() args: 16, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:41.076408 UTC

main5_entry() //  []
        { info_tbl: [(c4bJ,
                      label: main5_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4bJ:
          if ((Sp + -8) < SpLim) goto c4bK; else goto c4bL;
      c4bK:
          R1 = main5_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c4bL:
          P64[Sp - 8] = main1_closure+1;
          Sp = Sp - 8;
          call runMainIO1_entry() args: 16, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:41.078407 UTC

main5_entry() //  []
        { info_tbl: [(c4bJ,
                      label: main5_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4bJ:
          if ((Sp + -8) < SpLim) goto c4bK; else goto c4bL;
      c4bK:
          R1 = main5_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      c4bL:
          P64[Sp - 8] = main1_closure+1;
          Sp = Sp - 8;
          call runMainIO1_entry() args: 16, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:18:41.080466 UTC

[section "data" {
     main5_closure:
         const main5_info;
         const 0;
 },
 main5_entry() //  []
         { info_tbl: [(c4bJ,
                       label: main5_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bJ:
           if ((Sp + -8) < SpLim) goto c4bK; else goto c4bL;
       c4bK:
           R1 = main5_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4bL:
           P64[Sp - 8] = main1_closure+1;
           Sp = Sp - 8;
           call runMainIO1_entry() args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:18:41.082951 UTC

[section "data" {
     main5_closure:
         const main5_info;
         const 0;
 },
 main5_entry() //  []
         { info_tbl: [(c4bJ,
                       label: main5_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bJ:
           if ((Sp + -8) < SpLim) goto c4bK; else goto c4bL;
       c4bK:
           R1 = main5_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4bL:
           P64[Sp - 8] = main1_closure+1;
           Sp = Sp - 8;
           call runMainIO1_entry() args: 16, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:18:41.097972 UTC

[section "data" {
     main_closure:
         const main_info;
         const 0;
 },
 main_entry() //  []
         { info_tbl: [(c4cq,
                       label: main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4cq:
           goto c4co;
       c4co:
           if ((old + 0) - <highSp> < SpLim) goto c4cr; else goto c4cs;
       c4cr:
           R1 = main_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4cs:
           goto c4cn;
       c4cn:
           call main5_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:18:41.100733 UTC

{offset
  c4cq:
      if ((old + 0) - <highSp> < SpLim) goto c4cr; else goto c4cs;
  c4cr:
      R1 = main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4cs:
      call main5_entry() args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:18:41.102189 UTC

{offset
  c4cq:
      if ((old + 0) - <highSp> < SpLim) goto c4cr; else goto c4cs;
  c4cr:
      R1 = main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4cs:
      call main5_entry() args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:18:41.103446 UTC

main_entry
[c4cq]
{offset
  c4cq:
      if ((old + 0) - <highSp> < SpLim) goto c4cr; else goto c4cs;
  c4cr:
      R1 = main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  c4cs:
      call main5_entry() args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:18:41.105035 UTC

{offset
  c4cq:
      goto c4cs;
  c4cs:
      call main5_entry() args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:18:41.105993 UTC

{offset
  c4cq:
      goto c4cs;
  c4cs:
      call main5_entry() args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:18:41.106873 UTC

[(c4cq, {main5_closure}), (c4cs, {main5_closure})]


==================== procpoint map ====================
2016-08-04 14:18:41.107686 UTC

[(c4cq, <procpt>), (c4cs, reached by c4cq)]


==================== Post splitting ====================
2016-08-04 14:18:41.108467 UTC

main_entry() //  []
        { info_tbl: [(c4cq,
                      label: main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4cq:
          goto c4cs;
      c4cs:
          call main5_entry() args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:41.109914 UTC

main_entry() //  []
        { info_tbl: [(c4cq,
                      label: main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4cq:
          goto c4cs;
      c4cs:
          call main5_entry() args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:41.112138 UTC

main_entry() //  []
        { info_tbl: [(c4cq,
                      label: main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4cq:
          call main5_entry() args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:18:41.113505 UTC

[section "data" {
     main_closure:
         const main_info;
         const 0;
 },
 main_entry() //  []
         { info_tbl: [(c4cq,
                       label: main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cq:
           call main5_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:18:41.115175 UTC

[section "data" {
     main_closure:
         const main_info;
         const 0;
 },
 main_entry() //  []
         { info_tbl: [(c4cq,
                       label: main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cq:
           call main5_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:18:41.122093 UTC

[section "data" {
     Foo_closure:
         const Foo_info;
 },
 Foo_entry() //  []
         { info_tbl: [(c4cz,
                       label: Foo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 16 updfr_space: Just 8
         }
     {offset
       c4cz:
           _B1::P64 = P64[(old + 16)];
           goto c4cw;
       c4cw:
           if ((old + 0) - <highSp> < SpLim) goto c4cA; else goto c4cB;
       c4cB:
           goto c4cv;
       c4cv:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c4cD; else goto c4cC;
       c4cD:
           HpAlloc = 16;
           goto c4cA;
       c4cA:
           R1 = Foo_closure;
           P64[(old + 16)] = _B1::P64;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c4cC:
           I64[Hp - 8] = Foo_con_info;
           P64[Hp] = _B1::P64;
           _c4cy::P64 = Hp - 7;
           R1 = _c4cy::P64;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:18:41.126277 UTC

{offset
  c4cz:
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c4cA; else goto c4cB;
  c4cB:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c4cD; else goto c4cC;
  c4cD:
      HpAlloc = 16;
      goto c4cA;
  c4cA:
      R1 = Foo_closure;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c4cC:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c4cy::P64 = Hp - 7;
      R1 = _c4cy::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:18:41.12896 UTC

{offset
  c4cz:
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c4cA; else goto c4cB;
  c4cB:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c4cD; else goto c4cC;
  c4cD:
      HpAlloc = 16;
      goto c4cA;
  c4cA:
      R1 = Foo_closure;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c4cC:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c4cy::P64 = Hp - 7;
      R1 = _c4cy::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:18:41.131381 UTC

Foo_entry
[c4cz]
{offset
  c4cz:
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto c4cA; else goto c4cB;
  c4cB:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c4cD; else goto c4cC;
  c4cD:
      HpAlloc = 16;
      goto c4cA;
  c4cA:
      R1 = Foo_closure;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c4cC:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c4cy::P64 = Hp - 7;
      R1 = _c4cy::P64;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:18:41.134391 UTC

{offset
  c4cz:
      _B1::P64 = P64[Sp];
      goto c4cB;
  c4cB:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c4cD; else goto c4cC;
  c4cD:
      HpAlloc = 16;
      goto c4cA;
  c4cA:
      R1 = Foo_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c4cC:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = _B1::P64;
      _c4cy::P64 = Hp - 7;
      R1 = _c4cy::P64;
      Sp = Sp + 8;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:18:41.137047 UTC

{offset
  c4cz:
      goto c4cB;
  c4cB:
      Hp = Hp + 16;
      if (Hp > HpLim) goto c4cD; else goto c4cC;
  c4cD:
      HpAlloc = 16;
      goto c4cA;
  c4cA:
      R1 = Foo_closure;
      call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
  c4cC:
      I64[Hp - 8] = Foo_con_info;
      P64[Hp] = P64[Sp];
      R1 = Hp - 7;
      Sp = Sp + 8;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:18:41.138967 UTC

[(c4cz, {}), (c4cA, {}), (c4cB, {}), (c4cC, {}), (c4cD, {})]


==================== procpoint map ====================
2016-08-04 14:18:41.139913 UTC

[(c4cz, <procpt>), (c4cA, reached by c4cz),
 (c4cB, reached by c4cz), (c4cC, reached by c4cz),
 (c4cD, reached by c4cz)]


==================== Post splitting ====================
2016-08-04 14:18:41.14097 UTC

Foo_entry() //  []
        { info_tbl: [(c4cz,
                      label: Foo_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4cz:
          goto c4cB;
      c4cB:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c4cD; else goto c4cC;
      c4cD:
          HpAlloc = 16;
          goto c4cA;
      c4cA:
          R1 = Foo_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c4cC:
          I64[Hp - 8] = Foo_con_info;
          P64[Hp] = P64[Sp];
          R1 = Hp - 7;
          Sp = Sp + 8;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:41.143683 UTC

Foo_entry() //  []
        { info_tbl: [(c4cz,
                      label: Foo_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4cz:
          goto c4cB;
      c4cB:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c4cD; else goto c4cC;
      c4cD:
          HpAlloc = 16;
          goto c4cA;
      c4cA:
          R1 = Foo_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c4cC:
          I64[Hp - 8] = Foo_con_info;
          P64[Hp] = P64[Sp];
          R1 = Hp - 7;
          Sp = Sp + 8;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:41.146165 UTC

Foo_entry() //  []
        { info_tbl: [(c4cz,
                      label: Foo_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4cz:
          Hp = Hp + 16;
          if (Hp > HpLim) goto c4cD; else goto c4cC;
      c4cD:
          HpAlloc = 16;
          R1 = Foo_closure;
          call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
      c4cC:
          I64[Hp - 8] = Foo_con_info;
          P64[Hp] = P64[Sp];
          R1 = Hp - 7;
          Sp = Sp + 8;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:18:41.148593 UTC

[section "data" {
     Foo_closure:
         const Foo_info;
 },
 Foo_entry() //  []
         { info_tbl: [(c4cz,
                       label: Foo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cz:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c4cD; else goto c4cC;
       c4cD:
           HpAlloc = 16;
           R1 = Foo_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c4cC:
           I64[Hp - 8] = Foo_con_info;
           P64[Hp] = P64[Sp];
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:18:41.151268 UTC

[section "data" {
     Foo_closure:
         const Foo_info;
 },
 Foo_entry() //  []
         { info_tbl: [(c4cz,
                       label: Foo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cz:
           Hp = Hp + 16;
           if (Hp > HpLim) goto c4cD; else goto c4cC;
       c4cD:
           HpAlloc = 16;
           R1 = Foo_closure;
           call (stg_gc_fun)(R1) args: 16, res: 0, upd: 8;
       c4cC:
           I64[Hp - 8] = Foo_con_info;
           P64[Hp] = P64[Sp];
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2016-08-04 14:18:41.174222 UTC

[Foo_con_entry() //  []
         { info_tbl: [(c4dO,
                       label: Foo_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4dO:
           R1 = R1 + 1;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foo_static_entry() //  []
         { info_tbl: [(c4dP,
                       label: Foo_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4dP:
           R1 = R1 + 1;
           call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2016-08-04 14:18:41.177718 UTC

{offset
  c4dO:
      R1 = R1 + 1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:18:41.178801 UTC

{offset
  c4dO:
      R1 = R1 + 1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:18:41.179774 UTC

Foo_con_entry
[c4dO]
{offset
  c4dO:
      R1 = R1 + 1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:18:41.180989 UTC

{offset
  c4dO:
      R1 = R1 + 1;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:18:41.182065 UTC

{offset
  c4dO:
      R1 = R1 + 1;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:18:41.182997 UTC

[(c4dO, {})]


==================== procpoint map ====================
2016-08-04 14:18:41.183668 UTC

[(c4dO, <procpt>)]


==================== Post splitting ====================
2016-08-04 14:18:41.184356 UTC

Foo_con_entry() //  [R1]
        { info_tbl: [(c4dO,
                      label: Foo_con_info
                      rep:HeapRep 1 ptrs {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4dO:
          R1 = R1 + 1;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:41.18604 UTC

Foo_con_entry() //  [R1]
        { info_tbl: [(c4dO,
                      label: Foo_con_info
                      rep:HeapRep 1 ptrs {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4dO:
          R1 = R1 + 1;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:41.187637 UTC

Foo_con_entry() //  [R1]
        { info_tbl: [(c4dO,
                      label: Foo_con_info
                      rep:HeapRep 1 ptrs {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4dO:
          R1 = R1 + 1;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:41.189327 UTC

{offset
  c4dP:
      R1 = R1 + 1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2016-08-04 14:18:41.190399 UTC

{offset
  c4dP:
      R1 = R1 + 1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Proc points ====================
2016-08-04 14:18:41.191411 UTC

Foo_static_entry
[c4dP]
{offset
  c4dP:
      R1 = R1 + 1;
      call (I64[P64[(old + 8)]])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2016-08-04 14:18:41.192614 UTC

{offset
  c4dP:
      R1 = R1 + 1;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2016-08-04 14:18:41.193653 UTC

{offset
  c4dP:
      R1 = R1 + 1;
      call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2016-08-04 14:18:41.194582 UTC

[(c4dP, {})]


==================== procpoint map ====================
2016-08-04 14:18:41.195255 UTC

[(c4dP, <procpt>)]


==================== Post splitting ====================
2016-08-04 14:18:41.195937 UTC

Foo_static_entry() //  [R1]
        { info_tbl: [(c4dP,
                      label: Foo_static_info
                      rep:HeapRep static {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4dP:
          R1 = R1 + 1;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== after setInfoTableStackMap ====================
2016-08-04 14:18:41.197606 UTC

Foo_static_entry() //  [R1]
        { info_tbl: [(c4dP,
                      label: Foo_static_info
                      rep:HeapRep static {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4dP:
          R1 = R1 + 1;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2016-08-04 14:18:41.199158 UTC

Foo_static_entry() //  [R1]
        { info_tbl: [(c4dP,
                      label: Foo_static_info
                      rep:HeapRep static {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
          stack_info: arg_space: 0 updfr_space: Nothing
        }
    {offset
      c4dP:
          R1 = R1 + 1;
          call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2016-08-04 14:18:41.201526 UTC

[Foo_con_entry() //  [R1]
         { info_tbl: [(c4dO,
                       label: Foo_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4dO:
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foo_static_entry() //  [R1]
         { info_tbl: [(c4dP,
                       label: Foo_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4dP:
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:18:41.204517 UTC

[Foo_con_entry() //  [R1]
         { info_tbl: [(c4dO,
                       label: Foo_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4dO:
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foo_static_entry() //  [R1]
         { info_tbl: [(c4dP,
                       label: Foo_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,70,111,111]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4dP:
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2016-08-04 14:18:41.223381 UTC

[section "relreadonly" {
     S3If_srt:
         const $fShowFoo2_closure;
         const $w$cshowsPrec_closure;
         const $fShowFoo1_closure;
         const $fShowFoo_$cshowList_closure;
         const $fShowFoo_$cshow_closure;
         const childHandler1_closure;
         const stdout_closure;
         const hPutStr2_closure;
         const main1_closure;
         const runMainIO1_closure;
         const main5_closure;
 }]

